<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术特工队</title>
  
  <subtitle>人因梦想而伟大，因坚持而可贵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wxtlife.com/"/>
  <updated>2018-05-20T14:36:10.773Z</updated>
  <id>http://www.wxtlife.com/</id>
  
  <author>
    <name>WangXin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文章首发公众号【技术特工队】</title>
    <link href="http://www.wxtlife.com/2020/01/01/my-blog-step-wxtlife-com/"/>
    <id>http://www.wxtlife.com/2020/01/01/my-blog-step-wxtlife-com/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2018-05-20T14:36:10.773Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h3 id="【技术特工队】"><a href="#【技术特工队】" class="headerlink" title="【技术特工队】"></a><a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">【技术特工队】</a></h3><p><img src="http://www.wxtlife.com/img/qrcode/qrcode.jpg" alt="技术特工队"> </p><h5 id="分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。"><a href="#分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。" class="headerlink" title="分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。"></a>分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。</h5><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;vip-container&quot;&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一
      
    
    </summary>
    
      <category term="Blog" scheme="http://www.wxtlife.com/categories/Blog/"/>
    
    
      <category term="Blog" scheme="http://www.wxtlife.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>OSX AutoLayout原理介绍</title>
    <link href="http://www.wxtlife.com/2018/11/06/osx-autolayout/"/>
    <id>http://www.wxtlife.com/2018/11/06/osx-autolayout/</id>
    <published>2018-11-06T13:25:58.000Z</published>
    <updated>2019-10-20T15:57:59.603Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3><h3 id="AutoLayout介绍"><a href="#AutoLayout介绍" class="headerlink" title="AutoLayout介绍"></a>AutoLayout介绍</h3><p>Auto Layout 是苹果公司在iOS6发布的界面布局技术，为了适配不同大小屏幕及屏幕变化而推出的一种技术方案，旨在实现一次编写布局界面UI，自动适应所有屏幕布局，并随着iOS SDK的迭代逐步完善了各种布局API、提供多种使用Auto Layout的布局方式。实际上Auto Layout算法本身并非有Apple发明，Auto Layout源于Cassary约束解析工具包。该算法由Alan Borning、Kim Marriott、Peter Stuckey、Yi Xiao于1997年发布，该算法的主要思想是：将基于约束系统的布局规则（本质上是表示视图布局关系的线性方程组）转化为表示规则的视图几何参数。</p><h3 id="传统的布局"><a href="#传统的布局" class="headerlink" title="传统的布局"></a>传统的布局</h3><h4 id="frame-布局"><a href="#frame-布局" class="headerlink" title="frame 布局"></a>frame 布局</h4><p>传统的布局方式是基于Frame来做UI控件的界面布局的,即设置控件在父视图中的起始坐标点Origin(x,y)和控件的大小Size(width,height)，为了精确，我们必须计算每个视图的frame。但布局一旦发生变化，相关frame都需要重新计算。然后这些计算都需要不断的手动动态的去计算，导致一旦有变化，就会需要去维护和调试。</p><h4 id="自动缩放（auto-resizing）"><a href="#自动缩放（auto-resizing）" class="headerlink" title="自动缩放（auto resizing）"></a>自动缩放（auto resizing）</h4><p>自动缩放的出现在一定程度上减轻了我们的负担。自动缩放规定父视图的frame变化时，视图的frame如何应对。如此一来，简化了布局响应外部变化所需的工作。但是他仅能应对外部父布局的变化，自身大小的变化则无法进行处理。</p><a id="more"></a><h3 id="AutoLayout剖析"><a href="#AutoLayout剖析" class="headerlink" title="AutoLayout剖析"></a>AutoLayout剖析</h3><h4 id="布局变化原因"><a href="#布局变化原因" class="headerlink" title="布局变化原因"></a>布局变化原因</h4><p><strong>外在变化：</strong> 窗口缩放，设备旋转，屏幕尺寸不同，分屏模式等。<br><strong>内在变化：</strong> 内容展示变化，国际化，字体变化等。</p><h4 id="AutoLayout方程式"><a href="#AutoLayout方程式" class="headerlink" title="AutoLayout方程式"></a>AutoLayout方程式</h4><p>先来看一张官方的图，表示一个约束的表达式。</p><p><img src="https://upload-images.jianshu.io/upload_images/696463-66769da1d41fafac.png" alt="autoLayout"></p><p>下面来具体介绍下其各个变量的意义。</p><ul><li>Item1、Item2：一般是UIView，表示该约束关系对应的两个视图，当约束等式表示尺寸时，其中一个Item为nil。</li><li>Attribute1、Attribute2：NSLayoutAttribute类型，表示约束属性。当约束等式表示尺寸时，其中一个Attribute为NSLayoutAttributeNotAnAttribute，表示占位，无任何意义。具体看下图</li><li>Relationship：NSLayoutRelation类型，表示约束关系，可以是=、&gt;=、&lt;=。</li><li>Multiplier：CGFloat类型，表示倍数关系，一般用于尺寸（eg：Item1的宽度为Item2的两倍，则Multiplier为2.0）</li><li>Constant：CGFloat类型，表示常数。</li></ul><p><img src="http://macdev.io/ebook/media/14503524325175/AutoLayoutAttributes.png" alt="Attribute"></p><blockquote><p><strong>注意</strong></p><ul><li>只有同类型的约束才能互相做约束</li><li>建议开发中一直使用leading、trailing。leading表示前边、trailing表示后边，在阅读习惯从左到右的语言中，leading相当于left、trailing相当于right。在从右到左的语言中，leading相当于right、trailing相当于left。</li></ul></blockquote><h4 id="AutoLayout-本质"><a href="#AutoLayout-本质" class="headerlink" title="AutoLayout 本质"></a>AutoLayout 本质</h4><p>Auto Layout本质就是一个线性方程解析Engine。基于Auto Layout的布局，不在需要像frame时代一样，关注视图尺寸、位置的常数，转而关注视图之间关系，描述一个表示视图间布局关系的约束集合，由Engine解析出最终数值。</p><p>一个约束对象NSLayoutConstraint，本质上是表示两个视图之间（当表示尺寸时只表示视图本身）布局关系的一个线性方程，该方程可以是线性等式、也可以是线性不等式。</p><p>多个约束对象组成是一个约束集合，本质上是表示某个界面上多个视图之间布局关系的线性方程组。方程组中的多个线性方程，以数字标识的优先级进行排序（UILayoutPriority，本质上是浮点型float）。</p><p>Auto Layout Engine根据按照线性方程的优先级从高到底对线性方程组进行解析，求得方程组的解。</p><ul><li>当设置的约束欠缺，即存在约束歧义，线性方程组有多个解，而不是唯一解。这便是约束错误的一种：约束不充分，可能导致视图丢失，视图错位。</li><li>当设置的约束过多，存在多个优先级相同的描述同一个关系的线性方程，并且约束产生的效果不同（例如 View1.left = View2.right + 10 ; View1.left = View2.right + 20，优先级都为1000），线程方程组无解。这是约束错误的另一种：约束不可满足，产生约束约束冲突，控制台会Log错误日志，同样可能造成布局错误。</li></ul><h4 id="约束优先级"><a href="#约束优先级" class="headerlink" title="约束优先级"></a>约束优先级</h4><p>默认创建出来的约束优先级为UILayoutPriorityRequired（1000），称为必需约束；其他优先级小于1000的约束称为可选约束。Auto Layout Engine进行约束解析时，尝试着按优先级从高到低满足约束集合中的每一个约束，如果无法满足某个可选约束，则跳过；当优先级不同的两个约束描述的是同一个布局关系，Auto Layout会跳过优先级较低的约束。</p><h4 id="Intrinsic-Content-Size"><a href="#Intrinsic-Content-Size" class="headerlink" title="Intrinsic Content Size"></a>Intrinsic Content Size</h4><p>对于文本/图片等一些视图控件，可以通过其内在content推算出控件的大小。不是所有的控件都有Intrinsic Content Size。按钮,文本label,文字输入TextField,TextView,ImageView都可以根据内在的content内容计算控件的大小。</p><p>基于控件的内容content，有2个特定的约束:content hugging 收缩约束 和 content compression 扩张约束，这2个约束简称为CHCR。</p><p><img src="http://macdev.io/ebook/media/14503524325175/AutoLayoutCHCR.png" alt=""></p><p>IntrinsicHeight代表内部内容的高，IntrinsicWidth代表内部内容的宽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//content compression的约束条件：</span><br><span class="line">View.height &gt;= IntrinsicHeight</span><br><span class="line">View.width &gt;= IntrinsicWidth</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//content hugging的约束条件：</span><br><span class="line">View.height &lt;= IntrinsicHeight</span><br><span class="line">View.width &lt;= IntrinsicWidth</span><br></pre></td></tr></table></figure><p>从这几组约束来看，如果需要完整的显示内容就需要content compression的优先级尽量高，而如果需要尽量显示的紧凑一些占用空间小一些可以将content hugging优先级尽量设置高一些。</p><p>更加简洁易懂点的描述如下：</p><ul><li>Content Hugging Priority: 该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸</li><li>Content Compression Resistance Priority: 该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩</li></ul><h3 id="Auto-Layout布局机制"><a href="#Auto-Layout布局机制" class="headerlink" title="Auto Layout布局机制"></a>Auto Layout布局机制</h3><p><img src="https://upload-images.jianshu.io/upload_images/696463-22995f9148fa634e.jpg" alt=""><br>创建视图树、描述视图之间的约束、设置优先级、设置视图内容，Layout Engine计算出视图位置、尺寸，绘制出对应的图层。</p><p>Auto Layout布局过程涉及延迟机制，并非一有约束更新就马上进行布局重绘，当有约束更改时，系统的默认做法是延迟更新，目的是实现批量更改约束、绘制视图，避免频繁遍历视图层级，优化性能。当更新约束太慢影响到后序代码逻辑，也可强制马上更新。</p><p><img src="https://upload-images.jianshu.io/upload_images/696463-13cb1bc293287cf9.jpg" alt=""></p><ul><li>App启动后开启RunLoop，循环检测图层树中是否存在约束变化；</li><li>当发生Constrints Change（直接or间接设置、更新、移除约束）,RunLoop检测到约束变化；</li><li>RunLoop发现约束变化后，就会进入Deferred Layout阶段，视图的位置、尺寸值会在这个过程计算，设置到对应视图上，并绘制出来；</li><li>执行完一轮布局，RunLoop会继续检查视图树的约束更新情况，当再次发现约束更新，则执行新一轮布局……</li></ul><h4 id="VFL"><a href="#VFL" class="headerlink" title="VFL"></a>VFL</h4><p>略<br>官方文档<br><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1</a></p><h3 id="约束库使用建议"><a href="#约束库使用建议" class="headerlink" title="约束库使用建议"></a>约束库使用建议</h3><p>使用 <a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a> 来进行代码控制布局约束。</p><blockquote><p>参考连接：<br><a href="http://macdev.io/ebook/autoLayout.html" target="_blank" rel="noopener">http://macdev.io/ebook/autoLayout.html</a><br><a href="https://juejin.im/post/5b1ea5046fb9a01e2b2cc4a7" target="_blank" rel="noopener">https://juejin.im/post/5b1ea5046fb9a01e2b2cc4a7</a>  </p></blockquote><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;AutoLayout介绍&quot;&gt;&lt;a href=&quot;#AutoLayout介绍&quot; class=&quot;headerlink&quot; title=&quot;AutoLayout介绍&quot;&gt;&lt;/a&gt;AutoLayout介绍&lt;/h3&gt;&lt;p&gt;Auto Layout 是苹果公司在iOS6发布的界面布局技术，为了适配不同大小屏幕及屏幕变化而推出的一种技术方案，旨在实现一次编写布局界面UI，自动适应所有屏幕布局，并随着iOS SDK的迭代逐步完善了各种布局API、提供多种使用Auto Layout的布局方式。实际上Auto Layout算法本身并非有Apple发明，Auto Layout源于Cassary约束解析工具包。该算法由Alan Borning、Kim Marriott、Peter Stuckey、Yi Xiao于1997年发布，该算法的主要思想是：将基于约束系统的布局规则（本质上是表示视图布局关系的线性方程组）转化为表示规则的视图几何参数。&lt;/p&gt;
&lt;h3 id=&quot;传统的布局&quot;&gt;&lt;a href=&quot;#传统的布局&quot; class=&quot;headerlink&quot; title=&quot;传统的布局&quot;&gt;&lt;/a&gt;传统的布局&lt;/h3&gt;&lt;h4 id=&quot;frame-布局&quot;&gt;&lt;a href=&quot;#frame-布局&quot; class=&quot;headerlink&quot; title=&quot;frame 布局&quot;&gt;&lt;/a&gt;frame 布局&lt;/h4&gt;&lt;p&gt;传统的布局方式是基于Frame来做UI控件的界面布局的,即设置控件在父视图中的起始坐标点Origin(x,y)和控件的大小Size(width,height)，为了精确，我们必须计算每个视图的frame。但布局一旦发生变化，相关frame都需要重新计算。然后这些计算都需要不断的手动动态的去计算，导致一旦有变化，就会需要去维护和调试。&lt;/p&gt;
&lt;h4 id=&quot;自动缩放（auto-resizing）&quot;&gt;&lt;a href=&quot;#自动缩放（auto-resizing）&quot; class=&quot;headerlink&quot; title=&quot;自动缩放（auto resizing）&quot;&gt;&lt;/a&gt;自动缩放（auto resizing）&lt;/h4&gt;&lt;p&gt;自动缩放的出现在一定程度上减轻了我们的负担。自动缩放规定父视图的frame变化时，视图的frame如何应对。如此一来，简化了布局响应外部变化所需的工作。但是他仅能应对外部父布局的变化，自身大小的变化则无法进行处理。&lt;/p&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（五）</title>
    <link href="http://www.wxtlife.com/2018/08/27/osx-dev-summary-5/"/>
    <id>http://www.wxtlife.com/2018/08/27/osx-dev-summary-5/</id>
    <published>2018-08-27T11:52:08.000Z</published>
    <updated>2018-08-27T11:58:05.169Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3><h3 id="TableView"><a href="#TableView" class="headerlink" title="TableView"></a>TableView</h3><p>在 OSX 中有一些列表的需求，这时候需要使用 OSX 中 TableView 来实现，但是这个 TableView 与 Android的 ListView 不太一样。使用还是比较复杂的。下面做一个简单的介绍，</p><h4 id="TableView-的使用"><a href="#TableView-的使用" class="headerlink" title="TableView 的使用"></a>TableView 的使用</h4><ol><li><p>首先需要在布局文件中，拖出一个TableView，并且添加相应的每列的数据源，主要是 使用 <code>TableCellView</code>， 里面默认的控件有一个<code>TextFiled</code>和一个<code>ImageView</code>,如果需要其他控件则需要自己进行自定义进行实现，下一小节会说到。</p></li><li><p>需要对 TableView 设置一个数据源，需要实现 <code>NSTableViewDataSource</code>接口, 并对 <code>TableView</code> 设置数据源，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tableView.dataSource = self</span><br><span class="line"></span><br><span class="line">extension MainView: NSTableViewDataSource &#123;</span><br><span class="line">    func numberOfRows(in tableView: NSTableView) -&gt; Int &#123;</span><br><span class="line">        return dataSources.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对每行的数据进行渲染处理，设置<code>delegate</code>和<code>target</code>代理，并实现 <code>NSTableViewDelegate</code>接口中如下方法 </p></li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableView.delegate = self</span><br><span class="line">tableView.target = self</span><br></pre></td></tr></table></figure><p>下面为实现<code>NSTableViewDelegate</code>接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">extension MainView: NSTableViewDelegate &#123;</span><br><span class="line">    fileprivate enum CellIdentifiers &#123;</span><br><span class="line">        static let avatarImgCell = NSUserInterfaceItemIdentifier(&quot;image&quot;)</span><br><span class="line">        static let nickNameCell = NSUserInterfaceItemIdentifier(&quot;name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -&gt; NSView? &#123;</span><br><span class="line">        let item = dataSouece[row]</span><br><span class="line">        // 图片的资源</span><br><span class="line">        var image: NSImage?</span><br><span class="line">        //名称</span><br><span class="line">        var nickName: String = &quot;&quot;</span><br><span class="line">        var cellIdentifier: NSUserInterfaceItemIdentifier = CellIdentifiers.nickNameCell</span><br><span class="line">        if tableColumn == tableView.tableColumns[0] &#123;</span><br><span class="line">            image = #imageLiteral(resourceName: &quot;member_avatar&quot;)</span><br><span class="line">            cellIdentifier = CellIdentifiers.avatarImgCell</span><br><span class="line">        &#125; else if tableColumn == tableView.tableColumns[1] &#123;</span><br><span class="line">            nickName = item.nickName</span><br><span class="line">            cellIdentifier = CellIdentifiers.nickNameCell</span><br><span class="line">        &#125;</span><br><span class="line">        // 通过 NSUserInterfaceItemIdentifier 构建每一个 CellView </span><br><span class="line">        let view = tableView.makeView(withIdentifier: cellIdentifier, owner: nil)</span><br><span class="line">        if let cellItem = view as? NSTableCellView &#123;</span><br><span class="line">            // 对 CellView 中默认控件进行设置每个资源</span><br><span class="line">            cellItem.textField?.stringValue = nickName</span><br><span class="line">            cellItem.imageView?.image = image</span><br><span class="line">            return cellItem </span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的方法可以对基本的 TableView 进行渲染处理，可以看到 <code>NSTableCellView</code> 类中也只有默认 <code>textFiled</code> 与 <code>NSImageView</code> 控件，如果需要在一个<code>NSTableCellView</code>中有两个控件，或者有其他的控件如：NSButton等，则目前是无法完成的，那接下来就介绍下 <code>NSTableCellView</code>的自定义操作。</p><h4 id="TableView-中-TableCellView的自定义"><a href="#TableView-中-TableCellView的自定义" class="headerlink" title="TableView 中 TableCellView的自定义"></a>TableView 中 TableCellView的自定义</h4><ol><li>自定义<code>NSTableCellView</code>，首先先创建一个<code>CustomerTableViewCell</code>类，其继承自<code>NSTableCellView</code>,</li><li>其次主要在 xib 或者 storyboard 的 <code>TableView</code> 中 <code>NSTableCellView</code> 添加新的控件，或者移除掉原来的，添加新的控件进去，并设置相应的约束，与普通 View 操作一致的。最后将自定义的<code>NSTableCellView</code>的类名指定为自定义的类名。</li><li>将新添加的控件拖到<code>CustomerTableViewCell</code>中连线，这样 <code>CustomerTableViewCell</code>就可以控制自定义添加的控件了。</li><li>在上面的TableView 回调中设置相应的值。</li></ol><p>我们拿上面的例子来改造下，</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerNSTableCellView</span>: <span class="title">NSTableCellView</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加了一个 age 的label 在同一个CellView中</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> ageLabel: <span class="type">NSTextField</span>!</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame frameRect: <span class="type">NSRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frameRect)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainView</span>: <span class="title">NSTableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int)</span></span> -&gt; <span class="type">NSView</span>? &#123;</span><br><span class="line">        <span class="keyword">let</span> item = dataSouece[row]</span><br><span class="line">        <span class="comment">// 图片的资源</span></span><br><span class="line">        <span class="keyword">var</span> image: <span class="type">NSImage</span>?</span><br><span class="line">        <span class="comment">//名称</span></span><br><span class="line">        <span class="keyword">var</span> nickName: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">        <span class="keyword">var</span> age : <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cellIdentifier: <span class="type">NSUserInterfaceItemIdentifier</span> = <span class="type">CellIdentifiers</span>.nickNameCell</span><br><span class="line">        <span class="keyword">if</span> tableColumn == tableView.tableColumns[<span class="number">0</span>] &#123;</span><br><span class="line">            image = #imageLiteral(resourceName: <span class="string">"member_avatar"</span>)</span><br><span class="line">            cellIdentifier = <span class="type">CellIdentifiers</span>.avatarImgCell</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tableColumn == tableView.tableColumns[<span class="number">1</span>] &#123;</span><br><span class="line">            nickName = item.nickName</span><br><span class="line">            age = item.age</span><br><span class="line">            cellIdentifier = <span class="type">CellIdentifiers</span>.nickNameCell</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 NSUserInterfaceItemIdentifier 构建每一个 CellView </span></span><br><span class="line">        <span class="keyword">let</span> view = tableView.makeView(withIdentifier: cellIdentifier, owner: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cellItem = view <span class="keyword">as</span>? <span class="type">NSTableCellView</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cellItem <span class="keyword">is</span> <span class="type">CustomerNSTableCellView</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> userCellItem  = cellItem <span class="keyword">as</span>! <span class="type">CustomerNSTableCellView</span></span><br><span class="line">                userCellItem.ageLabel.stringValue = age</span><br><span class="line">                userCellItem.textField?.stringValue = nickName</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 对 CellView 中默认控件进行设置每个资源</span></span><br><span class="line">                cellItem.textField?.stringValue = nickName <span class="comment">// 这里默认的Cell里没有则控件会为空。</span></span><br><span class="line">                cellItem.imageView?.image = image</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cellItem </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此可以在每个 <code>NSTableCellView</code>中进行任意的自定义了，实现自己想要实现的功能。</p><h3 id="NSStoryboardSegue-的自定义"><a href="#NSStoryboardSegue-的自定义" class="headerlink" title="NSStoryboardSegue 的自定义"></a>NSStoryboardSegue 的自定义</h3><p><code>NSStoryboardSegue</code> 的功能是什么呢？官方文档是这样介绍的: <code>A transition or containment relationship between two scenes in a storyboard.</code>  也就是在多个 storyboard 或者 window 中进行的连线，这个连线可以定义一些功能，比如说<code>show</code>操作等等，比如我们点击一个按钮，打开（show）另外一个 window 则可以使用它进行连线操作后，这条线就是<code>NSStoryboardSegue</code>类型的。</p><p>那么为什么要自定义它呢？ 因为如果在 storyboard 中对某个控件连线使用 <code>NSStoryboardSegue</code> 后，如果在对该控件执行 <code>action</code> 操作时，<code>action</code>操作会不起作用，这点需要吐槽下苹果的设计了。如果要想再使用<code>NSStoryboardSegue</code>后还可以指定其他操作，则只能自定义 <code>NSStoryboardSegue</code>了。</p><p>在自定义中复写<code>perform()</code>方法，可以添加自定义的一些操作了。<br>如果一个项目中有多个需要自定义，可以使用<code>NSStoryboardSegue</code>中的<code>identifier</code>来区分不同的<code>NSStoryboardSegue</code>。<code>identifier</code> 是在每个每条连线<code>Segue</code>上设置，同时记得把类指定为我们定义的类型。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CustomerStoryboardSegue: NSStoryboardSegue &#123;</span><br><span class="line">    </span><br><span class="line">    override func perform() &#123;</span><br><span class="line">        super.perform()</span><br><span class="line">        // 下面则可以做其他的事情了。通过self.identifier 来区分不同的 Sugue,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;TableView&quot;&gt;&lt;a href=&quot;#TableView&quot; class=&quot;headerlink&quot; title=&quot;TableView&quot;&gt;&lt;/a&gt;TableView&lt;/h3&gt;&lt;p&gt;在 OSX 中有一些列表的需求，这时候需要使用 OSX 中 TableView 来实现，但是这个 TableView 与 Android的 ListView 不太一样。使用还是比较复杂的。下面做一个简单的介绍，&lt;/p&gt;
&lt;h4 id=&quot;TableView-的使用&quot;&gt;&lt;a href=&quot;#TableView-的使用&quot; class=&quot;headerlink&quot; title=&quot;TableView 的使用&quot;&gt;&lt;/a&gt;TableView 的使用&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先需要在布局文件中，拖出一个TableView，并且添加相应的每列的数据源，主要是 使用 &lt;code&gt;TableCellView&lt;/code&gt;， 里面默认的控件有一个&lt;code&gt;TextFiled&lt;/code&gt;和一个&lt;code&gt;ImageView&lt;/code&gt;,如果需要其他控件则需要自己进行自定义进行实现，下一小节会说到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要对 TableView 设置一个数据源，需要实现 &lt;code&gt;NSTableViewDataSource&lt;/code&gt;接口, 并对 &lt;code&gt;TableView&lt;/code&gt; 设置数据源，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tableView.dataSource = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;extension MainView: NSTableViewDataSource &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func numberOfRows(in tableView: NSTableView) -&amp;gt; Int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return dataSources.count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对每行的数据进行渲染处理，设置&lt;code&gt;delegate&lt;/code&gt;和&lt;code&gt;target&lt;/code&gt;代理，并实现 &lt;code&gt;NSTableViewDelegate&lt;/code&gt;接口中如下方法 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（四）</title>
    <link href="http://www.wxtlife.com/2018/08/19/osx-dev-summary-4/"/>
    <id>http://www.wxtlife.com/2018/08/19/osx-dev-summary-4/</id>
    <published>2018-08-19T14:04:25.000Z</published>
    <updated>2018-08-19T14:07:57.510Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3><h3 id="OSX-中Window中常用的一些属性"><a href="#OSX-中Window中常用的一些属性" class="headerlink" title="OSX 中Window中常用的一些属性"></a>OSX 中Window中常用的一些属性</h3><h4 id="1-applicationShouldTerminate"><a href="#1-applicationShouldTerminate" class="headerlink" title="1. applicationShouldTerminate"></a>1. applicationShouldTerminate</h4><p>在 AppDelegate 中，复写<code>applicationShouldTerminate</code>方法可以达到控制是否点击关闭按钮是否关闭应用的效果，其返回值<code>TerminateReply</code>有三个值，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum TerminateReply : UInt &#123;</span><br><span class="line">    case terminateCancel // 取消掉关闭，等于点击无作用</span><br><span class="line">    case terminateNow   // 现在直接关闭</span><br><span class="line">    case terminateLater  // 暂且不关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在下面的返回值可根据一些条件进行判断，比如有些应用点击关闭按钮是仅将窗口关闭，并最小化应用不退出，则可以根据设置情况进行返回不同的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func applicationShouldTerminate(_ sender: NSApplication) -&gt; NSApplication.TerminateReply &#123;</span><br><span class="line">    return .terminateNow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-applicationShouldTerminateAfterLastWindowClosed"><a href="#2-applicationShouldTerminateAfterLastWindowClosed" class="headerlink" title="2. applicationShouldTerminateAfterLastWindowClosed"></a>2. applicationShouldTerminateAfterLastWindowClosed</h4><p>在 AppDelegate中 <code>applicationShouldTerminateAfterLastWindowClosed</code>中的作用为确认是否是等待所有窗口关闭后才关闭整个应用的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -&gt; Bool &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a> <h4 id="3-NSWindow-windowShouldClose"><a href="#3-NSWindow-windowShouldClose" class="headerlink" title="3. NSWindow windowShouldClose"></a>3. NSWindow windowShouldClose</h4><p>在每个NSWindow中,有很多的NSWindowDelegate方法，其中<code>windowShouldClose</code>可以根据返回值控制是否可以关闭此窗口，比如有些情况我们的内容没保存，而直接点击<code>关闭</code>按钮时，可进行不关闭此窗口，而是进行提示，那么就可以通过此属性进行控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func windowShouldClose(_ sender: NSWindow) -&gt; Bool &#123;</span><br><span class="line">    return false // window 不关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-NSWindow-单例"><a href="#4-NSWindow-单例" class="headerlink" title="4. NSWindow 单例"></a>4. NSWindow 单例</h4><p>在应用中经常会有很多的弹窗，但这些弹框是需要只弹一个的（未关闭多次点击不新建，显示原来的那个），这时候就需要设置Window的属性。具体如下：<br>选中 <code>目标window</code> 上的<code>Window Controller</code>然后在属性栏中选中<code>show the attributes inspector</code>即可看到<code>Presentation</code>,然后选则<code>single</code>即可，默认是<code>Multiple</code>。</p><h3 id="自定义控件属性"><a href="#自定义控件属性" class="headerlink" title="自定义控件属性"></a>自定义控件属性</h3><p>在 Android 中自定义View，可以自定义很多的属性，对控件进行设置，在 iOS/OSX 中同样存在对自定义控件添加属性的方法，具体为<code>IBInspectable</code>和<code>IBDesignable</code>两个属性，定义了此属性后，在XCode中设置了View为此类型后，可以有可视化的设置项，很是方便，具体可以参考这篇文章:<a href="https://zhangbuhuai.com/ibinspectable-and-ibdesignable/" target="_blank" rel="noopener">https://zhangbuhuai.com/ibinspectable-and-ibdesignable/</a></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;OSX-中Window中常用的一些属性&quot;&gt;&lt;a href=&quot;#OSX-中Window中常用的一些属性&quot; class=&quot;headerlink&quot; title=&quot;OSX 中Window中常用的一些属性&quot;&gt;&lt;/a&gt;OSX 中Window中常用的一些属性&lt;/h3&gt;&lt;h4 id=&quot;1-applicationShouldTerminate&quot;&gt;&lt;a href=&quot;#1-applicationShouldTerminate&quot; class=&quot;headerlink&quot; title=&quot;1. applicationShouldTerminate&quot;&gt;&lt;/a&gt;1. applicationShouldTerminate&lt;/h4&gt;&lt;p&gt;在 AppDelegate 中，复写&lt;code&gt;applicationShouldTerminate&lt;/code&gt;方法可以达到控制是否点击关闭按钮是否关闭应用的效果，其返回值&lt;code&gt;TerminateReply&lt;/code&gt;有三个值，具体如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public enum TerminateReply : UInt &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case terminateCancel // 取消掉关闭，等于点击无作用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case terminateNow   // 现在直接关闭&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case terminateLater  // 暂且不关闭&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在下面的返回值可根据一些条件进行判断，比如有些应用点击关闭按钮是仅将窗口关闭，并最小化应用不退出，则可以根据设置情况进行返回不同的值。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func applicationShouldTerminate(_ sender: NSApplication) -&amp;gt; NSApplication.TerminateReply &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return .terminateNow&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-applicationShouldTerminateAfterLastWindowClosed&quot;&gt;&lt;a href=&quot;#2-applicationShouldTerminateAfterLastWindowClosed&quot; class=&quot;headerlink&quot; title=&quot;2. applicationShouldTerminateAfterLastWindowClosed&quot;&gt;&lt;/a&gt;2. applicationShouldTerminateAfterLastWindowClosed&lt;/h4&gt;&lt;p&gt;在 AppDelegate中 &lt;code&gt;applicationShouldTerminateAfterLastWindowClosed&lt;/code&gt;中的作用为确认是否是等待所有窗口关闭后才关闭整个应用的作用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -&amp;gt; Bool &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（三）</title>
    <link href="http://www.wxtlife.com/2018/08/12/osx-dev-summary-3/"/>
    <id>http://www.wxtlife.com/2018/08/12/osx-dev-summary-3/</id>
    <published>2018-08-12T15:51:41.000Z</published>
    <updated>2018-08-27T12:00:34.640Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3><h3 id="NSStackView"><a href="#NSStackView" class="headerlink" title="NSStackView"></a>NSStackView</h3><p>OSX 中 NSStackView  使用自动布局（系统的自动布局特性）来根据你的要求管理和对齐一组视图。可以设置为 水平方向，或者垂直方向。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.orientation = .horizontal //水平方向</span><br><span class="line">stackView.orientation = .vertical  //垂直方向</span><br></pre></td></tr></table></figure></p><h4 id="添加子view"><a href="#添加子view" class="headerlink" title="添加子view"></a>添加子view</h4><p>为stackView 中添加 子view的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stackView.addArrangedSubview(view)</span><br></pre></td></tr></table></figure></p><p><strong>注意： 由于stackView 是继承自 NSView， 所有也会有 <code>addSubview(view)</code> 的方法，但是调用此方法，不会自动扩大 stackView 的宽高，而导致新加的view 显示不出来。</strong></p><h4 id="移除子view"><a href="#移除子view" class="headerlink" title="移除子view"></a>移除子view</h4><p>移除子 View 采用如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.removeArrangedSubview(view) </span><br><span class="line">view.removeFromSuperview()</span><br></pre></td></tr></table></figure></p><p><strong>注意：子view从stackView移除后，还必须将子view从父view中移除</strong></p><a id="more"></a><h4 id="指定添加的每个View的间距"><a href="#指定添加的每个View的间距" class="headerlink" title="指定添加的每个View的间距"></a>指定添加的每个View的间距</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//指定每个添加的每个View间的间距</span><br><span class="line">stackView.spacing = 5</span><br><span class="line"></span><br><span class="line">// 在customerView 后设置space为10</span><br><span class="line">stackView.setCustomSpacing(10, customerView）</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：<br><a href="https://swift.gg/2016/03/31/ios9-uistackview-guide-swift/" target="_blank" rel="noopener">https://swift.gg/2016/03/31/ios9-uistackview-guide-swift/</a>  </p></blockquote><h3 id="OSX坐标系翻转"><a href="#OSX坐标系翻转" class="headerlink" title="OSX坐标系翻转"></a>OSX坐标系翻转</h3><p>这里为什么要说坐标系呢？ 因为在 iOS等其他移动设备上远点都左上角，而在OSX中坐标原点在左下角，这导致在有些 iOS 库想兼容到 OSX就要做很多的适配的问题。然而系统提供了坐标翻转的函数，可以很方便的将 OSX 坐标原点转化为 左上角，保持与iOS一致，在使用的NSView中复写如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isFlipped &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://www.macdev.io/ebook/nsview.html" target="_blank" rel="noopener">http://www.macdev.io/ebook/nsview.html</a></p><h3 id="Swift-倒序循环"><a href="#Swift-倒序循环" class="headerlink" title="Swift 倒序循环"></a>Swift 倒序循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in (0..&lt;3).reversed()</span><br><span class="line">//表示：2，1，0</span><br><span class="line"></span><br><span class="line">for i in stride(from:3, through:0, by:-1)  </span><br><span class="line">//表示3，2，1，0</span><br></pre></td></tr></table></figure><h3 id="NSWindow"><a href="#NSWindow" class="headerlink" title="NSWindow"></a>NSWindow</h3><h4 id="NSApp-keyWindow"><a href="#NSApp-keyWindow" class="headerlink" title="NSApp.keyWindow"></a>NSApp.keyWindow</h4><p>表示当前正在接受键盘事件的窗口，比如一个应用有多个窗口，当前窗口正在接受键盘事件或状态栏未灰掉的当前的窗口为 keyWindow, 官方文档对返回值解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The value of this property is nil when there is no window receiving keyboard events. </span><br><span class="line">The property might be nil because the app’s storyboard file has not yet finished loading or when the receiver is not active.</span><br></pre></td></tr></table></figure></p><p>也就是说如果如果没有窗口接收键盘事件或者storyboard文件还未加载完，或窗口未激活，将返回的都是 nil。</p><h4 id="NSApp-mainWindow"><a href="#NSApp-mainWindow" class="headerlink" title="NSApp.mainWindow"></a>NSApp.mainWindow</h4><p>表示一个应用程序的主Window，官方的返回值说明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The value in this property is nil when the app’s storyboard or nib file has not yet finished loading. It might also be nil when the app is inactive or hidden.</span><br></pre></td></tr></table></figure></p><p>当app的 storyboard 或者 xib文件未加载完成，或者当前窗口为未激活状态或者是隐藏状态时，将返回nil。</p><p><strong>注意： 所以项目中需要使用mainWindow 或者keyWinodw 时需要注意为空的情况。</strong></p><p><a href="https://zonble.net/archives/2010_08/1352.php" target="_blank" rel="noopener">https://zonble.net/archives/2010_08/1352.php</a></p><h4 id="window-窗口最小化"><a href="#window-窗口最小化" class="headerlink" title="window 窗口最小化"></a>window 窗口最小化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使当前的窗口最小化</span><br><span class="line">window.miniaturize(self)</span><br><span class="line">// 使当前的窗口恢复原来状态取消最小化</span><br><span class="line">window.deminiaturize(self)</span><br><span class="line">// 如果当前为最小化则最大化，如果当前为最大化则最小化，取反。</span><br><span class="line">window.toggleFullScreen(nil)</span><br><span class="line">// 判断是否为全屏的状态</span><br><span class="line">let isFullScreen = window.styleMask.contains(.fullScreen)</span><br></pre></td></tr></table></figure><h4 id="window-storyboard-代码加载"><a href="#window-storyboard-代码加载" class="headerlink" title="window storyboard 代码加载"></a>window storyboard 代码加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let mainStoryboard = NSStoryboard(name: NSStoryboard.Name(rawValue: &quot;main&quot;), bundle: nil)</span><br><span class="line">// 使用mainStoryboard自动连线控制的NSWindowController，</span><br><span class="line">let mainWindowController = mainStoryboard.instantiateInitialController() as! MainWindowController</span><br><span class="line">mainWindowController.showWindow(nil) // 显示出来。</span><br></pre></td></tr></table></figure><p>如果storyboard 不是我们默认启动，需要代码启动的化，上面需要我们自行定义一个NSWindow的子类<code>MainWindowController</code>，在初始化完成后强制转化为 <code>MainWindowController</code></p><p>如果已经有一个window启动，需要加载storyboard中的某个viewControl进行替换。可以使用下面的语句进行初始化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mainStoryboard = NSStoryboard(name: NSStoryboard.Name(rawValue: &quot;main&quot;), bundle: nil)</span><br><span class="line">//得到指定的storyboard中指定的ViewController。</span><br><span class="line">let mainViewController = mainStoryboard.instantiateController(withIdentifier: NSStoryboard.SceneIdentifier(rawValue: &quot;InMeetingViewController&quot;)) as? NSViewController</span><br><span class="line">// 将新创建的viewController 赋值给已经存在的Window中的contentViewController。</span><br><span class="line">otherWindowController.contentViewController = mainViewController</span><br></pre></td></tr></table></figure></p><h3 id="objc-setAssociatedObject-objc-getAssociatedObject"><a href="#objc-setAssociatedObject-objc-getAssociatedObject" class="headerlink" title="objc_setAssociatedObject/objc_getAssociatedObject"></a>objc_setAssociatedObject/objc_getAssociatedObject</h3><p>这两个方式是oc中方法，主要功能是什么呢？。在 oc 中可以使用 <code>Category</code>可以对一些系统类进行添加方法，相当于 Swift 中的 <code>extension</code>的概念，但是我们常用有需求希望能够对一个类中添加一个属性，经常是很难弄，但是 oc 就很好的提供了一个方法 <code>objc_setAssociatedObject</code> 来对一个类进行属性的添加扩展。这是一个运行时修改的库，<br>所以必须要先引入 <code>objc/runtime.h</code> </p><h4 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h4><p>具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// object 为需要添加属性的类</span><br><span class="line">// key 为保证对象级别唯一的常量</span><br><span class="line">// value 为object 对所添加对象的值</span><br><span class="line">// policy 为关联的策略。</span><br><span class="line">public func objc_setAssociatedObject(_ object: Any, _ key: UnsafeRawPointer, _ value: Any?, _ policy: objc_AssociationPolicy)</span><br></pre></td></tr></table></figure></p><p>关联的策略就像是在 oc 中自定义 property 的引用类型一样。具体对应的类型如下：</p><table><thead><tr><th>策略</th><th>等价属性</th><th>说明</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>@property (assign) or @property (unsafe_unretained)</td><td>弱引用关联对象 </td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>@property (strong, nonatomic)</td><td>强引用关联对象，且为非原子操作 </td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>@property (copy, nonatomic)</td><td>复制关联对象，且为非原子操作 </td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>@property (strong, atomic)</td><td>强引用关联对象，且为原子操作 </td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>@property (copy, atomic)</td><td>复制关联对象，且为原子操作 </td></tr></tbody></table><p>实例如下对 NSApp 添加一个属性值为test:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 执行一个对象变量，后面使用该对象的地址。</span><br><span class="line"> var keyMainString:UInt8 = 0</span><br><span class="line"> objc_setAssociatedObject(NSApplication.shared, &amp;keyMainString, &quot;test&quot;, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br></pre></td></tr></table></figure></p><h4 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h4><p>上面添加了相应的属性，下面则要获取添加的属性 <code>objc_getAssociatedObject</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let value = objc_getAssociatedObject(NSApplication.shared, &amp;keyMainString)</span><br><span class="line">// 如果上面进行了设置，那么这里将获得的值为“test”</span><br></pre></td></tr></table></figure></p><p>通过上面两个方法就可以对系统类添加一个任意的属性值，和获取系统类的添加的属性值，对了，<strong>如果要移除关联的对象，可以对上面设置的值重新设置为 nil 即可。</strong><br>当然还有一个 <code>objc_removeAssociatedObjects</code>,这样可以把某个对象所设置的所有关联属性全部移除掉，一般都不会这样做，避免引起其他异常。</p><blockquote><p>参考资料：<br><a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/</a><br><a href="https://www.jianshu.com/p/7f7255d4e76d" target="_blank" rel="noopener">https://www.jianshu.com/p/7f7255d4e76d</a></p></blockquote><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;NSStackView&quot;&gt;&lt;a href=&quot;#NSStackView&quot; class=&quot;headerlink&quot; title=&quot;NSStackView&quot;&gt;&lt;/a&gt;NSStackView&lt;/h3&gt;&lt;p&gt;OSX 中 NSStackView  使用自动布局（系统的自动布局特性）来根据你的要求管理和对齐一组视图。可以设置为 水平方向，或者垂直方向。如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stackView.orientation = .horizontal //水平方向&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stackView.orientation = .vertical  //垂直方向&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加子view&quot;&gt;&lt;a href=&quot;#添加子view&quot; class=&quot;headerlink&quot; title=&quot;添加子view&quot;&gt;&lt;/a&gt;添加子view&lt;/h4&gt;&lt;p&gt;为stackView 中添加 子view的方式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stackView.addArrangedSubview(view)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意： 由于stackView 是继承自 NSView， 所有也会有 &lt;code&gt;addSubview(view)&lt;/code&gt; 的方法，但是调用此方法，不会自动扩大 stackView 的宽高，而导致新加的view 显示不出来。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;移除子view&quot;&gt;&lt;a href=&quot;#移除子view&quot; class=&quot;headerlink&quot; title=&quot;移除子view&quot;&gt;&lt;/a&gt;移除子view&lt;/h4&gt;&lt;p&gt;移除子 View 采用如下方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stackView.removeArrangedSubview(view) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;view.removeFromSuperview()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：子view从stackView移除后，还必须将子view从父view中移除&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>iOS UIWindow 覆盖 StatusBar</title>
    <link href="http://www.wxtlife.com/2018/08/05/iOS-UIWindow-overlay-StatusBar/"/>
    <id>http://www.wxtlife.com/2018/08/05/iOS-UIWindow-overlay-StatusBar/</id>
    <published>2018-08-05T14:38:07.000Z</published>
    <updated>2018-08-05T14:45:00.591Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近产品要做一个消息的通知，而且通知是覆盖在 StatusBar 上面的。如果是普通的 UIView 则肯定是不行的，因为 StatusBar 为系统全局性的视图，所以要想覆盖它，则必须为 Statusbar 类型的，那么也就是 UIWindow 了。</p><h3 id="UIWindow-的基础介绍"><a href="#UIWindow-的基础介绍" class="headerlink" title="UIWindow 的基础介绍"></a>UIWindow 的基础介绍</h3><ul><li>UIWindow是一种特殊的UIView,通常在一个app中至少会有一个UIWindow。</li><li>iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的View,最后将控制器的View添加到UIWindow上，于是控制器的View就显示在屏幕上了。</li><li>一个iOS程序之所以能显示在屏幕上，完全是因为它有UIWindow，也就是说，没有UIWindow就看不到任何UI界面。</li><li>状态栏和键盘都是特殊的UIWindow。</li></ul><blockquote><p>这里有三个重要的对象UIScreen，UIWindow，UIView。</p><ol><li>UIScreen对象识别物理屏幕连接到设备</li><li>UIWindow对象提供绘画支持给屏幕</li><li>UIView执行绘画，当窗口要显示内容的时候，UIView绘画出他们的内容并附加到窗口上。</li></ol></blockquote><a id="more"></a><h3 id="UIWindow-等级"><a href="#UIWindow-等级" class="headerlink" title="UIWindow 等级"></a>UIWindow 等级</h3><p>window等级，即window在z轴上的层级关系,默认是0。UIWindowLevel 本身是一个 CGFloat 类型,可以随意设置或进行加减，高等级会显示在低等级上面。系统给出了三种常用等级:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal;      0</span><br><span class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert;       2000</span><br><span class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar;   4000</span><br></pre></td></tr></table></figure></p><h3 id="初始化-UIWindow-覆盖-StatusBar"><a href="#初始化-UIWindow-覆盖-StatusBar" class="headerlink" title="初始化 UIWindow 覆盖 StatusBar"></a>初始化 UIWindow 覆盖 StatusBar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)initWindow &#123;</span><br><span class="line">  //初始化statusView,可在其上添加控件</span><br><span class="line">  CGRect statusBarFrame = [UIApplication sharedApplication].statusBarFrame;</span><br><span class="line">  stateWindow = [[UIWindow alloc] initWithFrame:statusBarFrame];</span><br><span class="line">  // 设置windowLevel为statusbar + 1 保证可以显示在statusbar上面</span><br><span class="line">  stateWindow.windowLevel = UIWindowLevelStatusBar + 1;</span><br><span class="line">  stateWindow.backgroundColor = [UIColor orangeColor];</span><br><span class="line">  stateWindow.userInteractionEnabled = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样创建的与 statusbar 大小一样的UIWindow 已经好了，默认创建好 这个UIWindow 则已经添加上去了，只是默认不显示，可以使用下面来控制显示和隐藏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.hidden = YES; </span><br><span class="line">window.hidden = NO;</span><br></pre></td></tr></table></figure></p><p>当然 UIwindow 还有个 <code>makeKeyAndVisible</code> 方法，这个方法会将新建的 UIWindow 设置为主窗口并显示，之后如果消失后，需要将原来的主窗口设置回来，不然会出现很多异常的问题，这里切记。</p><p><strong>注意：控制新添加的 UIWindow 使用 hidden 来控制。尽量不要使用 makeKeyAndVisible</strong></p><p>这里的 stateWindow 必须是私有变量或者全局变量，生命周期随所在控制器的生命周期。</p><h3 id="添加Label"><a href="#添加Label" class="headerlink" title="添加Label"></a>添加Label</h3><p>上面的 UIWindow 创建好了，那么要显示相关的提示文字，还需要添加 label，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">label = [[UILabel alloc] initWithFrame:stateWindow.frame];</span><br><span class="line">label.backgroundColor = [UIColor blackColor];</span><br><span class="line">label.textColor = [UIColor whiteColor];</span><br><span class="line">label.font=[UIFont systemFontOfSize:12];</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">[stateWindow addSubview:label];</span><br></pre></td></tr></table></figure></p><p>之后设置 label的文字即可进行对其内容控制。</p><h3 id="旋转问题处理"><a href="#旋转问题处理" class="headerlink" title="旋转问题处理"></a>旋转问题处理</h3><p>上面弄完基本上都完成，但是在旋转屏幕后，发现显示还是在原来的位置上，无法跟随系统的状态栏一起旋转。需要对 Window 设置空的UIViewController后才会跟着状态栏旋转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 需要设置一个空的ViewController 不然旋转屏幕后，不会跟着旋转坐标系</span><br><span class="line">stateWindow.rootViewController = [UIViewController new];</span><br></pre></td></tr></table></figure></p><p>旋转后，又发现了新的问题，在新建的 UIWindow 根据的是一开始时的状态长宽，但是旋转为横屏时，尺寸会发生变化，所以在每次显示 statusWindow 时重新设置下frame的大小，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGRect newFrame = CGRectMake(0, 0, [[UIScreen mainScreen] bounds].size.width, STATUSBAR_HEIGHT);</span><br><span class="line">stateWindow.frame = newFrame;</span><br><span class="line">label.frame = newFrame;</span><br></pre></td></tr></table></figure></p><p>这里不直接取 statusbar 的frame，因为在statusbar 隐藏时获取的长宽为0，所以上面设置时取值为宽度和statusbar的高度，高度在一开始进行获取保存进常量中。</p><blockquote><p>综上：对于显示覆盖 statusbar 的 UIWindow 已经完成啦，</p></blockquote><h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><p>当我们显示了之后一般需要在延迟几秒后进行隐藏，在 Android 中一般实用Handler进行，或者实用timer进行执行操作。那么 ios 中怎么实用呢? 请看如下方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//延迟 3s 后执行 hideStateMsg 方法。</span><br><span class="line"> [self performSelector:@selector(hideStateMsg) withObject:nil afterDelay:3.0];</span><br><span class="line"> </span><br><span class="line"> -(void)hideStateMsg &#123;</span><br><span class="line">  stateWindow.hidden = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然在执行之前可能还需要把之前的延时任务取消了，则有如下两种方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 取消 self 对象中所有的延迟任务。</span><br><span class="line">[NSObject cancelPreviousPerformRequestsWithTarget:self];</span><br><span class="line"></span><br><span class="line">// 取消指定的函数的延迟执行操作。</span><br><span class="line">[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(hideStateMsg) object:nil];</span><br></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过上面的一些问题处理解决，最终能够实现一个覆盖 Statusbar 的View，并且能够在指定时间后消失，达到消息提醒的功能。</p><blockquote><p>参考地址：<br><a href="https://www.cnblogs.com/CoderAlex/p/4762210.html" target="_blank" rel="noopener">https://www.cnblogs.com/CoderAlex/p/4762210.html</a></p></blockquote><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近产品要做一个消息的通知，而且通知是覆盖在 StatusBar 上面的。如果是普通的 UIView 则肯定是不行的，因为 StatusBar 为系统全局性的视图，所以要想覆盖它，则必须为 Statusbar 类型的，那么也就是 UIWindow 了。&lt;/p&gt;
&lt;h3 id=&quot;UIWindow-的基础介绍&quot;&gt;&lt;a href=&quot;#UIWindow-的基础介绍&quot; class=&quot;headerlink&quot; title=&quot;UIWindow 的基础介绍&quot;&gt;&lt;/a&gt;UIWindow 的基础介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;UIWindow是一种特殊的UIView,通常在一个app中至少会有一个UIWindow。&lt;/li&gt;
&lt;li&gt;iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的View,最后将控制器的View添加到UIWindow上，于是控制器的View就显示在屏幕上了。&lt;/li&gt;
&lt;li&gt;一个iOS程序之所以能显示在屏幕上，完全是因为它有UIWindow，也就是说，没有UIWindow就看不到任何UI界面。&lt;/li&gt;
&lt;li&gt;状态栏和键盘都是特殊的UIWindow。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里有三个重要的对象UIScreen，UIWindow，UIView。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UIScreen对象识别物理屏幕连接到设备&lt;/li&gt;
&lt;li&gt;UIWindow对象提供绘画支持给屏幕&lt;/li&gt;
&lt;li&gt;UIView执行绘画，当窗口要显示内容的时候，UIView绘画出他们的内容并附加到窗口上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.wxtlife.com/categories/iOS/"/>
    
    
      <category term="object-c" scheme="http://www.wxtlife.com/tags/object-c/"/>
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="iOS" scheme="http://www.wxtlife.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OSX webview 与 native 通信简单介绍</title>
    <link href="http://www.wxtlife.com/2018/07/29/osx-webview-native-bridge/"/>
    <id>http://www.wxtlife.com/2018/07/29/osx-webview-native-bridge/</id>
    <published>2018-07-29T15:36:55.000Z</published>
    <updated>2018-07-29T15:44:26.851Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>在开发混合应用中，经常需要 js 与 webview 进行通信，那么官方也提供了一些方法进行消息处理，今天这里介绍一款开源库来更好的解决的 native 与 js 通信的问题，也就是 <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a></p><h3 id="基本配置使用"><a href="#基本配置使用" class="headerlink" title="基本配置使用"></a>基本配置使用</h3><ol><li>在 Podfile 文件中添加库稳健配置<code>pod &#39;WebViewJavascriptBridge&#39;, &#39;~&gt; 6.0&#39;</code>,然后执行<code>pod install</code></li><li><p>使 WebViewJavascriptBridge 初始化与 Webview 进行绑定 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let bridge: WebViewJavascriptBridge = WebViewJavascriptBridge.init(forWebView: webview)</span><br></pre></td></tr></table></figure></li><li><p>在js层中进行注册处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 将该方法写入 javascript 中</span><br><span class="line">function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">    if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">    if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">    window.WVJBCallbacks = [callback];</span><br><span class="line">    var WVJBIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    WVJBIframe.style.display = &apos;none&apos;;</span><br><span class="line">    WVJBIframe.src = &apos;https://__bridge_loaded__&apos;;</span><br><span class="line">    document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">    setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>经过上面的步骤，基本的搭建就完成了，下面就是要相互注册调用的函数，以及互相调用的方法。</p></li><li>native 层注册方法供 js 调用，以及 native 层调用的js方法。</li></ol><a id="more"></a><h3 id="注册及调用方法"><a href="#注册及调用方法" class="headerlink" title="注册及调用方法"></a>注册及调用方法</h3><ul><li>native 注册方法供 js 调用 （registerHandler）</li></ul><p>native拿到bridge对象后，即可对native的方法进行注册，以便供 js 调用。注册方也比较简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bridge.registerHandler(&quot;methodName&quot;) &#123; (jsCallData, responseCallback) in</span><br><span class="line">    // 通过jsCallData 来获取js层调用的方法。</span><br><span class="line">    print(&quot;jsCallData = &quot;, jsCallData)</span><br><span class="line">    let result = &quot;ok&quot;</span><br><span class="line">    // resonpseCallback 用来将处理的结果在返回给到 js 层</span><br><span class="line">    responseCallback(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>js 层注册方法供 native 调用 （registerHandler）</li></ul><p>调用 js 层前面注册的函数进行注册，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line">    bridge.registerHandler(&apos;methodName&apos;, function(data, responseCallback) &#123;</span><br><span class="line">            // data 为 native 调用的方法参数</span><br><span class="line">            log(&apos;ObjC called testJavascriptHandler with&apos;, data)</span><br><span class="line">            var responseData = &#123; &apos;Javascript Says&apos;:&apos;Right back atcha!&apos; &#125;</span><br><span class="line">            log(&apos;JS responding with&apos;, responseData)</span><br><span class="line">            // resonpsecallback 为js处理完告诉native 的结果</span><br><span class="line">            responseCallback(responseData)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的 native 注册供 js 调用的模式，与 js 注册供 native 调用的方法基本上是一样的，方法，参数，回调等都基本上一致。</p><ul><li><p>native 调用 js  层注册的方法 （callhandler）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bridge 为native 绑定后的 WebViewJavascriptBridge 对象</span><br><span class="line">// methodName 为js 注册的方法</span><br><span class="line">// data 为调用js的方法参数</span><br><span class="line">// callback 为 js 方法执行后的回调方法。</span><br><span class="line">bridge.callHandler(methodName, data: data, responseCallback: callback)</span><br></pre></td></tr></table></figure></li><li><p>js 调用 native 层注册的方法 （callHanlder）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line">    // data 构造调用native的参数</span><br><span class="line">    var data = &#123;&quot;action&quot;:&quot;connectstate&quot;,&quot;payload&quot;:&#123;&quot;isConnect&quot;: true&#125;&#125;</span><br><span class="line">    // methodName 为native 注册的方法。</span><br><span class="line">    bridge.callHandler(&apos;methodName&apos;, data, function(response) &#123;</span><br><span class="line">        // response 为native 回调的值</span><br><span class="line">        log(&apos;JS got response&apos;, response)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过上面的4个方法，已经把native 与 js 两端的互相注册及调用的讲完。整体上比较简单，两端的方法注册及调用都是互等性的，方法名、参数、回调都一样。理解起来也比较容易。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>主要的原理的通过 <code>function setupWebViewJavascriptBridge(callback) {}</code>方法里添加一个不显示的iframe view， 然后在native 层通过对注定的请求 url 进行拦截，解析出相应的参数。然后利用此特性进行 js 与 native 的互相通信。详细的可以参考文章：</p><blockquote><p>参数文章：<br><a href="https://www.jianshu.com/p/8bd6aeb719ff" target="_blank" rel="noopener">https://www.jianshu.com/p/8bd6aeb719ff</a><br><a href="https://www.jianshu.com/p/d45ce14278c7" target="_blank" rel="noopener">https://www.jianshu.com/p/d45ce14278c7</a></p></blockquote><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;在开发混合应用中，经常需要 js 与 webview 进行通信，那么官方也提供了一些方法进行消息处理，今天这里介绍一款开源库来更好的解决的 native 与 js 通信的问题，也就是 &lt;a href=&quot;https://github.com/marcuswestin/WebViewJavascriptBridge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebViewJavascriptBridge&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;基本配置使用&quot;&gt;&lt;a href=&quot;#基本配置使用&quot; class=&quot;headerlink&quot; title=&quot;基本配置使用&quot;&gt;&lt;/a&gt;基本配置使用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在 Podfile 文件中添加库稳健配置&lt;code&gt;pod &amp;#39;WebViewJavascriptBridge&amp;#39;, &amp;#39;~&amp;gt; 6.0&amp;#39;&lt;/code&gt;,然后执行&lt;code&gt;pod install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使 WebViewJavascriptBridge 初始化与 Webview 进行绑定 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let bridge: WebViewJavascriptBridge = WebViewJavascriptBridge.init(forWebView: webview)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在js层中进行注册处理&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 将该方法写入 javascript 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function setupWebViewJavascriptBridge(callback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (window.WebViewJavascriptBridge) &amp;#123; return callback(WebViewJavascriptBridge); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (window.WVJBCallbacks) &amp;#123; return window.WVJBCallbacks.push(callback); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    window.WVJBCallbacks = [callback];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var WVJBIframe = document.createElement(&amp;apos;iframe&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WVJBIframe.style.display = &amp;apos;none&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WVJBIframe.src = &amp;apos;https://__bridge_loaded__&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    document.documentElement.appendChild(WVJBIframe);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(function() &amp;#123; document.documentElement.removeChild(WVJBIframe) &amp;#125;, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;经过上面的步骤，基本的搭建就完成了，下面就是要相互注册调用的函数，以及互相调用的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;native 层注册方法供 js 调用，以及 native 层调用的js方法。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（二）</title>
    <link href="http://www.wxtlife.com/2018/07/29/osx-dev-summary-2/"/>
    <id>http://www.wxtlife.com/2018/07/29/osx-dev-summary-2/</id>
    <published>2018-07-29T15:34:48.000Z</published>
    <updated>2018-07-29T15:40:43.472Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><h3 id="在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，"><a href="#在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，" class="headerlink" title="在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，"></a>在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，</h3><ul><li>1.启动沙盒<br>需要在APP需要启动沙盒具体为：<br>target -&gt; Capabilities -&gt; App Sandbox 将Outgoing Connenctions 沟选上。</li><li>2.在项目Info.Plist 中添加设置<br>添加<code>App Transport Security Settings</code> 设置<code>Allow Arbitrary Loads</code> 为 true</li></ul><h3 id="为OSX项目添加Podfile"><a href="#为OSX项目添加Podfile" class="headerlink" title="为OSX项目添加Podfile"></a>为OSX项目添加Podfile</h3><p>新建一个工程时，需要引用第三方库时，一般实用OPodfile 进行引用，初始化podfile，在项目根目录下执行 <code>pod init</code>， 之后产生 Podfile，然后在产生的文件中添加依赖，再在根目录下执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br><span class="line">pod install</span><br></pre></td></tr></table></figure></p><p>然后项目根目录下会产生<code>.xcworkspace</code> 的文件，这时需要将新建的工程关闭，然后使用双击<code>xcworkspace</code>来打开项目。后续添加新的库，只需执行 <code>pod install</code>即可。</p><h3 id="swift-引用-oc-库桥接"><a href="#swift-引用-oc-库桥接" class="headerlink" title="swift 引用 oc 库桥接"></a>swift 引用 oc 库桥接</h3><p>如果开发中使用swift 语言，而库还是用oc语言开发的，如要使用oc库则需要添加一个配置bridge文件并配置在xcode中。</p><ol><li>首先在项目文件名下面新建一个 .h 的文件，文件名一般为<code>项目名+bridge.h</code>,例如<code>TestDemo-Bridging-Header.h</code></li><li>在该 .h 的文件中添加引入 oc 库的头文件，例如<code>#import &lt;DevMateKit/DevMateKit.h&gt;</code></li><li>选中项目根目录，进入项目设置，选中 target 选项，找到<code>swift Compiler -General</code>,下面有项为：<code>Object-C Bridging Header</code>, 双击进入编辑状态，然后将前面新建的.h文件拖到编辑框内，路径会自动填充上（绝对路径），然后重新编译项目即可。</li></ol><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;vip-container&quot;&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一
      
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（一）</title>
    <link href="http://www.wxtlife.com/2018/07/22/osx-dev-summary-1/"/>
    <id>http://www.wxtlife.com/2018/07/22/osx-dev-summary-1/</id>
    <published>2018-07-22T09:33:41.000Z</published>
    <updated>2018-07-29T15:35:52.637Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>下面为最近使用swift 进行 OSX 开发中，对于一些知识点的总结与汇总，主要是跨行过来，很多内容都不太熟悉，所以这里进行一部分的记录与总结，方便日后的回顾与思考，后续有新的也会继续进行补充。</p><h3 id="swift-代码同步块"><a href="#swift-代码同步块" class="headerlink" title="swift 代码同步块"></a>swift 代码同步块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_sync_enter(Obj)</span><br><span class="line"> //code </span><br><span class="line">objc_sync_exit(Obj)</span><br></pre></td></tr></table></figure><p>在上面两句话中间的语句则为同步代码块，Obj 为锁的对象。类似Java中的 synchronized(Obj)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//代码块</span><br><span class="line">synchronized(Obj) &#123;</span><br><span class="line">    //cide </span><br><span class="line">&#125;</span><br><span class="line">// synchronized 用到方法上</span><br><span class="line">public void synchronized method() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/" target="_blank" rel="noopener">http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/</a></p><h3 id="swift-布局约束"><a href="#swift-布局约束" class="headerlink" title="swift 布局约束"></a>swift 布局约束</h3><p>1、在Xib或者StoryBoard中的view间的依赖，都正常但是无法按照我们预期的显示，这时需要检查 约束之间的优先级，通常这部分很容易导致View依赖出现错误，而很难排查。</p><p>2、在定义布局时，有图片控件ImageView的时候，默认指定了图片，这时相当于控件的大小是固定的，如果我们想让其铺满父view，设置了相应的约束，但是实际运行中不起作用</p><p>原因： ImageView已经有图片，所以默认其图片是固定大小了，也就意味着ImageView是固定的了，所以这时view不会跟随父view铺满全屏，想要以 ImageView 的大小铺满父View，则 ImageView 的优先级则应该要低一些。 在xib中选中相应的ImageView，在约束那找到 Content compression resistance priority,将其优先级进行降低，也就是视图越容易被压缩。</p><p>如果在其他需求中ImageView不想被压缩，想要拉伸，而是设置Content Hugging Priority</p><p>约束优先级: 在Autolayout中每个约束都有一个优先级, 优先级的范围是1 ~ 1000。创建一个约束，默认的优先级是最高的1000</p><p>下面是关于两种属性的解释说明：</p><a id="more"></a><p><strong>Content Hugging Priority:</strong> 该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸，默认是250。</p><p><strong>Content Compression Resistance Priority:</strong> 该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩，默认是750</p><p>下面是第二种解释说法：</p><p><strong>Content Hugging Priority：</strong> 直译成中文就是“内容拥抱优先级”，从字面意思上来看就是两个视图，谁的“内容拥抱优先级”高，谁就优先环绕其内容。稍后我们会根据一些示例进行介绍。</p><p><strong>Content Compression Resistance Priority：</strong> 该优先级直译成中文就是“内容压缩阻力优先级”。也就是视图的“内容压缩阻力优先级”越大，那么该视图中的内容越难被压缩。而该优先级小的视图，则内容优先被压缩。稍后我们也会通过相应的实例来看一下这个优先级的具体表现。</p><blockquote><p>参考链接:<br><a href="https://www.cnblogs.com/ludashi/p/7373051.html" target="_blank" rel="noopener">https://www.cnblogs.com/ludashi/p/7373051.html</a><br><a href="https://juejin.im/entry/58b3d97c8d6d810057f5b647" target="_blank" rel="noopener">https://juejin.im/entry/58b3d97c8d6d810057f5b647</a></p></blockquote><h3 id="osx中监听窗口大小及状态的变化"><a href="#osx中监听窗口大小及状态的变化" class="headerlink" title="osx中监听窗口大小及状态的变化"></a>osx中监听窗口大小及状态的变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(self.enterFullScreen), name: NSWindow.willEnterFullScreenNotification, object: nil)</span><br><span class="line"></span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(self.exitFullScreen), name: NSWindow.willExitFullScreenNotification, object: nil)</span><br><span class="line"></span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(self.didResizeChanged), name: NSWindow.didResizeNotification, object: nil)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@objc dynamic func enterFullScreen() &#123;</span><br><span class="line">    print(&quot;窗口将进入全屏&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@objc dynamic func exitFullScreen() &#123;</span><br><span class="line">    print(&quot;窗口将退出全屏&quot;)   </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@objc dynamic func didResizeChanged() &#123;</span><br><span class="line">    print(&quot;窗口大小变化&quot;)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取消监听：</span><br><span class="line">NotificationCenter.default.removeObserver(self)</span><br></pre></td></tr></table></figure><p>当然在还有其他的 NSWindow.***Notification 类型的通知，按需监听，并进行处理。</p><h3 id="使用-Masonry-如何删掉约束"><a href="#使用-Masonry-如何删掉约束" class="headerlink" title="使用 Masonry 如何删掉约束"></a>使用 Masonry 如何删掉约束</h3><p>Masonry 是在ios与osx开发中 autolayout 进行动态布局约束不可或缺的一个好帮手，可以描述为可视化的语言去描述约束的情况。对于开发非常的方便。</p><p>对于删除动态约束可使用 MASConstraint 的 uninstall 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var constraint: MASConstraint? </span><br><span class="line"></span><br><span class="line">// 设置约束，并赋值</span><br><span class="line">view.remakeConstraints&#123; maker in </span><br><span class="line">  constraint = maker?.width.equal()(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除约束</span><br><span class="line">constraint?.uninstall()</span><br><span class="line"></span><br><span class="line">//当然也可以使用 install添加约束</span><br><span class="line">constraint?.install()</span><br></pre></td></tr></table></figure></p><h3 id="RxSwift-中debounce-与-throttle-的区别"><a href="#RxSwift-中debounce-与-throttle-的区别" class="headerlink" title="RxSwift 中debounce 与 throttle 的区别"></a>RxSwift 中debounce 与 throttle 的区别</h3><p>下面是官方的意思</p><ul><li>Throttle: the original function be called at most once per specified period.</li><li>Debounce: the original function be called after the caller stops calling the decorated function after a specified period.</li></ul><p>下面为我个人的理解，及使用场景</p><ul><li>throttle  :  一般会指定一个时间值，在这个时间里，最多只执行一次，比如常见开发中避免狂点 button，需要对点击时间进行控制的， 就可以使用来指定</li><li>debounce： 指定的一个时间值内，没有新消息触发，则返回最后一个值，如果指定事件内有新消息触发，则取消旧消息，直到没有新消息来在执行后面的操作，这种应用场景在，数据不断变化时，可以对中间的数据变化不做处理，直到指定时间不再变化时在进行以最后一次的数据进行刷新。</li></ul><p>参考链接: <a href="https://medium.com/@dkhuong291/throttle-vs-debounce-in-rxswift-86f8b303d5d4" target="_blank" rel="noopener">https://medium.com/@dkhuong291/throttle-vs-debounce-in-rxswift-86f8b303d5d4</a></p><h3 id="OSX-上NSTextField-支持复制粘贴"><a href="#OSX-上NSTextField-支持复制粘贴" class="headerlink" title="OSX 上NSTextField 支持复制粘贴"></a>OSX 上NSTextField 支持复制粘贴</h3><p>在mac os 上开发，去掉了应用的edit menu后导致后续的 NSTextField 无法直接使用 command + c或者 command + v 进行复制粘贴。所以想要支持的化，需要复写 performKeyEquivalent 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private let commandKey = NSEvent.ModifierFlags.command.rawValue</span><br><span class="line">private let commandShiftKey = NSEvent.ModifierFlags.command.rawValue | NSEvent.ModifierFlags.shift.rawValue</span><br><span class="line">// 在 NSTextField 子类中进行复写 performKeyEquivalent 方法。    </span><br><span class="line">override func performKeyEquivalent(with event: NSEvent) -&gt; Bool &#123;</span><br><span class="line">        if event.type == NSEvent.EventType.keyDown &#123;</span><br><span class="line">            if (event.modifierFlags.rawValue &amp; NSEvent.ModifierFlags.deviceIndependentFlagsMask.rawValue) == commandKey &#123;</span><br><span class="line">                switch event.charactersIgnoringModifiers! &#123;</span><br><span class="line">                case &quot;x&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSText.cut(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;c&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSText.copy(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;v&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSText.paste(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;z&quot;:</span><br><span class="line">                    if NSApp.sendAction(Selector((&quot;undo:&quot;)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;a&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSResponder.selectAll(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                default:</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (event.modifierFlags.rawValue &amp; NSEvent.ModifierFlags.deviceIndependentFlagsMask.rawValue) == commandShiftKey &#123;</span><br><span class="line">                if event.charactersIgnoringModifiers == &quot;Z&quot; &#123;</span><br><span class="line">                    if NSApp.sendAction(Selector((&quot;redo:&quot;)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.performKeyEquivalent(with: event)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加上上面的复写方法后，即可对NSTextField的控件支持复制粘贴快捷键操作。</p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/970707/cocoa-keyboard-shortcuts-in-dialog-without-an-edit-menu/3746058" target="_blank" rel="noopener">https://stackoverflow.com/questions/970707/cocoa-keyboard-shortcuts-in-dialog-without-an-edit-menu/3746058</a></p></blockquote><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;下面为最近使用swift 进行 OSX 开发中，对于一些知识点的总结与汇总，主要是跨行过来，很多内容都不太熟悉，所以这里进行一部分的记录与总结，方便日后的回顾与思考，后续有新的也会继续进行补充。&lt;/p&gt;
&lt;h3 id=&quot;swift-代码同步块&quot;&gt;&lt;a href=&quot;#swift-代码同步块&quot; class=&quot;headerlink&quot; title=&quot;swift 代码同步块&quot;&gt;&lt;/a&gt;swift 代码同步块&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_sync_enter(Obj)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; //code &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_sync_exit(Obj)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面两句话中间的语句则为同步代码块，Obj 为锁的对象。类似Java中的 synchronized(Obj)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//代码块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;synchronized(Obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //cide &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// synchronized 用到方法上&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void synchronized method() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;swift-布局约束&quot;&gt;&lt;a href=&quot;#swift-布局约束&quot; class=&quot;headerlink&quot; title=&quot;swift 布局约束&quot;&gt;&lt;/a&gt;swift 布局约束&lt;/h3&gt;&lt;p&gt;1、在Xib或者StoryBoard中的view间的依赖，都正常但是无法按照我们预期的显示，这时需要检查 约束之间的优先级，通常这部分很容易导致View依赖出现错误，而很难排查。&lt;/p&gt;
&lt;p&gt;2、在定义布局时，有图片控件ImageView的时候，默认指定了图片，这时相当于控件的大小是固定的，如果我们想让其铺满父view，设置了相应的约束，但是实际运行中不起作用&lt;/p&gt;
&lt;p&gt;原因： ImageView已经有图片，所以默认其图片是固定大小了，也就意味着ImageView是固定的了，所以这时view不会跟随父view铺满全屏，想要以 ImageView 的大小铺满父View，则 ImageView 的优先级则应该要低一些。 在xib中选中相应的ImageView，在约束那找到 Content compression resistance priority,将其优先级进行降低，也就是视图越容易被压缩。&lt;/p&gt;
&lt;p&gt;如果在其他需求中ImageView不想被压缩，想要拉伸，而是设置Content Hugging Priority&lt;/p&gt;
&lt;p&gt;约束优先级: 在Autolayout中每个约束都有一个优先级, 优先级的范围是1 ~ 1000。创建一个约束，默认的优先级是最高的1000&lt;/p&gt;
&lt;p&gt;下面是关于两种属性的解释说明：&lt;/p&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>比 cat 更好用的命令了解一下？</title>
    <link href="http://www.wxtlife.com/2018/05/20/bat-tool/"/>
    <id>http://www.wxtlife.com/2018/05/20/bat-tool/</id>
    <published>2018-05-20T13:50:58.000Z</published>
    <updated>2018-05-20T14:32:08.629Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>作为程序员经常使用命令行来进行一些文件的处理，比如常见的：<code>git</code>， <code>vim</code> ，以及不同语言下的一些命令等。那么这么多的命令中，相信你肯定有用过<code>cat</code>命令用来查看文件的内容，但是这个命令仅仅只能将文本展示出来，并不会很好的辅助我们阅读和理解里面的内容，尤其是文件中内容为 代码时，看起来就特别的痛苦了。那么这篇文章就要介绍更好命令来替代 <code>cat</code>命令，它就是<code>bat</code>命令。（不是windows中的那个脚本哟）</p><h3 id="bat介绍"><a href="#bat介绍" class="headerlink" title="bat介绍"></a>bat介绍</h3><p><code>bat</code> 是一个语法高亮显示和<code>Git</code>集成的<code>cat</code>高级版本，也就是说，<code>bat</code> 有 <code>cat</code>的所有功能，且已经集成了代码高亮，和<code>git</code>版本管理的工具，并且会对过长的文件进行自动分页，不会像 <code>cat</code> 一样全部一次打印,先来看张效果图：</p><p><img src="https://camo.githubusercontent.com/9d3d89364f2cc83ace8f29646a6236bc15ea1da0/68747470733a2f2f696d6775722e636f6d2f724773646e44652e706e67" alt=""></p><a id="more"></a><h3 id="bat安装"><a href="#bat安装" class="headerlink" title="bat安装"></a>bat安装</h3><p>安装的方法也是超级的简单，具体安装如下：</p><ul><li>Linux 上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://aur.archlinux.org/bat.git</span><br><span class="line">cd bat</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><ul><li>MACOS 上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install bat</span><br></pre></td></tr></table></figure></li></ul><p>安装完成后，输入<code>bat -help</code> 看下是否会出现相关的提示信息，来确认是否安装成功。</p><h3 id="bat使用"><a href="#bat使用" class="headerlink" title="bat使用"></a>bat使用</h3><p>使用与 <code>cat</code> 类似，在 <code>bat</code> 后面紧跟文件 就行了， 也可以同时打开过个，但结果是以一个接一个展示出来。</p><p>如打开一个有 <code>git</code> 管理的文件，会展示出文件中添加与删除的部分，如下图所示：<br><img src="https://camo.githubusercontent.com/67e44f4a68150325f74b3a46820b7473ff7b91a6/68747470733a2f2f692e696d6775722e636f6d2f326c53573452452e706e67" alt=""></p><p>如果需要制定文件中高亮的语言，可以使用 <code>-l</code> 参数来制定语言，例如：<br><code>bat  ./test.json -l json</code> 则指定文件中高亮为 json 模式，当然不指定也没有问题，默认会自动识别。<br>总之使用还是比较简单，一点都不复杂。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果有了这个命令，我想一般都不会再用 <code>cat</code>命令了，但每次敲命令都习惯使用 <code>cat</code> 了， 那么建议将 cat 命令使用 <code>alias cat= &#39;bat&#39;</code> 将其指定为 <code>bat</code> 这样就可以使用<code>cat</code> 命令，而达到 <code>bat</code> 的使用效果。</p><p>希望大家能够喜欢这篇文章，喜欢就分享出去吧。 如果你有更好的命令，欢迎留言交流。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;作为程序员经常使用命令行来进行一些文件的处理，比如常见的：&lt;code&gt;git&lt;/code&gt;， &lt;code&gt;vim&lt;/code&gt; ，以及不同语言下的一些命令等。那么这么多的命令中，相信你肯定有用过&lt;code&gt;cat&lt;/code&gt;命令用来查看文件的内容，但是这个命令仅仅只能将文本展示出来，并不会很好的辅助我们阅读和理解里面的内容，尤其是文件中内容为 代码时，看起来就特别的痛苦了。那么这篇文章就要介绍更好命令来替代 &lt;code&gt;cat&lt;/code&gt;命令，它就是&lt;code&gt;bat&lt;/code&gt;命令。（不是windows中的那个脚本哟）&lt;/p&gt;
&lt;h3 id=&quot;bat介绍&quot;&gt;&lt;a href=&quot;#bat介绍&quot; class=&quot;headerlink&quot; title=&quot;bat介绍&quot;&gt;&lt;/a&gt;bat介绍&lt;/h3&gt;&lt;p&gt;&lt;code&gt;bat&lt;/code&gt; 是一个语法高亮显示和&lt;code&gt;Git&lt;/code&gt;集成的&lt;code&gt;cat&lt;/code&gt;高级版本，也就是说，&lt;code&gt;bat&lt;/code&gt; 有 &lt;code&gt;cat&lt;/code&gt;的所有功能，且已经集成了代码高亮，和&lt;code&gt;git&lt;/code&gt;版本管理的工具，并且会对过长的文件进行自动分页，不会像 &lt;code&gt;cat&lt;/code&gt; 一样全部一次打印,先来看张效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/9d3d89364f2cc83ace8f29646a6236bc15ea1da0/68747470733a2f2f696d6775722e636f6d2f724773646e44652e706e67&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>【工具】github 插件源码浏览利器 Insight</title>
    <link href="http://www.wxtlife.com/2018/04/02/chrome-insight/"/>
    <id>http://www.wxtlife.com/2018/04/02/chrome-insight/</id>
    <published>2018-04-02T14:23:38.000Z</published>
    <updated>2018-05-20T13:56:19.798Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在之前的一篇文章中<a href="http://www.wxtlife.com/2017/09/27/developers-need-tools/">《开发人员必备的开发利器》</a>有介绍过一款Chrome插件，名为 Octotree ，它可以以树形结构的样式将源代码源文件展示出来，方便我们查看跳转等。但是有时候在github上看源码时，可能需要进行方法的跳转，查看具体实现，更或者找到某个方法或者类的调用方，那么有没有既有 Octotree 功能又能实现上面的功能呢，那当然是有的，它就是今天要介绍的主角 <code>insight.io</code> </p><h3 id="insight-io-使用"><a href="#insight-io-使用" class="headerlink" title="insight.io 使用"></a>insight.io 使用</h3><p>insight.io 也是一个Chrome 插件， 安装也就直接在Chrome插件中心搜索安装就行了，这里就不多描述。<br>安装好后，在首次安装上后需要使用github账号进行授权登录，之后会进行一些操作相关的提示。<br>整体的界面如下所示</p><p><img src="../img/insight/insight_view.png" alt="insight"></p><p>整体的风格还是很简约，清新的，很是喜欢。</p><p>这样上面树形结构的源代码已经展示出来了。</p><p>但在使用的时候有几点需要注意，此插件不是所有的github 项目都支持，你可以查看页面中间有个提示信息，如果为<code>ready</code> 则可以直接使用，如果提示<code>not indexed</code> 则说明未包含此项目，需要你手动提交，点击即可，之后会进行索引，成功后会邮件通知你，时间大约在半个小时以内，大的项目可能会比较久（本人尝试的时间不到5分钟就OK了），但是不能直接提交fork出来的仓库，fork的仓库可以通过邮件联系对方，可能需要pro付费版本支持。</p><a id="more"></a><h3 id="重点功能"><a href="#重点功能" class="headerlink" title="重点功能"></a>重点功能</h3><h4 id="文件类结构，"><a href="#文件类结构，" class="headerlink" title="文件类结构，"></a>文件类结构，</h4><p>客户以像ide一样展示出当前类的方法名及变量名，并且点击跳到相应行，很是方便，完全就像个ide一样。<br>如下图所示：</p><p><img src="http://www.imgeek.org/uploads/article/20170214/a2a38c0d8fc80e7fd2b0ba8fe8bc8f18.gif" alt=""></p><h4 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h4><p>基于对源代码的语意分析，在搜索时开发者可以直接按照类名，方法名，变量名等搜索，并且Codatlas提供自动补全功能。</p><p><img src="http://www.imgeek.org/uploads/article/20170214/634f52fba750388bc8a82a3419cc1ff6.gif" alt=""></p><h4 id="跳转到定义"><a href="#跳转到定义" class="headerlink" title="跳转到定义"></a>跳转到定义</h4><p>在源码中的方法，类，变量等，都会在下方有下划线表示可直接跳转，有些甚至包含系统的方法，鼠标直接点击即可，想快速看到代码中的类，变量或者方法是如何定义的？没问题，点击类，变量或者方法被使用的地方就会跳转到相应定义的地方。不仅可以在项目内部跳转，跨项目也同样可以实现跳转。如下图所示：</p><p><img src="http://www.imgeek.org/uploads/article/20170214/a3b95f46f04269ba4215ee47df14e7b1.gif" alt=""></p><h4 id="查找引用"><a href="#查找引用" class="headerlink" title="查找引用"></a>查找引用</h4><p>可以对方法或者类查找引用的地方，并安类文件罗列出来，直接点击即可查看引用的具体地方。<br>如果想知道代码中的类，变量或者方法在代码库中哪些地方被使用了，可以点击类，变量或者方法的定义处来显示所有被引用的地方。引用会被进一步分成Referenced At Inherit Override等子类型方便开发者进一步缩小查找范围，如下图所示：</p><p><img src="http://www.imgeek.org/uploads/article/20170214/e8f8041cb427fc620c7c89e9ec8cd20c.gif" alt=""></p><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>在设置中还有很多的快捷键可以设置，协助我们快速的浏览源代码，如下：<br><img src="../img/insight/insight-setting.png" alt="setting"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>此插件的功能很全，页面也很美观，很是喜欢，目前有了它在 github 上看源码方便很多，甚至就不用clone到本地再导入这些复杂的操作流程。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在之前的一篇文章中&lt;a href=&quot;http://www.wxtlife.com/2017/09/27/developers-need-tools/&quot;&gt;《开发人员必备的开发利器》&lt;/a&gt;有介绍过一款Chrome插件，名为 Octotree ，它可以以树形结构的样式将源代码源文件展示出来，方便我们查看跳转等。但是有时候在github上看源码时，可能需要进行方法的跳转，查看具体实现，更或者找到某个方法或者类的调用方，那么有没有既有 Octotree 功能又能实现上面的功能呢，那当然是有的，它就是今天要介绍的主角 &lt;code&gt;insight.io&lt;/code&gt; &lt;/p&gt;
&lt;h3 id=&quot;insight-io-使用&quot;&gt;&lt;a href=&quot;#insight-io-使用&quot; class=&quot;headerlink&quot; title=&quot;insight.io 使用&quot;&gt;&lt;/a&gt;insight.io 使用&lt;/h3&gt;&lt;p&gt;insight.io 也是一个Chrome 插件， 安装也就直接在Chrome插件中心搜索安装就行了，这里就不多描述。&lt;br&gt;安装好后，在首次安装上后需要使用github账号进行授权登录，之后会进行一些操作相关的提示。&lt;br&gt;整体的界面如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/insight/insight_view.png&quot; alt=&quot;insight&quot;&gt;&lt;/p&gt;
&lt;p&gt;整体的风格还是很简约，清新的，很是喜欢。&lt;/p&gt;
&lt;p&gt;这样上面树形结构的源代码已经展示出来了。&lt;/p&gt;
&lt;p&gt;但在使用的时候有几点需要注意，此插件不是所有的github 项目都支持，你可以查看页面中间有个提示信息，如果为&lt;code&gt;ready&lt;/code&gt; 则可以直接使用，如果提示&lt;code&gt;not indexed&lt;/code&gt; 则说明未包含此项目，需要你手动提交，点击即可，之后会进行索引，成功后会邮件通知你，时间大约在半个小时以内，大的项目可能会比较久（本人尝试的时间不到5分钟就OK了），但是不能直接提交fork出来的仓库，fork的仓库可以通过邮件联系对方，可能需要pro付费版本支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="【github,Tools]" scheme="http://www.wxtlife.com/tags/%E3%80%90github-Tools/"/>
    
  </entry>
  
  <entry>
    <title>强大的终端工具ohMyZsh</title>
    <link href="http://www.wxtlife.com/2018/03/21/oh-my-zsh/"/>
    <id>http://www.wxtlife.com/2018/03/21/oh-my-zsh/</id>
    <published>2018-03-21T15:43:14.000Z</published>
    <updated>2018-05-20T14:31:57.714Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天给大家介绍一款强大的终端工具，一般系统默认的终端一般都很鸡肋，要么功能不够智能，要么就是不够美观，这怎么能够体现程序员高大上的逼格呢，所以今天就给大家介绍一款强大的终端工具 <code>oh-my-zsh</code>.</p><p>先来看张我的终端<br><img src="../img/ohmyzsh/ohmyzsh.png" alt="image"></p><p>那么有什么强大的功能呢？</p><ol><li>智能提示</li><li>自动跳转</li><li>智能纠错</li><li>与git 等工具高度集成</li><li>历史记录功能</li><li>目录跳转等</li></ol><p>上面只是我觉得很好用的一些功能，这只是冰山一角，还有其他很多的插件功能，反正一句话就是用了之后你就忘不掉的一个终端。</p><h3 id="什么是-ohMyZsh-介绍"><a href="#什么是-ohMyZsh-介绍" class="headerlink" title="什么是 ohMyZsh 介绍"></a>什么是 ohMyZsh 介绍</h3><p>首先的介绍下 <code>Zsh</code> ，<code>Zsh</code> 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。且其兼容Bash，能够为其补充很多强大的功能。那么 <code>Oh My Zsh</code> 是一款社区驱动的命令行工具，正如它的主页上说的，<code>Oh My Zsh</code> 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。<br><code>ohMyZsh</code> 拥有 200+ 的插件，及140+ 的主题样式，供你任意搭配定制。</p><a id="more"></a><h3 id="安装ohMyZsh"><a href="#安装ohMyZsh" class="headerlink" title="安装ohMyZsh"></a>安装ohMyZsh</h3><ol><li><p>通过 curl 方式安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>通过wget 方式安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure></li></ol><p>如果提示有文件没权限，可使用 sudo 命令进行安装。</p><p>安装完成后，验证是否安装成功。</p><p>如果输入 <code>zsh --version</code> 输出版本号则为安装成功。</p><p>使用 <code>chsh -s $(which zsh)</code> 讲默认的shell切换为zsh，然后通过 <code>$SHELL</code> 检查是否设置成功，如果输出为 <code>/bin/zsh</code>， 则切换默认为zsh 成功。</p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p><code>ohMyZsh</code>拥有很多的主题及插件，可以按照自己的需求来定制，那么怎么配置呢？<br>ohMyZsh 所有的配置都在用户根目录下面的 <code>~/.zshrc</code> 文件中进行配置。</p><p>主题文件的种类及样式可以到网页上查看 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a><br>默认安装就会有很多的主题样式可供配置了，本地主题的文件路径为 <code>~/.oh-my-zsh/themes</code> 可以进行查看。</p><p>喜欢某个主题只需要在 zshrc 文件中的 <code>ZSH_THEME=&quot;XXX&quot;</code>(XXX 为主题名) 例如我的主题为 <code>ZSH_THEME=&quot;agnoster&quot;</code> (<strong>安装这个主题需要安装字体库，因为其中用到了特殊字符</strong>)，具体安装教程可参考官方 <a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">https://github.com/agnoster/agnoster-zsh-theme</a> ,下面也有一些我遇到的问题汇总，如果还有问题可在公众号上留言与我交流。</p><p>样式如下：<br><img src="https://gist.githubusercontent.com/agnoster/3712874/raw/screenshot.png" alt="agnoster"></p><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>插件的种类实在是太多了，以至于有些插件的功能都不清楚，只能说是有需求的时候再去插件库找找是否有满足自己需求的插件。<br>插件库地址如下： <a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins</a><br>本地安装的插件库地址为 <code>~/.oh-my-zsh/plugins</code>。</p><p>添加插件的方法为在<code>~/.zshrc</code> 中，按照下面的格式将插件名称填入即可，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  git</span><br><span class="line">  brew</span><br><span class="line">  adb</span><br><span class="line">  npm</span><br><span class="line">  gradle</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>之后则可以体检到这些插件给你带来的便捷。</p><h3 id="异常问题汇总"><a href="#异常问题汇总" class="headerlink" title="异常问题汇总"></a>异常问题汇总</h3><h4 id="1-终端显示异常"><a href="#1-终端显示异常" class="headerlink" title="1. 终端显示异常"></a>1. 终端显示异常</h4><p>使用 agnoster 主题时， 显示的当前路径及分支信息出现部分乱码，显示很乱。</p><p><strong>解决办法：</strong><br>首先按照<a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">https://github.com/agnoster/agnoster-zsh-theme</a>进行安装，记得一定要安装字体。<br>推荐使用iterm2 然后在 <code>iTerm -&gt; Preferences -&gt; Profiles -&gt; Text</code><br>在下方将 <code>use a different font for non-ASCll text</code> 去掉勾选即可。</p><h4 id="2-默认终端显示名字过长"><a href="#2-默认终端显示名字过长" class="headerlink" title="2. 默认终端显示名字过长"></a>2. 默认终端显示名字过长</h4><p>默认显示了 <a href="mailto:username@host.machine" target="_blank" rel="noopener">username@host.machine</a> 显得很长， 不美观。</p><p><strong>解决办法：</strong></p><ul><li>方法1. 在 .zshrc 中添加  <code>DEFAULT_USER=&quot;$USER&quot;</code></li><li>方法2. 在.zshrc 最末尾，添加下面脚本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$USER&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-使用-ohmyzsh-后，-bash-profile-及-bashrc-不起作用"><a href="#3-使用-ohmyzsh-后，-bash-profile-及-bashrc-不起作用" class="headerlink" title="3. 使用 ohmyzsh 后，~/.bash_profile 及 ~/.bashrc 不起作用"></a>3. 使用 ohmyzsh 后，~/.bash_profile 及 ~/.bashrc 不起作用</h4><p><strong>解决办法：</strong><br>这是由于默认使用是zsh， 所以不会按照<code>/etc/profile --&gt;  /etc/paths  ---&gt;  ~/.bash_profile ---&gt; ~/.bash_login ---&gt;  ~/.profile ---&gt; ~/.bashrc</code><br>所以需要在~/.zshrc 的末尾加上加载文件的脚本，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ -f ~/.bash_profile ]; then</span><br><span class="line">   source ~/.bash_profile</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">   source ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>退出终端，然后重新加载即可。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天给大家介绍一款强大的终端工具，一般系统默认的终端一般都很鸡肋，要么功能不够智能，要么就是不够美观，这怎么能够体现程序员高大上的逼格呢，所以今天就给大家介绍一款强大的终端工具 &lt;code&gt;oh-my-zsh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;先来看张我的终端&lt;br&gt;&lt;img src=&quot;../img/ohmyzsh/ohmyzsh.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么有什么强大的功能呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;智能提示&lt;/li&gt;
&lt;li&gt;自动跳转&lt;/li&gt;
&lt;li&gt;智能纠错&lt;/li&gt;
&lt;li&gt;与git 等工具高度集成&lt;/li&gt;
&lt;li&gt;历史记录功能&lt;/li&gt;
&lt;li&gt;目录跳转等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面只是我觉得很好用的一些功能，这只是冰山一角，还有其他很多的插件功能，反正一句话就是用了之后你就忘不掉的一个终端。&lt;/p&gt;
&lt;h3 id=&quot;什么是-ohMyZsh-介绍&quot;&gt;&lt;a href=&quot;#什么是-ohMyZsh-介绍&quot; class=&quot;headerlink&quot; title=&quot;什么是 ohMyZsh 介绍&quot;&gt;&lt;/a&gt;什么是 ohMyZsh 介绍&lt;/h3&gt;&lt;p&gt;首先的介绍下 &lt;code&gt;Zsh&lt;/code&gt; ，&lt;code&gt;Zsh&lt;/code&gt; 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。且其兼容Bash，能够为其补充很多强大的功能。那么 &lt;code&gt;Oh My Zsh&lt;/code&gt; 是一款社区驱动的命令行工具，正如它的主页上说的，&lt;code&gt;Oh My Zsh&lt;/code&gt; 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。&lt;br&gt;&lt;code&gt;ohMyZsh&lt;/code&gt; 拥有 200+ 的插件，及140+ 的主题样式，供你任意搭配定制。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://www.wxtlife.com/tags/Tools/"/>
    
      <category term="ohmyzsh" scheme="http://www.wxtlife.com/tags/ohmyzsh/"/>
    
  </entry>
  
  <entry>
    <title>【推荐】日志分析查看神器</title>
    <link href="http://www.wxtlife.com/2018/02/27/log-tools/"/>
    <id>http://www.wxtlife.com/2018/02/27/log-tools/</id>
    <published>2018-02-27T14:34:16.000Z</published>
    <updated>2018-03-16T15:49:44.454Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发中定位问题或者调试常常需要分析日志文件，但是对于日志文件一不小心就几百行甚至上千行的相信大家都有些惧怕，尤其在定位问题查看日志时，而且还有不同的tag需要过滤时，看了这个 tag，又要看另外一个 tag，到最后自己都凌乱了，不知道看到哪里了，看了哪些忘了那些，等等很多问题影响效率。</p><p>今天要给大家推荐一个查看日志的神器，至少我现在查看文本日志文件时，不会那么心累了，这款神器软件名字为：<strong>BBEditor</strong> ,遗憾的是目前只有 Mac 版，且也是收费的，不过作为福利，文末会给大家下载地址及注册码，让大家也来感受下查看日志的便捷。</p><a id="more"></a><h3 id="BBEditor-使用"><a href="#BBEditor-使用" class="headerlink" title="BBEditor 使用"></a>BBEditor 使用</h3><ol><li>打开此软件与普通文本软件没什么区别，直接打开或者将文件拖拽到软件中，直接看到整个文件的内容</li><li>过滤 tag，使用快捷键，<code>commond + f</code> 调出查找，然后输入要过滤的<br>tag，或者在文本中选中 tag，直接进行 <code>commond + f</code> 会自动填充查找内容，然后点击 <code>find all</code> 之后会启动一个新的界面，此界面分为两部分，上半部分和下半部分，上半部分的日志则为按照 tag 过滤后的日志结果，当点击选中上半部分的任何一行，下半部分则会显示出该行日志在整个文件中的的位置，且会自动显示出改行日志前后的相关日志。便于查看某些相关信息。</li><li>如果需要过滤过个日志，则在文件上使用 <code>commond + f</code> 命令进行查找，每次都会新开一个界面，便于多 tag 的文件定位。</li></ol><blockquote><p>当然还有很多的可配置参数，在设置中，这里只说基本的使用，高阶使用请自行研究。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了上面的工具，你是否觉得对查看日志不再那么畏惧了，因为这款工具确确实实解决了查看日志上的一些不便的地方。如果你有更好的工具欢迎留言交流。</p><h3 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h3><p>由于此软件只有 mac 版，且是收费的，故这里共享一版最新软件，且共享一个注册码，当然如有你有经济能力，建议进行购买正版。</p><blockquote><p><strong>领取方法：</strong> 在公众号对话框中，发送”日志” 两个字，则可以拿到最新版百度云下载地址及注册码。</p></blockquote><p><strong>如果你觉得文章有用，就帮忙分享出去或者帮忙点个赞吧~感激不尽~</strong></p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在开发中定位问题或者调试常常需要分析日志文件，但是对于日志文件一不小心就几百行甚至上千行的相信大家都有些惧怕，尤其在定位问题查看日志时，而且还有不同的tag需要过滤时，看了这个 tag，又要看另外一个 tag，到最后自己都凌乱了，不知道看到哪里了，看了哪些忘了那些，等等很多问题影响效率。&lt;/p&gt;
&lt;p&gt;今天要给大家推荐一个查看日志的神器，至少我现在查看文本日志文件时，不会那么心累了，这款神器软件名字为：&lt;strong&gt;BBEditor&lt;/strong&gt; ,遗憾的是目前只有 Mac 版，且也是收费的，不过作为福利，文末会给大家下载地址及注册码，让大家也来感受下查看日志的便捷。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="log" scheme="http://www.wxtlife.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin开发基础（三）</title>
    <link href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/"/>
    <id>http://www.wxtlife.com/2017/12/17/kotlin-share-3/</id>
    <published>2017-12-17T12:17:45.000Z</published>
    <updated>2018-03-16T15:49:44.453Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><ul><li><strong><a href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/">Kotlin开发基础（一）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/">Kotlin开发基础（二）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/">Kotlin开发基础（三）</a></strong></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>本篇文章主要介绍类的继承，接口，复写，单例，以及object属性的介绍。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>Kotlin中的继承方式与Java类似，Java中所有对象都继承自<code>Object</code>，而Kotlin中所有对象均继承自<code>Any</code>。两者均不能多继承，只是表现形式不同，Kotlin继承使用冒号<code>：</code>表示。想要复写某个方法，则也需要将方法标记为<code>open</code>的才可以被复写。<br><strong>切记一个类想要被继承，必须用 <code>open</code> 或 <code>abstract</code> 关键字 声明。</strong><br>示例如下；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class person(name: String) // 必须申请为open才可以继承，</span><br><span class="line"></span><br><span class="line">class  male(name: String)： Person(name)</span><br></pre></td></tr></table></figure></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类与这里与Java是一致的，通过<code>abstract</code>关键字标记为抽象类，抽象类中抽象方法也用 <code>abstract</code>标记。有了<code>abstract</code> 则不再需要使用<code>open</code>进行标注了。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open class person() &#123; </span><br><span class="line">    open fun eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class oldPerson(): person() &#123; </span><br><span class="line">    override abstract fun sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>抽象类和抽象方法是默认<code>open</code>关键字修饰的</li><li>复写抽象类中实现的方法，也必须要加<code>open</code>关键字才可复写</li><li>抽象类有抽象方法和方法的实现，可以有成员属性</li></ul><a id="more"></a><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>Kotlin中的接口需要使用关键字<code>interface</code>进行声明，Kotlin 的接口既包含抽象方法的声明，也可以包含实现，且接口中也可以申明属性，默认属性要求是抽象的，或者是提供访问器,其接口中的属性不能有<code>field</code>属性关键字。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface MyInterface &#123; </span><br><span class="line">    val prop: Int // 抽象的</span><br><span class="line">    val propertyWithImplementation: String get() = &quot;foo&quot;</span><br><span class="line">    fun foo() &#123; //方法实现</span><br><span class="line">        print(prop)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">class Child : MyInterface &#123; </span><br><span class="line">    override val prop: Int = 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中已经实现的方法，在子类中进行复写不需要在加<code>open</code>关键字。<br>在接口中</p><h4 id="复写"><a href="#复写" class="headerlink" title="复写"></a>复写</h4><p>复写关键字为 <code>override</code>，与Java的区别是没有了@符号了。复写这里需要注意两点</p><ol><li><code>var</code>可以复写<code>val</code>类型的，但是反之不行。</li><li>想要复写父类的方法，父类方法必须加<code>open</code>关键字标识。</li></ol><p>复写的规则中，如果继承和实现了同样的方法名，则必须在子类对该方法进行复写,以为编译器不知道该调用那个父类的方法。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;</span><br><span class="line">    open fun f() &#123; print(&quot;A&quot;) &#125; </span><br><span class="line">    fun a() &#123; print(&quot;a&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface B &#123;</span><br><span class="line">    fun f() &#123; print(&quot;B&quot;) &#125; // 接口成员默认就是“open”的 </span><br><span class="line">    fun b() &#123; print(&quot;b&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">class C() : A(), B &#123;</span><br><span class="line">    // 编译器要求覆盖 f()，因为不知道该调用哪个父类的方法</span><br><span class="line">    override fun f() &#123;</span><br><span class="line">        super&lt;A&gt;.f() // 调用 A.f()</span><br><span class="line">        super&lt;B&gt;.f() // 调用 B.f() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="data数据类"><a href="#data数据类" class="headerlink" title="data数据类"></a>data数据类</h4><p>在与服务器交互中经常有数据类，在Kotlin中直接使用data标记为数据类，它会根据构造函数的属性生成<code>equals</code> ， <code>hashcode</code> ， <code>toString</code> 方法，当然这块我们也是可以重写的。<br>需要注意的是：</p><ol><li>数据类主构造函数至少有一个参数</li><li>主构造函数的所有参数需要标记为 <code>val</code> 或 <code>var</code>；</li></ol><h4 id="单例声明"><a href="#单例声明" class="headerlink" title="单例声明"></a>单例声明</h4><p>在Java中写一个单例是很麻烦的事情，也有很多种不通过的写法，需要考虑多线程问题，但在Kotlin中单例就变得简单的多，使用 <code>object</code>关键字就可以实现单例,我们看下示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object Person &#123;</span><br><span class="line">    fun eat()&#123;</span><br><span class="line">        print(&quot;eat&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>翻译成为Java代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class Person &#123;</span><br><span class="line">   public static final Person INSTANCE;</span><br><span class="line"></span><br><span class="line">   public final void eat() &#123;</span><br><span class="line">      String var1 = &quot;eat&quot;;</span><br><span class="line">      System.out.print(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      Person var0 = new Person();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到上面代码实际为一个单例默认的饿汉模式实现。</p><h4 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h4><p>当需要修改一个类的部分功能，可以不通过显式实现一个该类的子类方式来实现。在Java中，通过匿名内部类来实现；在Kotlin中，概括为对象表达式和对象声明。最常见的就是我们代码中设置Listener。示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val test = object : View.OnClickListener() &#123;</span><br><span class="line">    override fun onClick(p0: View?) &#123;</span><br><span class="line">        Log.v(&quot;TAG&quot;,&quot;click listener&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有这种用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val adHoc = object &#123;  </span><br><span class="line">  var x: Int = 0  </span><br><span class="line">  var y: Int = 0  </span><br><span class="line">&#125;  </span><br><span class="line">print(adHoc.x + adHoc.y)</span><br></pre></td></tr></table></figure></p><h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><p>Kotlin中没有静态的属性和方法的概念， Kotlin官网建议我们使用包级别的函数，来替代静态方法。当然也可以在类内使用<code>companion object</code>关键字声明一个伴生对象。 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val  TAG = &quot;TEST&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    fun test()&#123;</span><br><span class="line">        Log.v(Test.TAG,&quot;test method&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>object</code>的使用有很多种，可参考这篇文章。 <a href="http://liuqingwen.me/blog/2017/06/20/object-vs-companion-object-in-kotlin/" target="_blank" rel="noopener">http://liuqingwen.me/blog/2017/06/20/object-vs-companion-object-in-kotlin/</a></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Kotlin 中的继承和接口大体上与 Java 一致，尤其是在 Java 8 后面的语法， 接口中可以包含实现了，和抽象类的概念更近了点，但是两个还是有些许的差别，这点需要自己多体会。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/09/08/kotlin-share-1/&quot;&gt;Kotlin开发基础（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/12/kotlin-share-2/&quot;&gt;Kotlin开发基础（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/17/kotlin-share-3/&quot;&gt;Kotlin开发基础（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;p&gt;本篇文章主要介绍类的继承，接口，复写，单例，以及object属性的介绍。&lt;/p&gt;
&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h4&gt;&lt;p&gt;Kotlin中的继承方式与Java类似，Java中所有对象都继承自&lt;code&gt;Object&lt;/code&gt;，而Kotlin中所有对象均继承自&lt;code&gt;Any&lt;/code&gt;。两者均不能多继承，只是表现形式不同，Kotlin继承使用冒号&lt;code&gt;：&lt;/code&gt;表示。想要复写某个方法，则也需要将方法标记为&lt;code&gt;open&lt;/code&gt;的才可以被复写。&lt;br&gt;&lt;strong&gt;切记一个类想要被继承，必须用 &lt;code&gt;open&lt;/code&gt; 或 &lt;code&gt;abstract&lt;/code&gt; 关键字 声明。&lt;/strong&gt;&lt;br&gt;示例如下；&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;open class person(name: String) // 必须申请为open才可以继承，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class  male(name: String)： Person(name)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h4&gt;&lt;p&gt;抽象类与这里与Java是一致的，通过&lt;code&gt;abstract&lt;/code&gt;关键字标记为抽象类，抽象类中抽象方法也用 &lt;code&gt;abstract&lt;/code&gt;标记。有了&lt;code&gt;abstract&lt;/code&gt; 则不再需要使用&lt;code&gt;open&lt;/code&gt;进行标注了。&lt;br&gt;示例如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;open class person() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    open fun eat() &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;abstract class oldPerson(): person() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override abstract fun sleep()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类和抽象方法是默认&lt;code&gt;open&lt;/code&gt;关键字修饰的&lt;/li&gt;
&lt;li&gt;复写抽象类中实现的方法，也必须要加&lt;code&gt;open&lt;/code&gt;关键字才可复写&lt;/li&gt;
&lt;li&gt;抽象类有抽象方法和方法的实现，可以有成员属性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.wxtlife.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin开发基础（二）</title>
    <link href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/"/>
    <id>http://www.wxtlife.com/2017/12/12/kotlin-share-2/</id>
    <published>2017-12-12T13:29:09.000Z</published>
    <updated>2018-03-16T15:49:44.453Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><ul><li><strong><a href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/">Kotlin开发基础（一）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/">Kotlin开发基础（二）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/">Kotlin开发基础（三）</a></strong></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>本篇文章主要介绍类的属性定义及getter和setter，构造器，主次构造函数相关知识。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>类使用 <code>class</code> 关键字来标识，这个与Java中一样的。但是在kotlin中默认类都是不可继承的，也就是所说的 <code>final</code> 的类型，如果需要别继承，则必须将其标记为 <code>open</code> 或者 <code>abstract</code> 类型。</p><h4 id="可见性声明"><a href="#可见性声明" class="headerlink" title="可见性声明"></a>可见性声明</h4><p>Kotlin 一共有四种可见性修饰符：<code>private、protected、internal、public</code>。<br>可见性修饰可用于函数、属性、类、对象和接口，但不能用于局部变量。<br>如果没有显式指定修饰符的话，默认可⻅性是 <code>public</code> 。与Java中默认类型不同。</p><h4 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h4><h5 id="getter-setter及filed关键字"><a href="#getter-setter及filed关键字" class="headerlink" title="getter/setter及filed关键字"></a>getter/setter及filed关键字</h5><p>在Kotlin中对于 <code>var</code> 的变量都会默认有 <code>setter</code> 和 <code>getter</code> 方法，对 <code>val</code> 的仅有 <code>getter</code> 方法，当然也可以复写 <code>getter</code> 和 <code>setter</code> 方法，一般写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>值得注意的是，在复写getter和setter时，新手很容易犯的一个错，请看如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">        get() = age</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            age = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码编译期间是没有任何问题，但是运行起来呢？发现发生了<code>StackOverflowError</code>。。。怎么会是这么个鬼错误。这么简单的代码还能写错？这里教大家一个展示转为Java的方法。通过 <code>Tools</code> —&gt; <code>Kotlin</code> —-&gt; <code>Show kotlin ByteCode</code> ,这里转出来是字节码，很难看，然后在对话框上面在点击 DeCompile 这样就出现Java代码了，看看上面的代码生成了什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class Person &#123;</span><br><span class="line">   public final int getAge() &#123;</span><br><span class="line">      return this.getAge();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final void setAge(int value) &#123;</span><br><span class="line">      this.setAge(value);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的 <code>getter</code> 和 <code>setter</code> 方法都调用的是自己的方法。所以就发生 <code>StackOverflowError</code> 的错误了。这怎么办？Kotlin官方也意识到这个问题啦，便有了<code>field</code> 关键字啦。<br>正确写法如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">get</span>() = field</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的写法请自行转换为java代码看看是什么代码。</p><ul><li><code>field</code>标识符只能用在属性的访问器内。</li></ul><h5 id="lateinit关键字"><a href="#lateinit关键字" class="headerlink" title="lateinit关键字"></a><code>lateinit</code>关键字</h5><p>由于Kotlin默认是不允许为空的，所以在声明变量时，必须对其进行赋值，但是有些时候，我们确时无法在一开始定义的时候就赋值，这时候就需要延迟赋值。这时就用 <code>lateinit</code> 关键字进行标记。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lateinit var ageStr: String</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>  </p><ol><li><code>lateinit</code> 只能对 <code>var</code> 类型的变量</li><li><code>lateinit</code> 不能用于基础类型，因为基础类型没有null的情况</li></ol><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>Kotlin中的类需要构造函数时，可以有一个主构造函数和多个次构造函数，当然也可以没有构造函数。</p><h5 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h5><p>主构造函数在类名后。<br>写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String) &#123;</span><br><span class="line">    /// some code ****</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果类中没有任何的代码时，则可以省略最后面的括号写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String)</span><br></pre></td></tr></table></figure></p><p>当构造函数有注解或者可见性修饰符时，构造函数需要加<code>constructor</code>关键字，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person private constructor(name: String)</span><br></pre></td></tr></table></figure></p><p><code>private</code> 指的是构造方法为<code>private</code> 类型。</p><p>由于主构造函数中是不能有代码块的，如果想要在构造函数中有代码块，则必须使用<code>init{}</code>语句块，将初始话语句写在init代码块中，代码块中可以访问到构造函数的属性，并执行一些语句块，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String) &#123;</span><br><span class="line">    private var mName: String</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;init&quot;)</span><br><span class="line">        mName = name.toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当在构造函数中的参数名前加上 <code>var</code> ，<code>val</code> 则表示此参数为类的一个成员变量。并且会自动会在构造函数中对其进行赋值，默认也会为其生成<code>get</code> 和 <code>set</code> 方法。不想对外访问则添加<code>private</code>修饰符即可。<br>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//会自动生成private name:String的类属性，且生成get方法（没有set因为是val的类型）</span><br><span class="line">class TestClass(val name:String) &#123;</span><br><span class="line">    fun test() &#123;</span><br><span class="line">        Log.v(&quot;TestClass&quot;,&quot;name = $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//下面是外部不可以访问name属性的</span><br><span class="line">class TestClass(private var name:String) &#123;</span><br><span class="line">    fun test() &#123;</span><br><span class="line">        Log.v(&quot;TestClass&quot;,&quot;name = $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二级构造"><a href="#二级构造" class="headerlink" title="二级构造"></a>二级构造</h4><p>二级构造函数，也称为次级构造函数。关于二级构造函数，主要有以下几点：</p><ul><li>次级构造函数不能省略 <code>constructor</code> 关键字；</li><li>当类拥有主构造函数时，任何一个二级构造函数都需要直接或间接通过另一个二级构造函数代理主构造函数；</li><li>类中的一个构造函数代理另一个构造函数，需要使用关键字this；</li></ul><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor(id: Int) &#123;//（构造函数No.0）主构造函数</span><br><span class="line">    var id = id//主构造函数初始化id</span><br><span class="line">    var name = &quot;&quot;</span><br><span class="line">    var age = 0</span><br><span class="line">    //（构造函数No.1）直接代理主构造函数</span><br><span class="line">    constructor(name: String, id: Int) : this(id) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    //（构造函数No.2）代理了构造函数No.1，间接代理主构造函数</span><br><span class="line">    constructor(name: String, age: Int, id: Int) : this(name, id) &#123;</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这类补充子类的次构造函数是无法直接代理到父类的方法。必须指向本类的主或次构造函数，但最终都必须指向主构造函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Kotlin 中的对一个类的声明比 Java 简单了很多，代码量也少了很多，尤其是对于数据类来说， 从这来看 Kotlin 的语法是比 Java 简洁了很多，节省码代码的时间。 </p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/09/08/kotlin-share-1/&quot;&gt;Kotlin开发基础（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/12/kotlin-share-2/&quot;&gt;Kotlin开发基础（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/17/kotlin-share-3/&quot;&gt;Kotlin开发基础（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;p&gt;本篇文章主要介绍类的属性定义及getter和setter，构造器，主次构造函数相关知识。&lt;/p&gt;
&lt;h4 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h4&gt;&lt;p&gt;类使用 &lt;code&gt;class&lt;/code&gt; 关键字来标识，这个与Java中一样的。但是在kotlin中默认类都是不可继承的，也就是所说的 &lt;code&gt;final&lt;/code&gt; 的类型，如果需要别继承，则必须将其标记为 &lt;code&gt;open&lt;/code&gt; 或者 &lt;code&gt;abstract&lt;/code&gt; 类型。&lt;/p&gt;
&lt;h4 id=&quot;可见性声明&quot;&gt;&lt;a href=&quot;#可见性声明&quot; class=&quot;headerlink&quot; title=&quot;可见性声明&quot;&gt;&lt;/a&gt;可见性声明&lt;/h4&gt;&lt;p&gt;Kotlin 一共有四种可见性修饰符：&lt;code&gt;private、protected、internal、public&lt;/code&gt;。&lt;br&gt;可见性修饰可用于函数、属性、类、对象和接口，但不能用于局部变量。&lt;br&gt;如果没有显式指定修饰符的话，默认可⻅性是 &lt;code&gt;public&lt;/code&gt; 。与Java中默认类型不同。&lt;/p&gt;
&lt;h4 id=&quot;类属性&quot;&gt;&lt;a href=&quot;#类属性&quot; class=&quot;headerlink&quot; title=&quot;类属性&quot;&gt;&lt;/a&gt;类属性&lt;/h4&gt;&lt;h5 id=&quot;getter-setter及filed关键字&quot;&gt;&lt;a href=&quot;#getter-setter及filed关键字&quot; class=&quot;headerlink&quot; title=&quot;getter/setter及filed关键字&quot;&gt;&lt;/a&gt;getter/setter及filed关键字&lt;/h5&gt;&lt;p&gt;在Kotlin中对于 &lt;code&gt;var&lt;/code&gt; 的变量都会默认有 &lt;code&gt;setter&lt;/code&gt; 和 &lt;code&gt;getter&lt;/code&gt; 方法，对 &lt;code&gt;val&lt;/code&gt; 的仅有 &lt;code&gt;getter&lt;/code&gt; 方法，当然也可以复写 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法，一般写法如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var &amp;lt;propertyName&amp;gt;[: &amp;lt;PropertyType&amp;gt;] [= &amp;lt;property_initializer&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&amp;lt;getter&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&amp;lt;setter&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.wxtlife.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android首次启动卡顿问题分析</title>
    <link href="http://www.wxtlife.com/2017/11/14/Android-first-launcher-problem/"/>
    <id>http://www.wxtlife.com/2017/11/14/Android-first-launcher-problem/</id>
    <published>2017-11-14T12:56:09.000Z</published>
    <updated>2018-03-16T15:49:44.448Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>在有些 Android 机器上首次启动时会出现很明显的卡顿问题，且比较明显的是只会在安装后的首次出现，很是奇怪，那么要分析这个问题则需要了解启动的不同类型的区别以及不同版本间的区别了。</p><h3 id="启动的分类"><a href="#启动的分类" class="headerlink" title="启动的分类"></a>启动的分类</h3><p>启动分三种，首次安装后的冷启动，冷启动，热启动</p><h4 id="首次安装完的冷启动"><a href="#首次安装完的冷启动" class="headerlink" title="首次安装完的冷启动"></a>首次安装完的冷启动</h4><p>这个指的是用户对APK进行安装后，首次进行打开的过程。</p><h4 id="app的冷启动"><a href="#app的冷启动" class="headerlink" title="app的冷启动"></a>app的冷启动</h4><p>指当启动应用时，后台没有该程序的进程。</p><h4 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h4><p>指程序依然在，启动时通过已有进程启动应用。</p><a id="more"></a><h3 id="虚拟机区别"><a href="#虚拟机区别" class="headerlink" title="虚拟机区别"></a>虚拟机区别</h3><h4 id="Dalvik（Android5-0-以下系统）"><a href="#Dalvik（Android5-0-以下系统）" class="headerlink" title="Dalvik（Android5.0 以下系统）"></a>Dalvik（Android5.0 以下系统）</h4><p>在5.0以下的版本中，默认的虚拟机为Dalvik，Dalvik虚拟机与Java虚拟机有差不多的特性，都是解释执行的。Dalvik采用的是JIT（及时编译）技术。 <code>.dex</code>格式是专为Dalvik设计的一种压缩格式,在每次执行应用的时候Dalvik虚拟机都会将程序的语言由高级语言编译为机器语言。</p><p>在应用启动时 JIT通过进行连续的性能分析来优化程序代码的执行，在程序运行的过程中，Dalvik虚拟机在不断的进行将字节码编译成机器码的工作，这样当前的程序才能运行。启动程序优化代码并存储在Dalvik缓存中。Dalvik第一次加载后会生成Cache文件，以提供下次快速加载，所以第一次会很慢。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><ul><li>1、 占用空间较小</li><li>2、 安装速度快</li></ul><p><strong>缺点：</strong></p><ul><li>1、 启动速度慢<h4 id="ART-Android-RunTime-Android-5-0-以上系统"><a href="#ART-Android-RunTime-Android-5-0-以上系统" class="headerlink" title="ART-Android RunTime (Android 5.0 以上系统)"></a>ART-Android RunTime (Android 5.0 以上系统)</h4></li></ul><p>在5.0以上的系统默认采用了<code>ART（Android RunTime）</code>模式，它正式的取代了以往的Dalvik虚拟机，ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机，ART采用Ahead-of-time（AOT）技术，此种模式对Dalvik进行了很多的优化，包括性能，以及垃圾回收器等。</p><p>在ART模式下系统在安装应用的时候会进行一次预编译，在安装应用程序时会先将代码转换为机器语言存储在本地，这样在运行程序时就不会每次都进行一次编译了，执行效率也大大提升。</p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点：</strong></p><ul><li>1、系统性能的显著提升。</li><li>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。</li><li>3、更长的电池续航能力。</li><li>4、支持更低的硬件。</li></ul><p><strong>缺点：</strong></p><ul><li>1、占用更多空间</li><li>2、安装时间变长</li></ul><p>对上面两个有个很好的比喻：</p><blockquote><p>Dalvik 是已经折叠起来的自行车，每次骑都要先组装自行车才能骑<br>ART 是已经组装好的自行车，每次骑直接上车就能走人</p></blockquote><h3 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h3><p>Dalvik是执行的时候编译+运行的模式。而ART是编译好的直接进行运行。<br>如果我们的应用比较大，比如有多个dex文件，那么这时候在不同虚拟机平台上启动速度是很不一样的，在Dalvik的虚拟机上，需要将每一个dex文件转化为机器码，dex越多越大则耗时越高，所以对于首次安装的冷启动是很慢很慢的，有时可能还会造成 ANR ，当然第一次之后会将相应的缓存保存在<code>data/dalvik-cache</code>下面，后续的冷启动读取缓存进行加载运行。相对会比首次安装后启动快很多。<br>然而在ART的模式下，由于其是在安装的过程中进行这部分处理的，所以应用的启动速度不受这些的影响。 </p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>对于在Dalvi虚拟机上的目前是没有很好的办法去解决首次安装后的冷启动，因为这个是系统虚拟机的限制导致此问题，此过程是必经之路。</p><p><strong>瞎方法（不推荐）</strong><br>对于系统定制开发来说，可以在自己代码中起一个很普通的service，什么都不做，启动起来只有就自己结束。然后另外一个系统常驻的service，监听系统新增的应用包，监听到后启动这个应用的空白service，这个过程就相当于让程序能够自运行一下。让虚拟机首次启动执行的过程跑一遍，加快后续在启动的一个启动速度。当然这样就会导致系统与应用有些耦合。当然这只是一个瞎推荐的方法。</p><h3 id="相关的参考资料"><a href="#相关的参考资料" class="headerlink" title="相关的参考资料"></a>相关的参考资料</h3><p>Activity 启动 Display 延迟问题源码分析代码如下：<a href="http://blog.csdn.net/kc58236582/article/details/60134836" target="_blank" rel="noopener">http://blog.csdn.net/kc58236582/article/details/60134836</a></p><p>Google 官方对于启动时间一些说明: <a href="https://developer.android.com/topic/performance/launch-time.html" target="_blank" rel="noopener">https://developer.android.com/topic/performance/launch-time.html </a>  </p><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队-1"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队-1" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;在有些 Android 机器上首次启动时会出现很明显的卡顿问题，且比较明显的是只会在安装后的首次出现，很是奇怪，那么要分析这个问题则需要了解启动的不同类型的区别以及不同版本间的区别了。&lt;/p&gt;
&lt;h3 id=&quot;启动的分类&quot;&gt;&lt;a href=&quot;#启动的分类&quot; class=&quot;headerlink&quot; title=&quot;启动的分类&quot;&gt;&lt;/a&gt;启动的分类&lt;/h3&gt;&lt;p&gt;启动分三种，首次安装后的冷启动，冷启动，热启动&lt;/p&gt;
&lt;h4 id=&quot;首次安装完的冷启动&quot;&gt;&lt;a href=&quot;#首次安装完的冷启动&quot; class=&quot;headerlink&quot; title=&quot;首次安装完的冷启动&quot;&gt;&lt;/a&gt;首次安装完的冷启动&lt;/h4&gt;&lt;p&gt;这个指的是用户对APK进行安装后，首次进行打开的过程。&lt;/p&gt;
&lt;h4 id=&quot;app的冷启动&quot;&gt;&lt;a href=&quot;#app的冷启动&quot; class=&quot;headerlink&quot; title=&quot;app的冷启动&quot;&gt;&lt;/a&gt;app的冷启动&lt;/h4&gt;&lt;p&gt;指当启动应用时，后台没有该程序的进程。&lt;/p&gt;
&lt;h4 id=&quot;热启动&quot;&gt;&lt;a href=&quot;#热启动&quot; class=&quot;headerlink&quot; title=&quot;热启动&quot;&gt;&lt;/a&gt;热启动&lt;/h4&gt;&lt;p&gt;指程序依然在，启动时通过已有进程启动应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【工具】gitignore全自动生成</title>
    <link href="http://www.wxtlife.com/2017/11/10/gitignore-auto-create/"/>
    <id>http://www.wxtlife.com/2017/11/10/gitignore-auto-create/</id>
    <published>2017-11-10T09:23:09.000Z</published>
    <updated>2018-03-16T15:49:44.451Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>今天给大家安利一款 gitignore 自动生成的在线软件，那么它有什么特别的功能呢？且慢看下面内容。</p><p>gitignore 文件大家应该比较熟悉，你必须把某些文件放到Git工作目录中，但又不能提交它们，或者在使用 git status 时看到很多不需要关心的 Untracked files … 文件 ，那么这时候就需要 .gitignore 文件了。</p><p>那么在新建项目时，由于使用不同的编译器，不同的语言以及不同的操作系统再或者使用不同的工具，都会或多或少在项目中生成一些不需要提交到仓库的文件，如果要想我们自己去一个个的添加 gitignore 配置那么就需要一个个查找哪些是不需要的而且还可能会遗漏，比较麻烦，那么今天介绍的工具就是解决这个问题的。</p><p>首先来看下网页的主界面：<br><img src="/img/ignore/ignore1.jpg" alt="ignore1"></p><a id="more"></a><p>可以在输入框中输入我们的操作系统，使用的语言，工具等，如下图：<br><img src="/img/ignore/ignore2.jpg" alt="ignore1"></p><p>然后点击 Create 看下结果。<br><img src="/img/ignore/ignore3.jpg" alt="ignore1"></p><p>当然还有很多的内容，这里就不贴出来了。虽然有些文件我们是没有遇到的，反正就是一个 gitignore 文件，不需要经常修改，所以全部贴到我们项目文件中就可以 。</p><p>工具的网址如下： <a href="https://www.gitignore.io/" target="_blank" rel="noopener">https://www.gitignore.io/</a></p><p>当然也可以点击阅读原文跳转到工具网址，如果你喜欢这个工具就点个赞吧，或者转发给你的同事吧。</p><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队-1"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队-1" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;今天给大家安利一款 gitignore 自动生成的在线软件，那么它有什么特别的功能呢？且慢看下面内容。&lt;/p&gt;
&lt;p&gt;gitignore 文件大家应该比较熟悉，你必须把某些文件放到Git工作目录中，但又不能提交它们，或者在使用 git status 时看到很多不需要关心的 Untracked files … 文件 ，那么这时候就需要 .gitignore 文件了。&lt;/p&gt;
&lt;p&gt;那么在新建项目时，由于使用不同的编译器，不同的语言以及不同的操作系统再或者使用不同的工具，都会或多或少在项目中生成一些不需要提交到仓库的文件，如果要想我们自己去一个个的添加 gitignore 配置那么就需要一个个查找哪些是不需要的而且还可能会遗漏，比较麻烦，那么今天介绍的工具就是解决这个问题的。&lt;/p&gt;
&lt;p&gt;首先来看下网页的主界面：&lt;br&gt;&lt;img src=&quot;/img/ignore/ignore1.jpg&quot; alt=&quot;ignore1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.wxtlife.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>还再用compile依赖？那你就落后啦</title>
    <link href="http://www.wxtlife.com/2017/11/05/Android-compile/"/>
    <id>http://www.wxtlife.com/2017/11/05/Android-compile/</id>
    <published>2017-11-05T05:56:45.000Z</published>
    <updated>2018-03-16T15:49:44.447Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>在上上一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzIwODI3MTc2Ng==&amp;mid=2649647447&amp;idx=1&amp;sn=4bcd221929a2982d231994af4aa0abe5&amp;chksm=8f1f69aeb868e0b8c5cf98c44a9b789a2fcd17497e3cd1df74aead19514c3a3bfeb0957c543c#rd" target="_blank" rel="noopener">《Android Studio 3.0版本正式发布啦》</a> 中说到AS 3.0 正式版已经出来了，讲到新版本支持的一些新特性，那么今天就来说说新版本中 Moudle 中 build.gradle 文件中的变化。</p><p>我们来看看新建一个项目在 Moudle 中的 dependencies 中的变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;</span><br><span class="line">    testImplementation &apos;junit:junit:4.12&apos;</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现我们经常添加依赖使用的 <code>compile</code>不见了，而现在改变为 <code>implementation</code>了，那么就来看看这个到底是有什么新的意思呢。</p><a id="more"></a><p>其实在新版本 <code>Android Gradle plugin 3.0</code> 中 已经将 <code>compile</code> 标记为过时了，而取而代之的是 <code>implementation</code> 和 <code>api</code> 两个关键字。那么它们有什么区别呢？</p><p><code>api</code> 关键字 其实等同于 <code>compile</code> 。但为什么要换个名字呢，目前还没有查到相关的信息，如有大神知道，请留言告知。</p><p><code>implementation</code> ： 使用了该命令编译的依赖，它仅仅对当前的 Moudle 提供接口。例如我们当前项目结构如下：<br><img src="http://mmbiz.qpic.cn/mmbiz_png/RTYpAoaia4pj3BRjGqTHkWulBLHNYrGxtY0Ao0QSGFLuq5Kl1ro9ribCwCD3z7YH36xibs6dgWYhKcTFkhfxcKkTA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="项目结构"><br>LibraryA 中引用了 LibraryC 的库，如果对 LibraryC 的依赖用的是 implementation 关键字。 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    . . . . </span><br><span class="line">    implementation project（path：&apos;：libraryC&apos;）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么 LibraryC 中的接口，仅仅只能给  LibraryA 使用，而我们的 App Moudle 是无法访问到 LibraryC 提供的接口的，也就是将该依赖隐藏在内部，而不对外部公开。这就是 implementation 关键字的作用。</p><p><strong> 那为什么要这么做呢？ </strong><br>答案是： 1.  加快编译速度。2.   隐藏对外不必要的接口。</p><p><strong> 为什么能加快编译速度呢？ </strong><br>这对于大型项目含有多个 Moudle 模块的， 以上图为例，比如我们改动 LibraryC 接口的相关代码，这时候编译只需要单独编译 LibraryA 模块就行， 如果使用的是 api 或者旧时代的 compile，由于App Moudle 也可以访问到 LibraryC ,所以 App Moudle 部分也需要重新编译。当然这是在全编的情况下。 </p><p>至于编译速度的对比，国外有个小哥已经做了简单的对比，效果还是不错。地址可点击原文跳转过去查看。 </p><p>那么我们现有项目中的依赖如何修改呢? 答案是：将 compile 都修改为 implementation 然后尝试进行项目构建，如果构建成功那么恭喜你，如果构建不成功，则查看相关的依赖项，并将其修改为 api 关键字依赖。</p><p>好了，今天就介绍这一个知识点，如果你有收获就关注我们吧，或者给我点个赞吧。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;在上上一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwODI3MTc2Ng==&amp;amp;mid=2649647447&amp;amp;idx=1&amp;amp;sn=4bcd221929a2982d231994af4aa0abe5&amp;amp;chksm=8f1f69aeb868e0b8c5cf98c44a9b789a2fcd17497e3cd1df74aead19514c3a3bfeb0957c543c#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Android Studio 3.0版本正式发布啦》&lt;/a&gt; 中说到AS 3.0 正式版已经出来了，讲到新版本支持的一些新特性，那么今天就来说说新版本中 Moudle 中 build.gradle 文件中的变化。&lt;/p&gt;
&lt;p&gt;我们来看看新建一个项目在 Moudle 中的 dependencies 中的变化。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation fileTree(dir: &amp;apos;libs&amp;apos;, include: [&amp;apos;*.jar&amp;apos;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;apos;com.android.support:appcompat-v7:26.1.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;apos;com.android.support.constraint:constraint-layout:1.0.2&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testImplementation &amp;apos;junit:junit:4.12&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    androidTestImplementation &amp;apos;com.android.support.test:runner:1.0.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    androidTestImplementation &amp;apos;com.android.support.test.espresso:espresso-core:3.0.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;发现我们经常添加依赖使用的 &lt;code&gt;compile&lt;/code&gt;不见了，而现在改变为 &lt;code&gt;implementation&lt;/code&gt;了，那么就来看看这个到底是有什么新的意思呢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="gradle" scheme="http://www.wxtlife.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android Support 库各版本功能介绍</title>
    <link href="http://www.wxtlife.com/2017/11/05/Android-support/"/>
    <id>http://www.wxtlife.com/2017/11/05/Android-support/</id>
    <published>2017-11-05T04:59:15.000Z</published>
    <updated>2018-03-16T15:49:44.450Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>Android 支持库软件有多个库，每个库均支持特定范围的 Android 平台版本和功能。像大家比较熟悉的 v4 、v7、 v13、v14 等。下面将分别介绍下各个库版本所兼容或带来的功能有哪些？</p><h3 id="v4-支持库"><a href="#v4-支持库" class="headerlink" title="v4 支持库"></a>v4 支持库</h3><p>v4库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。与其他支持库相比，它们包含的 API 集合最大，包括对应用组件、用户界面功能、辅助功能、数据处理、网络连接以及编程实用工具的支持。</p><blockquote><p>注：在支持库修订版 24.2.0 之前，存在一个 v4 支持库。为了提高效率，此库拆分成多个模块。出于向后兼容的考虑，如果您在 Gradle 脚本中列出了 support-v4，您的 APK 将包含所有的 v4 模块。不过，要减少 APK 大小，我们建议仅列出应用需要的特定模块。</p></blockquote><h4 id="v4-compat-库"><a href="#v4-compat-库" class="headerlink" title="v4 compat 库"></a>v4 compat 库</h4><p>此为众多框架 API 提供兼容性包装器，例如 Context.obtainDrawable() 和 View.performAccessibilityAction()</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-compat:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v4-core-utils-库"><a href="#v4-core-utils-库" class="headerlink" title="v4 core-utils 库"></a>v4 core-utils 库</h4><p>提供大量实用程序类，例如 AsyncTaskLoader 和 PermissionChecker。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-core-utils:24.2.0</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="v4-core-ui-库"><a href="#v4-core-ui-库" class="headerlink" title="v4 core-ui 库"></a>v4 core-ui 库</h4><p>实现各种 UI 相关组件，例如 ViewPager、NestedScrollView 和 ExploreByTouchHelper。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-core-ui:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v4-media-compat-库"><a href="#v4-media-compat-库" class="headerlink" title="v4 media-compat 库"></a>v4 media-compat 库</h4><p>向后移植部分媒体框架，包括 MediaBrowser 和 MediaSession。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-media-compat:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v4-fragment-库"><a href="#v4-fragment-库" class="headerlink" title="v4 fragment 库"></a>v4 fragment 库</h4><p>添加对使用片段封装用户界面和功能的支持，从而使应用能够提供可以在大屏幕设备与小屏幕设备之间进行调节的布局。此模块依赖于 compat、core-utils、core-ui 和 media-compat。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-fragment:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="Dalvik-可执行文件分包支持库"><a href="#Dalvik-可执行文件分包支持库" class="headerlink" title="Dalvik 可执行文件分包支持库"></a>Dalvik 可执行文件分包支持库</h4><p>此库可以为使用多个 Dalvik Executable (DEX) 文件开发应用提供支持。引用超过 65536 个方法的应用须使用 Dalvik 可执行文件分包配置。如需了解有关使用 Dalvik 可执行文件分包的详细信息，请参阅使用超过 6.4 万种方法开发应用。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:multidex:1.0.0</span><br></pre></td></tr></table></figure></p><h3 id="v7-支持库"><a href="#v7-支持库" class="headerlink" title="v7 支持库"></a>v7 支持库</h3><p>一些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。这些库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。</p><h4 id="v7-appcompat-库"><a href="#v7-appcompat-库" class="headerlink" title="v7 appcompat 库"></a>v7 appcompat 库</h4><p>此库添加了对操作栏用户界面设计模式的支持。此库包含对 Material Design 用户界面实现的支持。</p><blockquote><p>注：此库依赖于 v4 支持库。</p></blockquote><p>下面是 v7 appcompat 库中包含的一些关键类：</p><ul><li>ActionBar - 提供操作栏用户界面模式的实现。如需了解有关使用操作栏的详细信息，请参阅操作栏开发者指南。</li><li>AppCompatActivity - 添加一个应用 Activity 类，此类可作为使用支持库操作栏实现的 Activity 的基础类。</li><li>AppCompatDialog - 添加一个对话框类，此类可作为 AppCompat 主题对话框的基础类。</li><li>ShareActionProvider - 包含对可以添加到操作栏中的标准化分享操作（例如电子邮件或发帖至社交应用）的支持。<br>此库的 Gradle 构建脚本依赖关系标识符如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:appcompat-v7:24.2.0</span><br></pre></td></tr></table></figure></li></ul><h4 id="v7-cardview-库"><a href="#v7-cardview-库" class="headerlink" title="v7 cardview 库"></a>v7 cardview 库</h4><p>此库添加了对 CardView 小部件的支持，让您能够在卡片内显示信息，从而使应用具备一致的外观。这些卡片对 Material Design 实现非常有用，并在电视应用布局中广为使用。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:cardview-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v7-gridlayout-库"><a href="#v7-gridlayout-库" class="headerlink" title="v7 gridlayout 库"></a>v7 gridlayout 库</h4><p>下载 Android 支持库后，此库可以添加对 GridLayout 类的支持，让您能够使用网状方格安排用户界面元素。如需了解有关 v7 gridlayout 库 API 的详细信息，请参阅 API 参考中的 android.support.v7.widget 软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:gridlayout-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v7-mediarouter-库"><a href="#v7-mediarouter-库" class="headerlink" title="v7 mediarouter 库"></a>v7 mediarouter 库</h4><p>此库可以提供 MediaRouter、MediaRouteProvider 和支持 Google Cast 的相关媒体类。</p><p>一般而言，利用 v7 mediarouter 库中的 API，您可以控制当前设备到外部屏幕、扬声器和其他目标设备的媒体渠道和流的路由。此库包含的 API 可以用于发布应用特定的媒体路由提供程序、发现和选择目标设备，以及检查媒体状态，等等。如需了解有关 v7 mediarouter 库 API 的详细信息，请参阅 API 参考中的 android.support.v7.media 软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:mediarouter-v7:24.2.0</span><br></pre></td></tr></table></figure></p><blockquote><p>支持库 r18 中引入的 v7 mediarouter 库 API 在后续版本的支持库中可能会发生更改。目前，我们建议仅使用与 Google Cast 有关的库。</p></blockquote><h4 id="v7-palette-库"><a href="#v7-palette-库" class="headerlink" title="v7 palette 库"></a>v7 palette 库</h4><p>v7 palette 支持库包含 Palette 类，此类让您可以从图像中抽取突出颜色。例如，音乐应用可以使用 Palette 对象从专辑封面抽取主要颜色，然后使用这些颜色创建一个色彩协调的歌曲标题卡。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:palette-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v7-recyclerview-库"><a href="#v7-recyclerview-库" class="headerlink" title="v7 recyclerview 库"></a>v7 recyclerview 库</h4><p>recyclerview 库添加了 RecyclerView 类。此类能够为 RecyclerView 小部件提供支持，RecyclerView 是一种通过提供有限的数据项窗口有效显示大数据集的视图。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:recyclerview-v7:24.2.0</span><br></pre></td></tr></table></figure></p><p>####v7 Preference 支持库<br>首选项软件包提供的 API 支持添加 preference 对象（例如 CheckBoxPreference 和 ListPreference），方便用户修改 UI 设置。</p><p>v7 Preference 库添加了对接口（例如 Preference.OnPreferenceChangeListener 和 Preference.OnPreferenceClickListener）以及类（例如 CheckBoxPreference 和 ListPreference）的支持。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:preference-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="v8-支持库"><a href="#v8-支持库" class="headerlink" title="v8 支持库"></a>v8 支持库</h3><p>此库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。此库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。</p><h4 id="v8-renderscript-库"><a href="#v8-renderscript-库" class="headerlink" title="v8 renderscript 库"></a>v8 renderscript 库</h4><p>此库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。它添加了对 RenderScript 计算框架的支持。android.support.v8.renderscript 软件包中包含这些 API。请注意，在应用中添加这些 API 的步骤与添加其他支持库 API 迥然不同。如需了解有关在应用中使用这些 API 的详细信息，请参阅 RenderScript 开发者指南。</p><blockquote><p>注：Android Studio 和 Gradle 构建支持使用带支持库的 RenderScript。renderscript 库位于 build-tools/$VERSION/renderscript/ 文件夹中。</p></blockquote><p>以下示例显示了此库的 Gradle 构建脚本属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    renderscriptTargetApi 18</span><br><span class="line">    renderscriptSupportModeEnabled true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="v13-支持库"><a href="#v13-支持库" class="headerlink" title="v13 支持库"></a>v13 支持库</h3><p>此库旨在用于 Android 3.2（API 级别 13）及更高版本。它添加了对带有 (FragmentCompat) 类和其他片段支持类的 Fragment 用户界面模式的支持。如需了解有关片段的详细信息，请参阅片段开发者指南。如需了解有关 v13 支持库 API 的详细信息，请参阅 API 参考中的 android.support.v13 软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-v13:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="v14-Preference-支持库"><a href="#v14-Preference-支持库" class="headerlink" title="v14 Preference 支持库"></a>v14 Preference 支持库</h3><p>android.support.v14.preference 软件包提供的 API 添加了对首选项接口（例如 PreferenceFragment.OnPreferenceStartFragmentCallback 和 PreferenceFragment.OnPreferenceStartScreenCallback）以及类（例如 MultiSelectListPreference 和 PreferenceFragment）的支持。如需了解有关 v14 Preference 支持库 API 的详细信息，请参阅 API 参考中的首选项软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:preference-v14:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="适用于电视的-v17-Preference-支持库"><a href="#适用于电视的-v17-Preference-支持库" class="headerlink" title="适用于电视的 v17 Preference 支持库"></a>适用于电视的 v17 Preference 支持库</h3><p>android.support.v17.preference 软件包提供的 API 可以在电视设备上提供首选项接口，包括对 LeanbackListPreferenceDialogFragment.ViewHolder.OnItemClickListener 接口和类的支持，例如 BaseLeanbackPreferenceFragment 和 LeanbackPreferenceFragment。如需了解有关 v17 Preference 支持库 API 的详细信息，请参阅 API 参考中的首选项软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:preference-leanback-v17:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v17-Leanback-库"><a href="#v17-Leanback-库" class="headerlink" title="v17 Leanback 库"></a>v17 Leanback 库</h4><p>android.support.v17.leanback 软件包提供的 API 支持在电视设备上构建用户界面。它为电视应用提供了一些重要的小部件。一些值得注意的类包括：</p><ul><li>BrowseFragment - 一种用于创建主要布局的片段，主要布局用于浏览类别和媒体项目。</li><li>DetailsFragment - 用于 Leanback 细节屏幕的包装器片段。</li><li>PlaybackOverlayFragment - 用于显示播放控件及相关内容的 DetailsFragment 子类。</li><li>SearchFragment - 用于处理搜索的片段。片段可以接收用户的搜索请求并将其传递给应用提供的 SearchResultProvider。SearchResultProvider 可以将搜索结果返回给 SearchFragment，后者会将结果渲染到 RowsFragment 中。</li></ul><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:leanback-v17:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="注解支持库"><a href="#注解支持库" class="headerlink" title="注解支持库"></a>注解支持库</h3><p>注解软件包提供的 API 支持向应用中添加注解元数据。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-annotations:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="设计支持库"><a href="#设计支持库" class="headerlink" title="设计支持库"></a>设计支持库</h3><p>设计软件包提供的 API 支持向应用中添加 Material Design 组件和模式。</p><p>设计支持库添加了对应用开发者依赖的各种 Material Design 组件和模式的支持，例如抽屉式导航栏、浮动操作按钮 (FAB)、快捷信息栏和标签页。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:design:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="自定义标签页支持库"><a href="#自定义标签页支持库" class="headerlink" title="自定义标签页支持库"></a>自定义标签页支持库</h3><p>自定义标签页软件包提供的 API 支持向应用中添加自定义标签页并对其进行管理。</p><p>自定义标签页支持库添加了对自定义标签页服务和自定义标签页回调等各种类的支持。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:customtabs:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="百分比支持库"><a href="#百分比支持库" class="headerlink" title="百分比支持库"></a>百分比支持库</h3><p>百分比软件包提供的 API 支持向应用中添加基于百分比的尺寸并对其进行管理。</p><p>百分比支持库添加了对 PercentLayoutHelper.PercentLayoutParams 接口和各种类的支持，例如 PercentFrameLayout 和 PercentRelativeLayout。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:percent:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="适用于电视的应用建议支持库"><a href="#适用于电视的应用建议支持库" class="headerlink" title="适用于电视的应用建议支持库"></a>适用于电视的应用建议支持库</h3><p>应用建议软件包提供的 API 支持向电视设备上运行的应用中添加内容建议。</p><p>应用库添加了对注解（例如 ContentRecommendation.ContentMaturity 和各种类（例如 ContentRecommendation 和 RecommendationExtender）的支持。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:recommendation:24.2.0</span><br></pre></td></tr></table></figure></p><p>看完上面的介绍，是不是对 Google 这些 Support 库 有了更全面的了解以及各版本之间的区别。如果希望就分享出去让更多的人知道吧。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;Android 支持库软件有多个库，每个库均支持特定范围的 Android 平台版本和功能。像大家比较熟悉的 v4 、v7、 v13、v14 等。下面将分别介绍下各个库版本所兼容或带来的功能有哪些？&lt;/p&gt;
&lt;h3 id=&quot;v4-支持库&quot;&gt;&lt;a href=&quot;#v4-支持库&quot; class=&quot;headerlink&quot; title=&quot;v4 支持库&quot;&gt;&lt;/a&gt;v4 支持库&lt;/h3&gt;&lt;p&gt;v4库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。与其他支持库相比，它们包含的 API 集合最大，包括对应用组件、用户界面功能、辅助功能、数据处理、网络连接以及编程实用工具的支持。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在支持库修订版 24.2.0 之前，存在一个 v4 支持库。为了提高效率，此库拆分成多个模块。出于向后兼容的考虑，如果您在 Gradle 脚本中列出了 support-v4，您的 APK 将包含所有的 v4 模块。不过，要减少 APK 大小，我们建议仅列出应用需要的特定模块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;v4-compat-库&quot;&gt;&lt;a href=&quot;#v4-compat-库&quot; class=&quot;headerlink&quot; title=&quot;v4 compat 库&quot;&gt;&lt;/a&gt;v4 compat 库&lt;/h4&gt;&lt;p&gt;此为众多框架 API 提供兼容性包装器，例如 Context.obtainDrawable() 和 View.performAccessibilityAction()&lt;/p&gt;
&lt;p&gt;此库的 Gradle 构建脚本依赖关系标识符如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;com.android.support:support-compat:24.2.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;v4-core-utils-库&quot;&gt;&lt;a href=&quot;#v4-core-utils-库&quot; class=&quot;headerlink&quot; title=&quot;v4 core-utils 库&quot;&gt;&lt;/a&gt;v4 core-utils 库&lt;/h4&gt;&lt;p&gt;提供大量实用程序类，例如 AsyncTaskLoader 和 PermissionChecker。&lt;/p&gt;
&lt;p&gt;此库的 Gradle 构建脚本依赖关系标识符如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;com.android.support:support-core-utils:24.2.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【推荐】开发人员必备的强兵利器</title>
    <link href="http://www.wxtlife.com/2017/09/27/developers-need-tools/"/>
    <id>http://www.wxtlife.com/2017/09/27/developers-need-tools/</id>
    <published>2017-09-27T11:47:59.000Z</published>
    <updated>2018-03-16T15:49:44.450Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>熟话说“工欲善其事，必先利其器”，那么今天整理了些目前开发常用的一些软件或者插件，分享给大家，主要都是提高效率，便于开发的工具，希望能够对你的工作，学习有所帮助。</p><p>那么本篇文章将推荐5个插件类工具和5个软件类工具。分别介绍如下：</p><h3 id="插件类"><a href="#插件类" class="headerlink" title="插件类"></a>插件类</h3><h4 id="1-gliffy-Diagrams"><a href="#1-gliffy-Diagrams" class="headerlink" title="1. gliffy Diagrams"></a>1. gliffy Diagrams</h4><p>gliffy Diagrams一个轻量级Chrome 插件，简单易用，可以用它进行各种图形的绘制，比如：流程化，类图等，而且可以直接导入visio的文件进行二次编辑，绘制完成后，可以直接与google 云盘连接，便于保存和同步，当然其也有很多的主题与模板可供选择，绘制这些图，是开发理清思路的第一步。<br>界面如下：<br><img src="/img/tools/gliffy.jpeg" alt="gliffy"></p><h4 id="2-Momentum"><a href="#2-Momentum" class="headerlink" title="2.Momentum"></a>2.Momentum</h4><p>Momentum 可以给Chrome浏览器每天更换新标签页，让你每天可以看到漂亮的美图，除了美图风景，还有很多附加小功能，比如，天气，todolist，时间，今日任务，搜索等，可以给你的浏览器焕然一新。<br>一起来感受下美观的界面：<br><img src="/img/tools/motion.jpeg" alt="motion"></p><a id="more"></a><h4 id="3-Postman"><a href="#3-Postman" class="headerlink" title="3. Postman"></a>3. Postman</h4><p>Postman 是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。当开发人员需要调试相应后台接口时，可以把各种模拟用户HTTP请求的数据发送到服务器，以便开发人员能够及时地作出正确的响应，或者是对产品发布之前的错误信息提前处理，进而保证产品上线之后的稳定性和安全性。值得推荐的一个插件。<br>界面如下：<br><img src="/img/tools/postman.jpeg" alt="postman"></p><h4 id="4-Octotree"><a href="#4-Octotree" class="headerlink" title="4. Octotree"></a>4. Octotree</h4><p>Octotree 是一款可以在github上浏览代码，可以向本地一样方便便捷，简化各种目录间跳转的复杂，对在github阅读源码体验有很大的提升。<br>界面如下：<br><img src="/img/tools/tree.jpeg" alt="octotree"></p><h4 id="5-OneTab"><a href="#5-OneTab" class="headerlink" title="5. OneTab"></a>5. OneTab</h4><p>OneTab 是一款可以帮助用户一键杀死谷歌浏览器中所有标签页并通过提示恢复部分有用标签页的Chrome插件。当我们有很多的页面暂时不需要浏览了，但后续还需要的话，就可以使用OneTab进行保存，这样不仅可以保存浏览的网页，还可以省很多浏览器内存。<br>界面如下：<br><img src="/img/tools/onetable.jpeg" alt="onetable"></p><h3 id="软件类"><a href="#软件类" class="headerlink" title="软件类"></a>软件类</h3><h4 id="1-Charlas"><a href="#1-Charlas" class="headerlink" title="1. Charlas"></a>1. Charlas</h4><p>Charlas 是一个HTTP代理服务器,HTTP监视器,反转代理服务器，当连接Charles的代理访问互联网时，Charles可以监控浏览器发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括request, response和HTTP headers （包含cookies与caching信息）。<br><img src="/img/tools/charlets.jpeg" alt="charlets"></p><h4 id="2-Markman"><a href="#2-Markman" class="headerlink" title="2. Markman"></a>2. Markman</h4><p>Markman 是一个高效的设计稿标注、测量工具。这个工具主要是设计师使用，但偶尔开发也可以用下看下设计稿的标注等信息。主要功能，长度标记，坐标和矩形标记，颜色值标记，文字的标记说明。<br><img src="/img/tools/markman.jpeg" alt="markman"></p><h4 id="3-SourceTree"><a href="#3-SourceTree" class="headerlink" title="3. SourceTree"></a>3. SourceTree</h4><p>SourceTree 是一个简化了与Git存储库进行交互，从而可以专注于编码。通过Sourcetree的简单Git GUI可视化和管理您的存储库。可以与Github仓库绑定，点击某个提交，可以看到所有相关的修改信息。对开发者来说很是方便。<br><img src="/img/tools/sourcetree.jpeg" alt="sourcetree"></p><h4 id="4-1Password"><a href="#4-1Password" class="headerlink" title="4. 1Password"></a>4. 1Password</h4><p>1Password是管理网站登录和敏感信息的最好应用，它拥有友好的用户界面，可以在任何时刻在任何设备上使用，包括笔记本电脑、手机等。支持浏览器，可以在浏览器上不用输入账号密码实现登录功能，但是需要保存好主密码，不然其他密码都会泄露了。目前手机端的应用是免费的，PC端的需要收费。<br><img src="/img/tools/1password.jpeg" alt="1password"></p><h4 id="5-ohMyStar2-仅有mac端"><a href="#5-ohMyStar2-仅有mac端" class="headerlink" title="5. ohMyStar2  (仅有mac端)"></a>5. ohMyStar2  (仅有mac端)</h4><p>OhMyStar2 可以无缝同步你在Github star的所有repo，在本地浏览、搜索这些stared repo，还能根据语言自动分组（自动侦测你加星的repo所使用的语言，菜单栏-Tool-Group with languages），而且你能手动对所有repo进行group，可以按照日，周，月，发现流行的github仓库。所有数据都能通过iCloud进行备份/还原。<br><img src="/img/tools/ohmystart.jpeg" alt="onmystar2"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望上面10款工具可以给你带来工作上的便捷和帮助，如果喜欢，就把他分享出去吧，让更多人知道有这么多好的工具可提高我们的效率。</p><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;熟话说“工欲善其事，必先利其器”，那么今天整理了些目前开发常用的一些软件或者插件，分享给大家，主要都是提高效率，便于开发的工具，希望能够对你的工作，学习有所帮助。&lt;/p&gt;
&lt;p&gt;那么本篇文章将推荐5个插件类工具和5个软件类工具。分别介绍如下：&lt;/p&gt;
&lt;h3 id=&quot;插件类&quot;&gt;&lt;a href=&quot;#插件类&quot; class=&quot;headerlink&quot; title=&quot;插件类&quot;&gt;&lt;/a&gt;插件类&lt;/h3&gt;&lt;h4 id=&quot;1-gliffy-Diagrams&quot;&gt;&lt;a href=&quot;#1-gliffy-Diagrams&quot; class=&quot;headerlink&quot; title=&quot;1. gliffy Diagrams&quot;&gt;&lt;/a&gt;1. gliffy Diagrams&lt;/h4&gt;&lt;p&gt;gliffy Diagrams一个轻量级Chrome 插件，简单易用，可以用它进行各种图形的绘制，比如：流程化，类图等，而且可以直接导入visio的文件进行二次编辑，绘制完成后，可以直接与google 云盘连接，便于保存和同步，当然其也有很多的主题与模板可供选择，绘制这些图，是开发理清思路的第一步。&lt;br&gt;界面如下：&lt;br&gt;&lt;img src=&quot;/img/tools/gliffy.jpeg&quot; alt=&quot;gliffy&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-Momentum&quot;&gt;&lt;a href=&quot;#2-Momentum&quot; class=&quot;headerlink&quot; title=&quot;2.Momentum&quot;&gt;&lt;/a&gt;2.Momentum&lt;/h4&gt;&lt;p&gt;Momentum 可以给Chrome浏览器每天更换新标签页，让你每天可以看到漂亮的美图，除了美图风景，还有很多附加小功能，比如，天气，todolist，时间，今日任务，搜索等，可以给你的浏览器焕然一新。&lt;br&gt;一起来感受下美观的界面：&lt;br&gt;&lt;img src=&quot;/img/tools/motion.jpeg&quot; alt=&quot;motion&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.wxtlife.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
