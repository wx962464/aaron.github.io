<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Android技术特工队</title>
  
  <subtitle>人因梦想而伟大，因坚持而可贵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wxtlife.com/"/>
  <updated>2018-03-16T15:49:44.454Z</updated>
  <id>http://www.wxtlife.com/</id>
  
  <author>
    <name>WangXin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文章首发公众号【技术特工队】</title>
    <link href="http://www.wxtlife.com/2020/01/01/my-blog-step-wxtlife-com/"/>
    <id>http://www.wxtlife.com/2020/01/01/my-blog-step-wxtlife-com/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2018-03-16T15:49:44.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h3 id="【技术特工队】"><a href="#【技术特工队】" class="headerlink" title="【技术特工队】"></a><a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">【技术特工队】</a></h3><p><img src="http://www.wxtlife.com/img/qrcode/qrcode0.jpg" alt="技术特工队"> </p><h5 id="分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。"><a href="#分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。" class="headerlink" title="分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。"></a>分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队
      
    
    </summary>
    
      <category term="Blog" scheme="http://www.wxtlife.com/categories/Blog/"/>
    
    
      <category term="Blog" scheme="http://www.wxtlife.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>强大的终端工具ohMyZsh</title>
    <link href="http://www.wxtlife.com/2018/03/21/oh-my-zsh/"/>
    <id>http://www.wxtlife.com/2018/03/21/oh-my-zsh/</id>
    <published>2018-03-21T15:43:14.000Z</published>
    <updated>2018-03-21T15:50:27.924Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天给大家介绍一款强大的终端工具，一般系统默认的终端一般都很鸡肋，要么功能不够智能，要么就是不够美观，这怎么能够体现程序员高大上的逼格呢，所以今天就给大家介绍一款强大的终端工具 <code>oh-my-zsh</code>.</p><p>先来看张我的终端<br><img src="../img/ohmyzsh/ohmyzsh.png" alt="image"></p><p>那么有什么强大的功能呢？</p><ol><li>智能提示</li><li>自动跳转</li><li>智能纠错</li><li>与git 等工具高度集成</li><li>历史记录功能</li><li>目录跳转等</li></ol><p>上面只是我觉得很好用的一些功能，这只是冰山一角，还有其他很多的插件功能，反正一句话就是用了之后你就忘不掉的一个终端。</p><h3 id="什么是-ohMyZsh-介绍"><a href="#什么是-ohMyZsh-介绍" class="headerlink" title="什么是 ohMyZsh 介绍"></a>什么是 ohMyZsh 介绍</h3><p>首先的介绍下 <code>Zsh</code> ，<code>Zsh</code> 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。且其兼容Bash，能够为其补充很多强大的功能。那么 <code>Oh My Zsh</code> 是一款社区驱动的命令行工具，正如它的主页上说的，<code>Oh My Zsh</code> 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。<br><code>ohMyZsh</code> 拥有 200+ 的插件，及140+ 的主题样式，供你任意搭配定制。</p><a id="more"></a><h3 id="安装ohMyZsh"><a href="#安装ohMyZsh" class="headerlink" title="安装ohMyZsh"></a>安装ohMyZsh</h3><ol><li><p>通过 curl 方式安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>通过wget 方式安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure></li></ol><p>如果提示有文件没权限，可使用 sudo 命令进行安装。</p><p>安装完成后，验证是否安装成功。</p><p>如果输入 <code>zsh --version</code> 输出版本号则为安装成功。</p><p>使用 <code>chsh -s $(which zsh)</code> 讲默认的shell切换为zsh，然后通过 <code>$SHELL</code> 检查是否设置成功，如果输出为 <code>/bin/zsh</code>， 则切换默认为zsh 成功。</p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p><code>ohMyZsh</code>拥有很多的主题及插件，可以按照自己的需求来定制，那么怎么配置呢？<br>ohMyZsh 所有的配置都在用户根目录下面的 <code>~/.zshrc</code> 文件中进行配置。</p><p>主题文件的种类及样式可以到网页上查看 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a><br>默认安装就会有很多的主题样式可供配置了，本地主题的文件路径为 <code>~/.oh-my-zsh/themes</code> 可以进行查看。</p><p>喜欢某个主题只需要在 zshrc 文件中的 <code>ZSH_THEME=&quot;XXX&quot;</code>(XXX 为主题名) 例如我的主题为 <code>ZSH_THEME=&quot;agnoster&quot;</code> (<strong>安装这个主题需要安装字体库，因为其中用到了特殊字符</strong>)，具体安装教程可参考官方 <a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">https://github.com/agnoster/agnoster-zsh-theme</a> ,下面也有一些我遇到的问题汇总，如果还有问题可在公众号上留言与我交流。</p><p>样式如下：<br><img src="https://gist.githubusercontent.com/agnoster/3712874/raw/screenshot.png" alt="agnoster"></p><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>插件的种类实在是太多了，以至于有些插件的功能都不清楚，只能说是有需求的时候再去插件库找找是否有满足自己需求的插件。<br>插件库地址如下： <a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins</a><br>本地安装的插件库地址为 <code>~/.oh-my-zsh/plugins</code>。</p><p>添加插件的方法为在<code>~/.zshrc</code> 中，按照下面的格式将插件名称填入即可，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  git</span><br><span class="line">  brew</span><br><span class="line">  adb</span><br><span class="line">  npm</span><br><span class="line">  gradle</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>之后则可以体检到这些插件给你带来的便捷。</p><h3 id="异常问题汇总"><a href="#异常问题汇总" class="headerlink" title="异常问题汇总"></a>异常问题汇总</h3><h4 id="1-终端显示异常"><a href="#1-终端显示异常" class="headerlink" title="1. 终端显示异常"></a>1. 终端显示异常</h4><p>使用 agnoster 主题时， 显示的当前路径及分支信息出现部分乱码，显示很乱。</p><p><strong>解决办法：</strong><br>首先按照<a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">https://github.com/agnoster/agnoster-zsh-theme</a>进行安装，记得一定要安装字体。<br>推荐使用iterm2 然后在 <code>iTerm -&gt; Preferences -&gt; Profiles -&gt; Text</code><br>在下方将 <code>use a different font for non-ASCll text</code> 去掉勾选即可。</p><h4 id="2-默认终端显示名字过长"><a href="#2-默认终端显示名字过长" class="headerlink" title="2. 默认终端显示名字过长"></a>2. 默认终端显示名字过长</h4><p>默认显示了 <a href="mailto:username@host.machine" target="_blank" rel="noopener">username@host.machine</a> 显得很长， 不美观。</p><p><strong>解决办法：</strong></p><ul><li>方法1. 在 .zshrc 中添加  <code>DEFAULT_USER=&quot;$USER&quot;</code></li><li>方法2. 在.zshrc 最末尾，添加下面脚本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$USER&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-使用-ohmyzsh-后，-bash-profile-及-bashrc-不起作用"><a href="#3-使用-ohmyzsh-后，-bash-profile-及-bashrc-不起作用" class="headerlink" title="3. 使用 ohmyzsh 后，~/.bash_profile 及 ~/.bashrc 不起作用"></a>3. 使用 ohmyzsh 后，~/.bash_profile 及 ~/.bashrc 不起作用</h4><p><strong>解决办法：</strong><br>这是由于默认使用是zsh， 所以不会按照<code>/etc/profile --&gt;  /etc/paths  ---&gt;  ~/.bash_profile ---&gt; ~/.bash_login ---&gt;  ~/.profile ---&gt; ~/.bashrc</code><br>所以需要在~/.zshrc 的末尾加上加载文件的脚本，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ -f ~/.bash_profile ]; then</span><br><span class="line">   source ~/.bash_profile</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">   source ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>退出终端，然后重新加载即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天给大家介绍一款强大的终端工具，一般系统默认的终端一般都很鸡肋，要么功能不够智能，要么就是不够美观，这怎么能够体现程序员高大上的逼格呢，所以今天就给大家介绍一款强大的终端工具 &lt;code&gt;oh-my-zsh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;先来看张我的终端&lt;br&gt;&lt;img src=&quot;../img/ohmyzsh/ohmyzsh.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么有什么强大的功能呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;智能提示&lt;/li&gt;
&lt;li&gt;自动跳转&lt;/li&gt;
&lt;li&gt;智能纠错&lt;/li&gt;
&lt;li&gt;与git 等工具高度集成&lt;/li&gt;
&lt;li&gt;历史记录功能&lt;/li&gt;
&lt;li&gt;目录跳转等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面只是我觉得很好用的一些功能，这只是冰山一角，还有其他很多的插件功能，反正一句话就是用了之后你就忘不掉的一个终端。&lt;/p&gt;
&lt;h3 id=&quot;什么是-ohMyZsh-介绍&quot;&gt;&lt;a href=&quot;#什么是-ohMyZsh-介绍&quot; class=&quot;headerlink&quot; title=&quot;什么是 ohMyZsh 介绍&quot;&gt;&lt;/a&gt;什么是 ohMyZsh 介绍&lt;/h3&gt;&lt;p&gt;首先的介绍下 &lt;code&gt;Zsh&lt;/code&gt; ，&lt;code&gt;Zsh&lt;/code&gt; 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。且其兼容Bash，能够为其补充很多强大的功能。那么 &lt;code&gt;Oh My Zsh&lt;/code&gt; 是一款社区驱动的命令行工具，正如它的主页上说的，&lt;code&gt;Oh My Zsh&lt;/code&gt; 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。&lt;br&gt;&lt;code&gt;ohMyZsh&lt;/code&gt; 拥有 200+ 的插件，及140+ 的主题样式，供你任意搭配定制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Tools" scheme="http://www.wxtlife.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>【推荐】日志分析查看神器</title>
    <link href="http://www.wxtlife.com/2018/02/27/log-tools/"/>
    <id>http://www.wxtlife.com/2018/02/27/log-tools/</id>
    <published>2018-02-27T14:34:16.000Z</published>
    <updated>2018-03-16T15:49:44.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发中定位问题或者调试常常需要分析日志文件，但是对于日志文件一不小心就几百行甚至上千行的相信大家都有些惧怕，尤其在定位问题查看日志时，而且还有不同的tag需要过滤时，看了这个 tag，又要看另外一个 tag，到最后自己都凌乱了，不知道看到哪里了，看了哪些忘了那些，等等很多问题影响效率。</p><p>今天要给大家推荐一个查看日志的神器，至少我现在查看文本日志文件时，不会那么心累了，这款神器软件名字为：<strong>BBEditor</strong> ,遗憾的是目前只有 Mac 版，且也是收费的，不过作为福利，文末会给大家下载地址及注册码，让大家也来感受下查看日志的便捷。</p><a id="more"></a><h3 id="BBEditor-使用"><a href="#BBEditor-使用" class="headerlink" title="BBEditor 使用"></a>BBEditor 使用</h3><ol><li>打开此软件与普通文本软件没什么区别，直接打开或者将文件拖拽到软件中，直接看到整个文件的内容</li><li>过滤 tag，使用快捷键，<code>commond + f</code> 调出查找，然后输入要过滤的<br>tag，或者在文本中选中 tag，直接进行 <code>commond + f</code> 会自动填充查找内容，然后点击 <code>find all</code> 之后会启动一个新的界面，此界面分为两部分，上半部分和下半部分，上半部分的日志则为按照 tag 过滤后的日志结果，当点击选中上半部分的任何一行，下半部分则会显示出该行日志在整个文件中的的位置，且会自动显示出改行日志前后的相关日志。便于查看某些相关信息。</li><li>如果需要过滤过个日志，则在文件上使用 <code>commond + f</code> 命令进行查找，每次都会新开一个界面，便于多 tag 的文件定位。</li></ol><blockquote><p>当然还有很多的可配置参数，在设置中，这里只说基本的使用，高阶使用请自行研究。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了上面的工具，你是否觉得对查看日志不再那么畏惧了，因为这款工具确确实实解决了查看日志上的一些不便的地方。如果你有更好的工具欢迎留言交流。</p><h3 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h3><p>由于此软件只有 mac 版，且是收费的，故这里共享一版最新软件，且共享一个注册码，当然如有你有经济能力，建议进行购买正版。</p><blockquote><p><strong>领取方法：</strong> 在公众号对话框中，发送”日志” 两个字，则可以拿到最新版百度云下载地址及注册码。</p></blockquote><p><strong>如果你觉得文章有用，就帮忙分享出去或者帮忙点个赞吧~感激不尽~</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在开发中定位问题或者调试常常需要分析日志文件，但是对于日志文件一不小心就几百行甚至上千行的相信大家都有些惧怕，尤其在定位问题查看日志时，而且还有不同的tag需要过滤时，看了这个 tag，又要看另外一个 tag，到最后自己都凌乱了，不知道看到哪里了，看了哪些忘了那些，等等很多问题影响效率。&lt;/p&gt;
&lt;p&gt;今天要给大家推荐一个查看日志的神器，至少我现在查看文本日志文件时，不会那么心累了，这款神器软件名字为：&lt;strong&gt;BBEditor&lt;/strong&gt; ,遗憾的是目前只有 Mac 版，且也是收费的，不过作为福利，文末会给大家下载地址及注册码，让大家也来感受下查看日志的便捷。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="log" scheme="http://www.wxtlife.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin开发基础（三）</title>
    <link href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/"/>
    <id>http://www.wxtlife.com/2017/12/17/kotlin-share-3/</id>
    <published>2017-12-17T12:17:45.000Z</published>
    <updated>2018-03-16T15:49:44.453Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><ul><li><strong><a href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/">Kotlin开发基础（一）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/">Kotlin开发基础（二）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/">Kotlin开发基础（三）</a></strong></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>本篇文章主要介绍类的继承，接口，复写，单例，以及object属性的介绍。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>Kotlin中的继承方式与Java类似，Java中所有对象都继承自<code>Object</code>，而Kotlin中所有对象均继承自<code>Any</code>。两者均不能多继承，只是表现形式不同，Kotlin继承使用冒号<code>：</code>表示。想要复写某个方法，则也需要将方法标记为<code>open</code>的才可以被复写。<br><strong>切记一个类想要被继承，必须用 <code>open</code> 或 <code>abstract</code> 关键字 声明。</strong><br>示例如下；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class person(name: String) // 必须申请为open才可以继承，</span><br><span class="line"></span><br><span class="line">class  male(name: String)： Person(name)</span><br></pre></td></tr></table></figure></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类与这里与Java是一致的，通过<code>abstract</code>关键字标记为抽象类，抽象类中抽象方法也用 <code>abstract</code>标记。有了<code>abstract</code> 则不再需要使用<code>open</code>进行标注了。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open class person() &#123; </span><br><span class="line">    open fun eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class oldPerson(): person() &#123; </span><br><span class="line">    override abstract fun sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>抽象类和抽象方法是默认<code>open</code>关键字修饰的</li><li>复写抽象类中实现的方法，也必须要加<code>open</code>关键字才可复写</li><li>抽象类有抽象方法和方法的实现，可以有成员属性</li></ul><a id="more"></a><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>Kotlin中的接口需要使用关键字<code>interface</code>进行声明，Kotlin 的接口既包含抽象方法的声明，也可以包含实现，且接口中也可以申明属性，默认属性要求是抽象的，或者是提供访问器,其接口中的属性不能有<code>field</code>属性关键字。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface MyInterface &#123; </span><br><span class="line">    val prop: Int // 抽象的</span><br><span class="line">    val propertyWithImplementation: String get() = &quot;foo&quot;</span><br><span class="line">    fun foo() &#123; //方法实现</span><br><span class="line">        print(prop)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">class Child : MyInterface &#123; </span><br><span class="line">    override val prop: Int = 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中已经实现的方法，在子类中进行复写不需要在加<code>open</code>关键字。<br>在接口中</p><h4 id="复写"><a href="#复写" class="headerlink" title="复写"></a>复写</h4><p>复写关键字为 <code>override</code>，与Java的区别是没有了@符号了。复写这里需要注意两点</p><ol><li><code>var</code>可以复写<code>val</code>类型的，但是反之不行。</li><li>想要复写父类的方法，父类方法必须加<code>open</code>关键字标识。</li></ol><p>复写的规则中，如果继承和实现了同样的方法名，则必须在子类对该方法进行复写,以为编译器不知道该调用那个父类的方法。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;</span><br><span class="line">    open fun f() &#123; print(&quot;A&quot;) &#125; </span><br><span class="line">    fun a() &#123; print(&quot;a&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface B &#123;</span><br><span class="line">    fun f() &#123; print(&quot;B&quot;) &#125; // 接口成员默认就是“open”的 </span><br><span class="line">    fun b() &#123; print(&quot;b&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">class C() : A(), B &#123;</span><br><span class="line">    // 编译器要求覆盖 f()，因为不知道该调用哪个父类的方法</span><br><span class="line">    override fun f() &#123;</span><br><span class="line">        super&lt;A&gt;.f() // 调用 A.f()</span><br><span class="line">        super&lt;B&gt;.f() // 调用 B.f() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="data数据类"><a href="#data数据类" class="headerlink" title="data数据类"></a>data数据类</h4><p>在与服务器交互中经常有数据类，在Kotlin中直接使用data标记为数据类，它会根据构造函数的属性生成<code>equals</code> ， <code>hashcode</code> ， <code>toString</code> 方法，当然这块我们也是可以重写的。<br>需要注意的是：</p><ol><li>数据类主构造函数至少有一个参数</li><li>主构造函数的所有参数需要标记为 <code>val</code> 或 <code>var</code>；</li></ol><h4 id="单例声明"><a href="#单例声明" class="headerlink" title="单例声明"></a>单例声明</h4><p>在Java中写一个单例是很麻烦的事情，也有很多种不通过的写法，需要考虑多线程问题，但在Kotlin中单例就变得简单的多，使用 <code>object</code>关键字就可以实现单例,我们看下示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object Person &#123;</span><br><span class="line">    fun eat()&#123;</span><br><span class="line">        print(&quot;eat&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>翻译成为Java代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class Person &#123;</span><br><span class="line">   public static final Person INSTANCE;</span><br><span class="line"></span><br><span class="line">   public final void eat() &#123;</span><br><span class="line">      String var1 = &quot;eat&quot;;</span><br><span class="line">      System.out.print(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      Person var0 = new Person();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到上面代码实际为一个单例默认的饿汉模式实现。</p><h4 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h4><p>当需要修改一个类的部分功能，可以不通过显式实现一个该类的子类方式来实现。在Java中，通过匿名内部类来实现；在Kotlin中，概括为对象表达式和对象声明。最常见的就是我们代码中设置Listener。示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val test = object : View.OnClickListener() &#123;</span><br><span class="line">    override fun onClick(p0: View?) &#123;</span><br><span class="line">        Log.v(&quot;TAG&quot;,&quot;click listener&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有这种用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val adHoc = object &#123;  </span><br><span class="line">  var x: Int = 0  </span><br><span class="line">  var y: Int = 0  </span><br><span class="line">&#125;  </span><br><span class="line">print(adHoc.x + adHoc.y)</span><br></pre></td></tr></table></figure></p><h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><p>Kotlin中没有静态的属性和方法的概念， Kotlin官网建议我们使用包级别的函数，来替代静态方法。当然也可以在类内使用<code>companion object</code>关键字声明一个伴生对象。 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val  TAG = &quot;TEST&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    fun test()&#123;</span><br><span class="line">        Log.v(Test.TAG,&quot;test method&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>object</code>的使用有很多种，可参考这篇文章。 <a href="http://liuqingwen.me/blog/2017/06/20/object-vs-companion-object-in-kotlin/" target="_blank" rel="noopener">http://liuqingwen.me/blog/2017/06/20/object-vs-companion-object-in-kotlin/</a></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Kotlin 中的继承和接口大体上与 Java 一致，尤其是在 Java 8 后面的语法， 接口中可以包含实现了，和抽象类的概念更近了点，但是两个还是有些许的差别，这点需要自己多体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/09/08/kotlin-share-1/&quot;&gt;Kotlin开发基础（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/12/kotlin-share-2/&quot;&gt;Kotlin开发基础（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/17/kotlin-share-3/&quot;&gt;Kotlin开发基础（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;p&gt;本篇文章主要介绍类的继承，接口，复写，单例，以及object属性的介绍。&lt;/p&gt;
&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h4&gt;&lt;p&gt;Kotlin中的继承方式与Java类似，Java中所有对象都继承自&lt;code&gt;Object&lt;/code&gt;，而Kotlin中所有对象均继承自&lt;code&gt;Any&lt;/code&gt;。两者均不能多继承，只是表现形式不同，Kotlin继承使用冒号&lt;code&gt;：&lt;/code&gt;表示。想要复写某个方法，则也需要将方法标记为&lt;code&gt;open&lt;/code&gt;的才可以被复写。&lt;br&gt;&lt;strong&gt;切记一个类想要被继承，必须用 &lt;code&gt;open&lt;/code&gt; 或 &lt;code&gt;abstract&lt;/code&gt; 关键字 声明。&lt;/strong&gt;&lt;br&gt;示例如下；&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;open class person(name: String) // 必须申请为open才可以继承，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class  male(name: String)： Person(name)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h4&gt;&lt;p&gt;抽象类与这里与Java是一致的，通过&lt;code&gt;abstract&lt;/code&gt;关键字标记为抽象类，抽象类中抽象方法也用 &lt;code&gt;abstract&lt;/code&gt;标记。有了&lt;code&gt;abstract&lt;/code&gt; 则不再需要使用&lt;code&gt;open&lt;/code&gt;进行标注了。&lt;br&gt;示例如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;open class person() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    open fun eat() &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;abstract class oldPerson(): person() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override abstract fun sleep()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类和抽象方法是默认&lt;code&gt;open&lt;/code&gt;关键字修饰的&lt;/li&gt;
&lt;li&gt;复写抽象类中实现的方法，也必须要加&lt;code&gt;open&lt;/code&gt;关键字才可复写&lt;/li&gt;
&lt;li&gt;抽象类有抽象方法和方法的实现，可以有成员属性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.wxtlife.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin开发基础（二）</title>
    <link href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/"/>
    <id>http://www.wxtlife.com/2017/12/12/kotlin-share-2/</id>
    <published>2017-12-12T13:29:09.000Z</published>
    <updated>2018-03-16T15:49:44.453Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><ul><li><strong><a href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/">Kotlin开发基础（一）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/">Kotlin开发基础（二）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/">Kotlin开发基础（三）</a></strong></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>本篇文章主要介绍类的属性定义及getter和setter，构造器，主次构造函数相关知识。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>类使用 <code>class</code> 关键字来标识，这个与Java中一样的。但是在kotlin中默认类都是不可继承的，也就是所说的 <code>final</code> 的类型，如果需要别继承，则必须将其标记为 <code>open</code> 或者 <code>abstract</code> 类型。</p><h4 id="可见性声明"><a href="#可见性声明" class="headerlink" title="可见性声明"></a>可见性声明</h4><p>Kotlin 一共有四种可见性修饰符：<code>private、protected、internal、public</code>。<br>可见性修饰可用于函数、属性、类、对象和接口，但不能用于局部变量。<br>如果没有显式指定修饰符的话，默认可⻅性是 <code>public</code> 。与Java中默认类型不同。</p><h4 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h4><h5 id="getter-setter及filed关键字"><a href="#getter-setter及filed关键字" class="headerlink" title="getter/setter及filed关键字"></a>getter/setter及filed关键字</h5><p>在Kotlin中对于 <code>var</code> 的变量都会默认有 <code>setter</code> 和 <code>getter</code> 方法，对 <code>val</code> 的仅有 <code>getter</code> 方法，当然也可以复写 <code>getter</code> 和 <code>setter</code> 方法，一般写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>值得注意的是，在复写getter和setter时，新手很容易犯的一个错，请看如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">        get() = age</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            age = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码编译期间是没有任何问题，但是运行起来呢？发现发生了<code>StackOverflowError</code>。。。怎么会是这么个鬼错误。这么简单的代码还能写错？这里教大家一个展示转为Java的方法。通过 <code>Tools</code> —&gt; <code>Kotlin</code> —-&gt; <code>Show kotlin ByteCode</code> ,这里转出来是字节码，很难看，然后在对话框上面在点击 DeCompile 这样就出现Java代码了，看看上面的代码生成了什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class Person &#123;</span><br><span class="line">   public final int getAge() &#123;</span><br><span class="line">      return this.getAge();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final void setAge(int value) &#123;</span><br><span class="line">      this.setAge(value);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的 <code>getter</code> 和 <code>setter</code> 方法都调用的是自己的方法。所以就发生 <code>StackOverflowError</code> 的错误了。这怎么办？Kotlin官方也意识到这个问题啦，便有了<code>field</code> 关键字啦。<br>正确写法如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">get</span>() = field</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的写法请自行转换为java代码看看是什么代码。</p><ul><li><code>field</code>标识符只能用在属性的访问器内。</li></ul><h5 id="lateinit关键字"><a href="#lateinit关键字" class="headerlink" title="lateinit关键字"></a><code>lateinit</code>关键字</h5><p>由于Kotlin默认是不允许为空的，所以在声明变量时，必须对其进行赋值，但是有些时候，我们确时无法在一开始定义的时候就赋值，这时候就需要延迟赋值。这时就用 <code>lateinit</code> 关键字进行标记。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lateinit var ageStr: String</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>  </p><ol><li><code>lateinit</code> 只能对 <code>var</code> 类型的变量</li><li><code>lateinit</code> 不能用于基础类型，因为基础类型没有null的情况</li></ol><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>Kotlin中的类需要构造函数时，可以有一个主构造函数和多个次构造函数，当然也可以没有构造函数。</p><h5 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h5><p>主构造函数在类名后。<br>写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String) &#123;</span><br><span class="line">    /// some code ****</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果类中没有任何的代码时，则可以省略最后面的括号写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String)</span><br></pre></td></tr></table></figure></p><p>当构造函数有注解或者可见性修饰符时，构造函数需要加<code>constructor</code>关键字，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person private constructor(name: String)</span><br></pre></td></tr></table></figure></p><p><code>private</code> 指的是构造方法为<code>private</code> 类型。</p><p>由于主构造函数中是不能有代码块的，如果想要在构造函数中有代码块，则必须使用<code>init{}</code>语句块，将初始话语句写在init代码块中，代码块中可以访问到构造函数的属性，并执行一些语句块，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String) &#123;</span><br><span class="line">    private var mName: String</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;init&quot;)</span><br><span class="line">        mName = name.toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当在构造函数中的参数名前加上 <code>var</code> ，<code>val</code> 则表示此参数为类的一个成员变量。并且会自动会在构造函数中对其进行赋值，默认也会为其生成<code>get</code> 和 <code>set</code> 方法。不想对外访问则添加<code>private</code>修饰符即可。<br>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//会自动生成private name:String的类属性，且生成get方法（没有set因为是val的类型）</span><br><span class="line">class TestClass(val name:String) &#123;</span><br><span class="line">    fun test() &#123;</span><br><span class="line">        Log.v(&quot;TestClass&quot;,&quot;name = $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//下面是外部不可以访问name属性的</span><br><span class="line">class TestClass(private var name:String) &#123;</span><br><span class="line">    fun test() &#123;</span><br><span class="line">        Log.v(&quot;TestClass&quot;,&quot;name = $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二级构造"><a href="#二级构造" class="headerlink" title="二级构造"></a>二级构造</h4><p>二级构造函数，也称为次级构造函数。关于二级构造函数，主要有以下几点：</p><ul><li>次级构造函数不能省略 <code>constructor</code> 关键字；</li><li>当类拥有主构造函数时，任何一个二级构造函数都需要直接或间接通过另一个二级构造函数代理主构造函数；</li><li>类中的一个构造函数代理另一个构造函数，需要使用关键字this；</li></ul><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor(id: Int) &#123;//（构造函数No.0）主构造函数</span><br><span class="line">    var id = id//主构造函数初始化id</span><br><span class="line">    var name = &quot;&quot;</span><br><span class="line">    var age = 0</span><br><span class="line">    //（构造函数No.1）直接代理主构造函数</span><br><span class="line">    constructor(name: String, id: Int) : this(id) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    //（构造函数No.2）代理了构造函数No.1，间接代理主构造函数</span><br><span class="line">    constructor(name: String, age: Int, id: Int) : this(name, id) &#123;</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这类补充子类的次构造函数是无法直接代理到父类的方法。必须指向本类的主或次构造函数，但最终都必须指向主构造函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Kotlin 中的对一个类的声明比 Java 简单了很多，代码量也少了很多，尤其是对于数据类来说， 从这来看 Kotlin 的语法是比 Java 简洁了很多，节省码代码的时间。 </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/09/08/kotlin-share-1/&quot;&gt;Kotlin开发基础（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/12/kotlin-share-2/&quot;&gt;Kotlin开发基础（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/17/kotlin-share-3/&quot;&gt;Kotlin开发基础（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;p&gt;本篇文章主要介绍类的属性定义及getter和setter，构造器，主次构造函数相关知识。&lt;/p&gt;
&lt;h4 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h4&gt;&lt;p&gt;类使用 &lt;code&gt;class&lt;/code&gt; 关键字来标识，这个与Java中一样的。但是在kotlin中默认类都是不可继承的，也就是所说的 &lt;code&gt;final&lt;/code&gt; 的类型，如果需要别继承，则必须将其标记为 &lt;code&gt;open&lt;/code&gt; 或者 &lt;code&gt;abstract&lt;/code&gt; 类型。&lt;/p&gt;
&lt;h4 id=&quot;可见性声明&quot;&gt;&lt;a href=&quot;#可见性声明&quot; class=&quot;headerlink&quot; title=&quot;可见性声明&quot;&gt;&lt;/a&gt;可见性声明&lt;/h4&gt;&lt;p&gt;Kotlin 一共有四种可见性修饰符：&lt;code&gt;private、protected、internal、public&lt;/code&gt;。&lt;br&gt;可见性修饰可用于函数、属性、类、对象和接口，但不能用于局部变量。&lt;br&gt;如果没有显式指定修饰符的话，默认可⻅性是 &lt;code&gt;public&lt;/code&gt; 。与Java中默认类型不同。&lt;/p&gt;
&lt;h4 id=&quot;类属性&quot;&gt;&lt;a href=&quot;#类属性&quot; class=&quot;headerlink&quot; title=&quot;类属性&quot;&gt;&lt;/a&gt;类属性&lt;/h4&gt;&lt;h5 id=&quot;getter-setter及filed关键字&quot;&gt;&lt;a href=&quot;#getter-setter及filed关键字&quot; class=&quot;headerlink&quot; title=&quot;getter/setter及filed关键字&quot;&gt;&lt;/a&gt;getter/setter及filed关键字&lt;/h5&gt;&lt;p&gt;在Kotlin中对于 &lt;code&gt;var&lt;/code&gt; 的变量都会默认有 &lt;code&gt;setter&lt;/code&gt; 和 &lt;code&gt;getter&lt;/code&gt; 方法，对 &lt;code&gt;val&lt;/code&gt; 的仅有 &lt;code&gt;getter&lt;/code&gt; 方法，当然也可以复写 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法，一般写法如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var &amp;lt;propertyName&amp;gt;[: &amp;lt;PropertyType&amp;gt;] [= &amp;lt;property_initializer&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&amp;lt;getter&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&amp;lt;setter&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.wxtlife.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android首次启动卡顿问题分析</title>
    <link href="http://www.wxtlife.com/2017/11/14/Android-first-launcher-problem/"/>
    <id>http://www.wxtlife.com/2017/11/14/Android-first-launcher-problem/</id>
    <published>2017-11-14T12:56:09.000Z</published>
    <updated>2018-03-16T15:49:44.448Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>在有些 Android 机器上首次启动时会出现很明显的卡顿问题，且比较明显的是只会在安装后的首次出现，很是奇怪，那么要分析这个问题则需要了解启动的不同类型的区别以及不同版本间的区别了。</p><h3 id="启动的分类"><a href="#启动的分类" class="headerlink" title="启动的分类"></a>启动的分类</h3><p>启动分三种，首次安装后的冷启动，冷启动，热启动</p><h4 id="首次安装完的冷启动"><a href="#首次安装完的冷启动" class="headerlink" title="首次安装完的冷启动"></a>首次安装完的冷启动</h4><p>这个指的是用户对APK进行安装后，首次进行打开的过程。</p><h4 id="app的冷启动"><a href="#app的冷启动" class="headerlink" title="app的冷启动"></a>app的冷启动</h4><p>指当启动应用时，后台没有该程序的进程。</p><h4 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h4><p>指程序依然在，启动时通过已有进程启动应用。</p><a id="more"></a><h3 id="虚拟机区别"><a href="#虚拟机区别" class="headerlink" title="虚拟机区别"></a>虚拟机区别</h3><h4 id="Dalvik（Android5-0-以下系统）"><a href="#Dalvik（Android5-0-以下系统）" class="headerlink" title="Dalvik（Android5.0 以下系统）"></a>Dalvik（Android5.0 以下系统）</h4><p>在5.0以下的版本中，默认的虚拟机为Dalvik，Dalvik虚拟机与Java虚拟机有差不多的特性，都是解释执行的。Dalvik采用的是JIT（及时编译）技术。 <code>.dex</code>格式是专为Dalvik设计的一种压缩格式,在每次执行应用的时候Dalvik虚拟机都会将程序的语言由高级语言编译为机器语言。</p><p>在应用启动时 JIT通过进行连续的性能分析来优化程序代码的执行，在程序运行的过程中，Dalvik虚拟机在不断的进行将字节码编译成机器码的工作，这样当前的程序才能运行。启动程序优化代码并存储在Dalvik缓存中。Dalvik第一次加载后会生成Cache文件，以提供下次快速加载，所以第一次会很慢。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><ul><li>1、 占用空间较小</li><li>2、 安装速度快</li></ul><p><strong>缺点：</strong></p><ul><li>1、 启动速度慢<h4 id="ART-Android-RunTime-Android-5-0-以上系统"><a href="#ART-Android-RunTime-Android-5-0-以上系统" class="headerlink" title="ART-Android RunTime (Android 5.0 以上系统)"></a>ART-Android RunTime (Android 5.0 以上系统)</h4></li></ul><p>在5.0以上的系统默认采用了<code>ART（Android RunTime）</code>模式，它正式的取代了以往的Dalvik虚拟机，ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机，ART采用Ahead-of-time（AOT）技术，此种模式对Dalvik进行了很多的优化，包括性能，以及垃圾回收器等。</p><p>在ART模式下系统在安装应用的时候会进行一次预编译，在安装应用程序时会先将代码转换为机器语言存储在本地，这样在运行程序时就不会每次都进行一次编译了，执行效率也大大提升。</p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点：</strong></p><ul><li>1、系统性能的显著提升。</li><li>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。</li><li>3、更长的电池续航能力。</li><li>4、支持更低的硬件。</li></ul><p><strong>缺点：</strong></p><ul><li>1、占用更多空间</li><li>2、安装时间变长</li></ul><p>对上面两个有个很好的比喻：</p><blockquote><p>Dalvik 是已经折叠起来的自行车，每次骑都要先组装自行车才能骑<br>ART 是已经组装好的自行车，每次骑直接上车就能走人</p></blockquote><h3 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h3><p>Dalvik是执行的时候编译+运行的模式。而ART是编译好的直接进行运行。<br>如果我们的应用比较大，比如有多个dex文件，那么这时候在不同虚拟机平台上启动速度是很不一样的，在Dalvik的虚拟机上，需要将每一个dex文件转化为机器码，dex越多越大则耗时越高，所以对于首次安装的冷启动是很慢很慢的，有时可能还会造成 ANR ，当然第一次之后会将相应的缓存保存在<code>data/dalvik-cache</code>下面，后续的冷启动读取缓存进行加载运行。相对会比首次安装后启动快很多。<br>然而在ART的模式下，由于其是在安装的过程中进行这部分处理的，所以应用的启动速度不受这些的影响。 </p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>对于在Dalvi虚拟机上的目前是没有很好的办法去解决首次安装后的冷启动，因为这个是系统虚拟机的限制导致此问题，此过程是必经之路。</p><p><strong>瞎方法（不推荐）</strong><br>对于系统定制开发来说，可以在自己代码中起一个很普通的service，什么都不做，启动起来只有就自己结束。然后另外一个系统常驻的service，监听系统新增的应用包，监听到后启动这个应用的空白service，这个过程就相当于让程序能够自运行一下。让虚拟机首次启动执行的过程跑一遍，加快后续在启动的一个启动速度。当然这样就会导致系统与应用有些耦合。当然这只是一个瞎推荐的方法。</p><h3 id="相关的参考资料"><a href="#相关的参考资料" class="headerlink" title="相关的参考资料"></a>相关的参考资料</h3><p>Activity 启动 Display 延迟问题源码分析代码如下：<a href="http://blog.csdn.net/kc58236582/article/details/60134836" target="_blank" rel="noopener">http://blog.csdn.net/kc58236582/article/details/60134836</a></p><p>Google 官方对于启动时间一些说明: <a href="https://developer.android.com/topic/performance/launch-time.html" target="_blank" rel="noopener">https://developer.android.com/topic/performance/launch-time.html </a>  </p><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队-1"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队-1" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;在有些 Android 机器上首次启动时会出现很明显的卡顿问题，且比较明显的是只会在安装后的首次出现，很是奇怪，那么要分析这个问题则需要了解启动的不同类型的区别以及不同版本间的区别了。&lt;/p&gt;
&lt;h3 id=&quot;启动的分类&quot;&gt;&lt;a href=&quot;#启动的分类&quot; class=&quot;headerlink&quot; title=&quot;启动的分类&quot;&gt;&lt;/a&gt;启动的分类&lt;/h3&gt;&lt;p&gt;启动分三种，首次安装后的冷启动，冷启动，热启动&lt;/p&gt;
&lt;h4 id=&quot;首次安装完的冷启动&quot;&gt;&lt;a href=&quot;#首次安装完的冷启动&quot; class=&quot;headerlink&quot; title=&quot;首次安装完的冷启动&quot;&gt;&lt;/a&gt;首次安装完的冷启动&lt;/h4&gt;&lt;p&gt;这个指的是用户对APK进行安装后，首次进行打开的过程。&lt;/p&gt;
&lt;h4 id=&quot;app的冷启动&quot;&gt;&lt;a href=&quot;#app的冷启动&quot; class=&quot;headerlink&quot; title=&quot;app的冷启动&quot;&gt;&lt;/a&gt;app的冷启动&lt;/h4&gt;&lt;p&gt;指当启动应用时，后台没有该程序的进程。&lt;/p&gt;
&lt;h4 id=&quot;热启动&quot;&gt;&lt;a href=&quot;#热启动&quot; class=&quot;headerlink&quot; title=&quot;热启动&quot;&gt;&lt;/a&gt;热启动&lt;/h4&gt;&lt;p&gt;指程序依然在，启动时通过已有进程启动应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【工具】gitignore全自动生成</title>
    <link href="http://www.wxtlife.com/2017/11/10/gitignore-auto-create/"/>
    <id>http://www.wxtlife.com/2017/11/10/gitignore-auto-create/</id>
    <published>2017-11-10T09:23:09.000Z</published>
    <updated>2018-03-16T15:49:44.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>今天给大家安利一款 gitignore 自动生成的在线软件，那么它有什么特别的功能呢？且慢看下面内容。</p><p>gitignore 文件大家应该比较熟悉，你必须把某些文件放到Git工作目录中，但又不能提交它们，或者在使用 git status 时看到很多不需要关心的 Untracked files … 文件 ，那么这时候就需要 .gitignore 文件了。</p><p>那么在新建项目时，由于使用不同的编译器，不同的语言以及不同的操作系统再或者使用不同的工具，都会或多或少在项目中生成一些不需要提交到仓库的文件，如果要想我们自己去一个个的添加 gitignore 配置那么就需要一个个查找哪些是不需要的而且还可能会遗漏，比较麻烦，那么今天介绍的工具就是解决这个问题的。</p><p>首先来看下网页的主界面：<br><img src="/img/ignore/ignore1.jpg" alt="ignore1"></p><a id="more"></a><p>可以在输入框中输入我们的操作系统，使用的语言，工具等，如下图：<br><img src="/img/ignore/ignore2.jpg" alt="ignore1"></p><p>然后点击 Create 看下结果。<br><img src="/img/ignore/ignore3.jpg" alt="ignore1"></p><p>当然还有很多的内容，这里就不贴出来了。虽然有些文件我们是没有遇到的，反正就是一个 gitignore 文件，不需要经常修改，所以全部贴到我们项目文件中就可以 。</p><p>工具的网址如下： <a href="https://www.gitignore.io/" target="_blank" rel="noopener">https://www.gitignore.io/</a></p><p>当然也可以点击阅读原文跳转到工具网址，如果你喜欢这个工具就点个赞吧，或者转发给你的同事吧。</p><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队-1"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队-1" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;今天给大家安利一款 gitignore 自动生成的在线软件，那么它有什么特别的功能呢？且慢看下面内容。&lt;/p&gt;
&lt;p&gt;gitignore 文件大家应该比较熟悉，你必须把某些文件放到Git工作目录中，但又不能提交它们，或者在使用 git status 时看到很多不需要关心的 Untracked files … 文件 ，那么这时候就需要 .gitignore 文件了。&lt;/p&gt;
&lt;p&gt;那么在新建项目时，由于使用不同的编译器，不同的语言以及不同的操作系统再或者使用不同的工具，都会或多或少在项目中生成一些不需要提交到仓库的文件，如果要想我们自己去一个个的添加 gitignore 配置那么就需要一个个查找哪些是不需要的而且还可能会遗漏，比较麻烦，那么今天介绍的工具就是解决这个问题的。&lt;/p&gt;
&lt;p&gt;首先来看下网页的主界面：&lt;br&gt;&lt;img src=&quot;/img/ignore/ignore1.jpg&quot; alt=&quot;ignore1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.wxtlife.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>还再用compile依赖？那你就落后啦</title>
    <link href="http://www.wxtlife.com/2017/11/05/Android-compile/"/>
    <id>http://www.wxtlife.com/2017/11/05/Android-compile/</id>
    <published>2017-11-05T05:56:45.000Z</published>
    <updated>2018-03-16T15:49:44.447Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>在上上一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzIwODI3MTc2Ng==&amp;mid=2649647447&amp;idx=1&amp;sn=4bcd221929a2982d231994af4aa0abe5&amp;chksm=8f1f69aeb868e0b8c5cf98c44a9b789a2fcd17497e3cd1df74aead19514c3a3bfeb0957c543c#rd" target="_blank" rel="noopener">《Android Studio 3.0版本正式发布啦》</a> 中说到AS 3.0 正式版已经出来了，讲到新版本支持的一些新特性，那么今天就来说说新版本中 Moudle 中 build.gradle 文件中的变化。</p><p>我们来看看新建一个项目在 Moudle 中的 dependencies 中的变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;</span><br><span class="line">    testImplementation &apos;junit:junit:4.12&apos;</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现我们经常添加依赖使用的 <code>compile</code>不见了，而现在改变为 <code>implementation</code>了，那么就来看看这个到底是有什么新的意思呢。</p><a id="more"></a><p>其实在新版本 <code>Android Gradle plugin 3.0</code> 中 已经将 <code>compile</code> 标记为过时了，而取而代之的是 <code>implementation</code> 和 <code>api</code> 两个关键字。那么它们有什么区别呢？</p><p><code>api</code> 关键字 其实等同于 <code>compile</code> 。但为什么要换个名字呢，目前还没有查到相关的信息，如有大神知道，请留言告知。</p><p><code>implementation</code> ： 使用了该命令编译的依赖，它仅仅对当前的 Moudle 提供接口。例如我们当前项目结构如下：<br><img src="http://mmbiz.qpic.cn/mmbiz_png/RTYpAoaia4pj3BRjGqTHkWulBLHNYrGxtY0Ao0QSGFLuq5Kl1ro9ribCwCD3z7YH36xibs6dgWYhKcTFkhfxcKkTA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="项目结构"><br>LibraryA 中引用了 LibraryC 的库，如果对 LibraryC 的依赖用的是 implementation 关键字。 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    . . . . </span><br><span class="line">    implementation project（path：&apos;：libraryC&apos;）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么 LibraryC 中的接口，仅仅只能给  LibraryA 使用，而我们的 App Moudle 是无法访问到 LibraryC 提供的接口的，也就是将该依赖隐藏在内部，而不对外部公开。这就是 implementation 关键字的作用。</p><p><strong> 那为什么要这么做呢？ </strong><br>答案是： 1.  加快编译速度。2.   隐藏对外不必要的接口。</p><p><strong> 为什么能加快编译速度呢？ </strong><br>这对于大型项目含有多个 Moudle 模块的， 以上图为例，比如我们改动 LibraryC 接口的相关代码，这时候编译只需要单独编译 LibraryA 模块就行， 如果使用的是 api 或者旧时代的 compile，由于App Moudle 也可以访问到 LibraryC ,所以 App Moudle 部分也需要重新编译。当然这是在全编的情况下。 </p><p>至于编译速度的对比，国外有个小哥已经做了简单的对比，效果还是不错。地址可点击原文跳转过去查看。 </p><p>那么我们现有项目中的依赖如何修改呢? 答案是：将 compile 都修改为 implementation 然后尝试进行项目构建，如果构建成功那么恭喜你，如果构建不成功，则查看相关的依赖项，并将其修改为 api 关键字依赖。</p><p>好了，今天就介绍这一个知识点，如果你有收获就关注我们吧，或者给我点个赞吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;在上上一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwODI3MTc2Ng==&amp;amp;mid=2649647447&amp;amp;idx=1&amp;amp;sn=4bcd221929a2982d231994af4aa0abe5&amp;amp;chksm=8f1f69aeb868e0b8c5cf98c44a9b789a2fcd17497e3cd1df74aead19514c3a3bfeb0957c543c#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Android Studio 3.0版本正式发布啦》&lt;/a&gt; 中说到AS 3.0 正式版已经出来了，讲到新版本支持的一些新特性，那么今天就来说说新版本中 Moudle 中 build.gradle 文件中的变化。&lt;/p&gt;
&lt;p&gt;我们来看看新建一个项目在 Moudle 中的 dependencies 中的变化。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation fileTree(dir: &amp;apos;libs&amp;apos;, include: [&amp;apos;*.jar&amp;apos;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;apos;com.android.support:appcompat-v7:26.1.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;apos;com.android.support.constraint:constraint-layout:1.0.2&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testImplementation &amp;apos;junit:junit:4.12&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    androidTestImplementation &amp;apos;com.android.support.test:runner:1.0.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    androidTestImplementation &amp;apos;com.android.support.test.espresso:espresso-core:3.0.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;发现我们经常添加依赖使用的 &lt;code&gt;compile&lt;/code&gt;不见了，而现在改变为 &lt;code&gt;implementation&lt;/code&gt;了，那么就来看看这个到底是有什么新的意思呢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="gradle" scheme="http://www.wxtlife.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android Support 库各版本功能介绍</title>
    <link href="http://www.wxtlife.com/2017/11/05/Android-support/"/>
    <id>http://www.wxtlife.com/2017/11/05/Android-support/</id>
    <published>2017-11-05T04:59:15.000Z</published>
    <updated>2018-03-16T15:49:44.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>Android 支持库软件有多个库，每个库均支持特定范围的 Android 平台版本和功能。像大家比较熟悉的 v4 、v7、 v13、v14 等。下面将分别介绍下各个库版本所兼容或带来的功能有哪些？</p><h3 id="v4-支持库"><a href="#v4-支持库" class="headerlink" title="v4 支持库"></a>v4 支持库</h3><p>v4库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。与其他支持库相比，它们包含的 API 集合最大，包括对应用组件、用户界面功能、辅助功能、数据处理、网络连接以及编程实用工具的支持。</p><blockquote><p>注：在支持库修订版 24.2.0 之前，存在一个 v4 支持库。为了提高效率，此库拆分成多个模块。出于向后兼容的考虑，如果您在 Gradle 脚本中列出了 support-v4，您的 APK 将包含所有的 v4 模块。不过，要减少 APK 大小，我们建议仅列出应用需要的特定模块。</p></blockquote><h4 id="v4-compat-库"><a href="#v4-compat-库" class="headerlink" title="v4 compat 库"></a>v4 compat 库</h4><p>此为众多框架 API 提供兼容性包装器，例如 Context.obtainDrawable() 和 View.performAccessibilityAction()</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-compat:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v4-core-utils-库"><a href="#v4-core-utils-库" class="headerlink" title="v4 core-utils 库"></a>v4 core-utils 库</h4><p>提供大量实用程序类，例如 AsyncTaskLoader 和 PermissionChecker。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-core-utils:24.2.0</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="v4-core-ui-库"><a href="#v4-core-ui-库" class="headerlink" title="v4 core-ui 库"></a>v4 core-ui 库</h4><p>实现各种 UI 相关组件，例如 ViewPager、NestedScrollView 和 ExploreByTouchHelper。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-core-ui:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v4-media-compat-库"><a href="#v4-media-compat-库" class="headerlink" title="v4 media-compat 库"></a>v4 media-compat 库</h4><p>向后移植部分媒体框架，包括 MediaBrowser 和 MediaSession。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-media-compat:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v4-fragment-库"><a href="#v4-fragment-库" class="headerlink" title="v4 fragment 库"></a>v4 fragment 库</h4><p>添加对使用片段封装用户界面和功能的支持，从而使应用能够提供可以在大屏幕设备与小屏幕设备之间进行调节的布局。此模块依赖于 compat、core-utils、core-ui 和 media-compat。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-fragment:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="Dalvik-可执行文件分包支持库"><a href="#Dalvik-可执行文件分包支持库" class="headerlink" title="Dalvik 可执行文件分包支持库"></a>Dalvik 可执行文件分包支持库</h4><p>此库可以为使用多个 Dalvik Executable (DEX) 文件开发应用提供支持。引用超过 65536 个方法的应用须使用 Dalvik 可执行文件分包配置。如需了解有关使用 Dalvik 可执行文件分包的详细信息，请参阅使用超过 6.4 万种方法开发应用。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:multidex:1.0.0</span><br></pre></td></tr></table></figure></p><h3 id="v7-支持库"><a href="#v7-支持库" class="headerlink" title="v7 支持库"></a>v7 支持库</h3><p>一些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。这些库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。</p><h4 id="v7-appcompat-库"><a href="#v7-appcompat-库" class="headerlink" title="v7 appcompat 库"></a>v7 appcompat 库</h4><p>此库添加了对操作栏用户界面设计模式的支持。此库包含对 Material Design 用户界面实现的支持。</p><blockquote><p>注：此库依赖于 v4 支持库。</p></blockquote><p>下面是 v7 appcompat 库中包含的一些关键类：</p><ul><li>ActionBar - 提供操作栏用户界面模式的实现。如需了解有关使用操作栏的详细信息，请参阅操作栏开发者指南。</li><li>AppCompatActivity - 添加一个应用 Activity 类，此类可作为使用支持库操作栏实现的 Activity 的基础类。</li><li>AppCompatDialog - 添加一个对话框类，此类可作为 AppCompat 主题对话框的基础类。</li><li>ShareActionProvider - 包含对可以添加到操作栏中的标准化分享操作（例如电子邮件或发帖至社交应用）的支持。<br>此库的 Gradle 构建脚本依赖关系标识符如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:appcompat-v7:24.2.0</span><br></pre></td></tr></table></figure></li></ul><h4 id="v7-cardview-库"><a href="#v7-cardview-库" class="headerlink" title="v7 cardview 库"></a>v7 cardview 库</h4><p>此库添加了对 CardView 小部件的支持，让您能够在卡片内显示信息，从而使应用具备一致的外观。这些卡片对 Material Design 实现非常有用，并在电视应用布局中广为使用。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:cardview-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v7-gridlayout-库"><a href="#v7-gridlayout-库" class="headerlink" title="v7 gridlayout 库"></a>v7 gridlayout 库</h4><p>下载 Android 支持库后，此库可以添加对 GridLayout 类的支持，让您能够使用网状方格安排用户界面元素。如需了解有关 v7 gridlayout 库 API 的详细信息，请参阅 API 参考中的 android.support.v7.widget 软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:gridlayout-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v7-mediarouter-库"><a href="#v7-mediarouter-库" class="headerlink" title="v7 mediarouter 库"></a>v7 mediarouter 库</h4><p>此库可以提供 MediaRouter、MediaRouteProvider 和支持 Google Cast 的相关媒体类。</p><p>一般而言，利用 v7 mediarouter 库中的 API，您可以控制当前设备到外部屏幕、扬声器和其他目标设备的媒体渠道和流的路由。此库包含的 API 可以用于发布应用特定的媒体路由提供程序、发现和选择目标设备，以及检查媒体状态，等等。如需了解有关 v7 mediarouter 库 API 的详细信息，请参阅 API 参考中的 android.support.v7.media 软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:mediarouter-v7:24.2.0</span><br></pre></td></tr></table></figure></p><blockquote><p>支持库 r18 中引入的 v7 mediarouter 库 API 在后续版本的支持库中可能会发生更改。目前，我们建议仅使用与 Google Cast 有关的库。</p></blockquote><h4 id="v7-palette-库"><a href="#v7-palette-库" class="headerlink" title="v7 palette 库"></a>v7 palette 库</h4><p>v7 palette 支持库包含 Palette 类，此类让您可以从图像中抽取突出颜色。例如，音乐应用可以使用 Palette 对象从专辑封面抽取主要颜色，然后使用这些颜色创建一个色彩协调的歌曲标题卡。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:palette-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v7-recyclerview-库"><a href="#v7-recyclerview-库" class="headerlink" title="v7 recyclerview 库"></a>v7 recyclerview 库</h4><p>recyclerview 库添加了 RecyclerView 类。此类能够为 RecyclerView 小部件提供支持，RecyclerView 是一种通过提供有限的数据项窗口有效显示大数据集的视图。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:recyclerview-v7:24.2.0</span><br></pre></td></tr></table></figure></p><p>####v7 Preference 支持库<br>首选项软件包提供的 API 支持添加 preference 对象（例如 CheckBoxPreference 和 ListPreference），方便用户修改 UI 设置。</p><p>v7 Preference 库添加了对接口（例如 Preference.OnPreferenceChangeListener 和 Preference.OnPreferenceClickListener）以及类（例如 CheckBoxPreference 和 ListPreference）的支持。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:preference-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="v8-支持库"><a href="#v8-支持库" class="headerlink" title="v8 支持库"></a>v8 支持库</h3><p>此库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。此库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。</p><h4 id="v8-renderscript-库"><a href="#v8-renderscript-库" class="headerlink" title="v8 renderscript 库"></a>v8 renderscript 库</h4><p>此库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。它添加了对 RenderScript 计算框架的支持。android.support.v8.renderscript 软件包中包含这些 API。请注意，在应用中添加这些 API 的步骤与添加其他支持库 API 迥然不同。如需了解有关在应用中使用这些 API 的详细信息，请参阅 RenderScript 开发者指南。</p><blockquote><p>注：Android Studio 和 Gradle 构建支持使用带支持库的 RenderScript。renderscript 库位于 build-tools/$VERSION/renderscript/ 文件夹中。</p></blockquote><p>以下示例显示了此库的 Gradle 构建脚本属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    renderscriptTargetApi 18</span><br><span class="line">    renderscriptSupportModeEnabled true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="v13-支持库"><a href="#v13-支持库" class="headerlink" title="v13 支持库"></a>v13 支持库</h3><p>此库旨在用于 Android 3.2（API 级别 13）及更高版本。它添加了对带有 (FragmentCompat) 类和其他片段支持类的 Fragment 用户界面模式的支持。如需了解有关片段的详细信息，请参阅片段开发者指南。如需了解有关 v13 支持库 API 的详细信息，请参阅 API 参考中的 android.support.v13 软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-v13:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="v14-Preference-支持库"><a href="#v14-Preference-支持库" class="headerlink" title="v14 Preference 支持库"></a>v14 Preference 支持库</h3><p>android.support.v14.preference 软件包提供的 API 添加了对首选项接口（例如 PreferenceFragment.OnPreferenceStartFragmentCallback 和 PreferenceFragment.OnPreferenceStartScreenCallback）以及类（例如 MultiSelectListPreference 和 PreferenceFragment）的支持。如需了解有关 v14 Preference 支持库 API 的详细信息，请参阅 API 参考中的首选项软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:preference-v14:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="适用于电视的-v17-Preference-支持库"><a href="#适用于电视的-v17-Preference-支持库" class="headerlink" title="适用于电视的 v17 Preference 支持库"></a>适用于电视的 v17 Preference 支持库</h3><p>android.support.v17.preference 软件包提供的 API 可以在电视设备上提供首选项接口，包括对 LeanbackListPreferenceDialogFragment.ViewHolder.OnItemClickListener 接口和类的支持，例如 BaseLeanbackPreferenceFragment 和 LeanbackPreferenceFragment。如需了解有关 v17 Preference 支持库 API 的详细信息，请参阅 API 参考中的首选项软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:preference-leanback-v17:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v17-Leanback-库"><a href="#v17-Leanback-库" class="headerlink" title="v17 Leanback 库"></a>v17 Leanback 库</h4><p>android.support.v17.leanback 软件包提供的 API 支持在电视设备上构建用户界面。它为电视应用提供了一些重要的小部件。一些值得注意的类包括：</p><ul><li>BrowseFragment - 一种用于创建主要布局的片段，主要布局用于浏览类别和媒体项目。</li><li>DetailsFragment - 用于 Leanback 细节屏幕的包装器片段。</li><li>PlaybackOverlayFragment - 用于显示播放控件及相关内容的 DetailsFragment 子类。</li><li>SearchFragment - 用于处理搜索的片段。片段可以接收用户的搜索请求并将其传递给应用提供的 SearchResultProvider。SearchResultProvider 可以将搜索结果返回给 SearchFragment，后者会将结果渲染到 RowsFragment 中。</li></ul><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:leanback-v17:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="注解支持库"><a href="#注解支持库" class="headerlink" title="注解支持库"></a>注解支持库</h3><p>注解软件包提供的 API 支持向应用中添加注解元数据。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-annotations:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="设计支持库"><a href="#设计支持库" class="headerlink" title="设计支持库"></a>设计支持库</h3><p>设计软件包提供的 API 支持向应用中添加 Material Design 组件和模式。</p><p>设计支持库添加了对应用开发者依赖的各种 Material Design 组件和模式的支持，例如抽屉式导航栏、浮动操作按钮 (FAB)、快捷信息栏和标签页。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:design:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="自定义标签页支持库"><a href="#自定义标签页支持库" class="headerlink" title="自定义标签页支持库"></a>自定义标签页支持库</h3><p>自定义标签页软件包提供的 API 支持向应用中添加自定义标签页并对其进行管理。</p><p>自定义标签页支持库添加了对自定义标签页服务和自定义标签页回调等各种类的支持。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:customtabs:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="百分比支持库"><a href="#百分比支持库" class="headerlink" title="百分比支持库"></a>百分比支持库</h3><p>百分比软件包提供的 API 支持向应用中添加基于百分比的尺寸并对其进行管理。</p><p>百分比支持库添加了对 PercentLayoutHelper.PercentLayoutParams 接口和各种类的支持，例如 PercentFrameLayout 和 PercentRelativeLayout。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:percent:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="适用于电视的应用建议支持库"><a href="#适用于电视的应用建议支持库" class="headerlink" title="适用于电视的应用建议支持库"></a>适用于电视的应用建议支持库</h3><p>应用建议软件包提供的 API 支持向电视设备上运行的应用中添加内容建议。</p><p>应用库添加了对注解（例如 ContentRecommendation.ContentMaturity 和各种类（例如 ContentRecommendation 和 RecommendationExtender）的支持。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:recommendation:24.2.0</span><br></pre></td></tr></table></figure></p><p>看完上面的介绍，是不是对 Google 这些 Support 库 有了更全面的了解以及各版本之间的区别。如果希望就分享出去让更多的人知道吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;Android 支持库软件有多个库，每个库均支持特定范围的 Android 平台版本和功能。像大家比较熟悉的 v4 、v7、 v13、v14 等。下面将分别介绍下各个库版本所兼容或带来的功能有哪些？&lt;/p&gt;
&lt;h3 id=&quot;v4-支持库&quot;&gt;&lt;a href=&quot;#v4-支持库&quot; class=&quot;headerlink&quot; title=&quot;v4 支持库&quot;&gt;&lt;/a&gt;v4 支持库&lt;/h3&gt;&lt;p&gt;v4库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。与其他支持库相比，它们包含的 API 集合最大，包括对应用组件、用户界面功能、辅助功能、数据处理、网络连接以及编程实用工具的支持。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在支持库修订版 24.2.0 之前，存在一个 v4 支持库。为了提高效率，此库拆分成多个模块。出于向后兼容的考虑，如果您在 Gradle 脚本中列出了 support-v4，您的 APK 将包含所有的 v4 模块。不过，要减少 APK 大小，我们建议仅列出应用需要的特定模块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;v4-compat-库&quot;&gt;&lt;a href=&quot;#v4-compat-库&quot; class=&quot;headerlink&quot; title=&quot;v4 compat 库&quot;&gt;&lt;/a&gt;v4 compat 库&lt;/h4&gt;&lt;p&gt;此为众多框架 API 提供兼容性包装器，例如 Context.obtainDrawable() 和 View.performAccessibilityAction()&lt;/p&gt;
&lt;p&gt;此库的 Gradle 构建脚本依赖关系标识符如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;com.android.support:support-compat:24.2.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;v4-core-utils-库&quot;&gt;&lt;a href=&quot;#v4-core-utils-库&quot; class=&quot;headerlink&quot; title=&quot;v4 core-utils 库&quot;&gt;&lt;/a&gt;v4 core-utils 库&lt;/h4&gt;&lt;p&gt;提供大量实用程序类，例如 AsyncTaskLoader 和 PermissionChecker。&lt;/p&gt;
&lt;p&gt;此库的 Gradle 构建脚本依赖关系标识符如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;com.android.support:support-core-utils:24.2.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【推荐】开发人员必备的强兵利器</title>
    <link href="http://www.wxtlife.com/2017/09/27/developers-need-tools/"/>
    <id>http://www.wxtlife.com/2017/09/27/developers-need-tools/</id>
    <published>2017-09-27T11:47:59.000Z</published>
    <updated>2018-03-16T15:49:44.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>熟话说“工欲善其事，必先利其器”，那么今天整理了些目前开发常用的一些软件或者插件，分享给大家，主要都是提高效率，便于开发的工具，希望能够对你的工作，学习有所帮助。</p><p>那么本篇文章将推荐5个插件类工具和5个软件类工具。分别介绍如下：</p><h3 id="插件类"><a href="#插件类" class="headerlink" title="插件类"></a>插件类</h3><h4 id="1-gliffy-Diagrams"><a href="#1-gliffy-Diagrams" class="headerlink" title="1. gliffy Diagrams"></a>1. gliffy Diagrams</h4><p>gliffy Diagrams一个轻量级Chrome 插件，简单易用，可以用它进行各种图形的绘制，比如：流程化，类图等，而且可以直接导入visio的文件进行二次编辑，绘制完成后，可以直接与google 云盘连接，便于保存和同步，当然其也有很多的主题与模板可供选择，绘制这些图，是开发理清思路的第一步。<br>界面如下：<br><img src="/img/tools/gliffy.jpeg" alt="gliffy"></p><h4 id="2-Momentum"><a href="#2-Momentum" class="headerlink" title="2.Momentum"></a>2.Momentum</h4><p>Momentum 可以给Chrome浏览器每天更换新标签页，让你每天可以看到漂亮的美图，除了美图风景，还有很多附加小功能，比如，天气，todolist，时间，今日任务，搜索等，可以给你的浏览器焕然一新。<br>一起来感受下美观的界面：<br><img src="/img/tools/motion.jpeg" alt="motion"></p><a id="more"></a><h4 id="3-Postman"><a href="#3-Postman" class="headerlink" title="3. Postman"></a>3. Postman</h4><p>Postman 是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。当开发人员需要调试相应后台接口时，可以把各种模拟用户HTTP请求的数据发送到服务器，以便开发人员能够及时地作出正确的响应，或者是对产品发布之前的错误信息提前处理，进而保证产品上线之后的稳定性和安全性。值得推荐的一个插件。<br>界面如下：<br><img src="/img/tools/postman.jpeg" alt="postman"></p><h4 id="4-Octotree"><a href="#4-Octotree" class="headerlink" title="4. Octotree"></a>4. Octotree</h4><p>Octotree 是一款可以在github上浏览代码，可以向本地一样方便便捷，简化各种目录间跳转的复杂，对在github阅读源码体验有很大的提升。<br>界面如下：<br><img src="/img/tools/tree.jpeg" alt="octotree"></p><h4 id="5-OneTab"><a href="#5-OneTab" class="headerlink" title="5. OneTab"></a>5. OneTab</h4><p>OneTab 是一款可以帮助用户一键杀死谷歌浏览器中所有标签页并通过提示恢复部分有用标签页的Chrome插件。当我们有很多的页面暂时不需要浏览了，但后续还需要的话，就可以使用OneTab进行保存，这样不仅可以保存浏览的网页，还可以省很多浏览器内存。<br>界面如下：<br><img src="/img/tools/onetable.jpeg" alt="onetable"></p><h3 id="软件类"><a href="#软件类" class="headerlink" title="软件类"></a>软件类</h3><h4 id="1-Charlas"><a href="#1-Charlas" class="headerlink" title="1. Charlas"></a>1. Charlas</h4><p>Charlas 是一个HTTP代理服务器,HTTP监视器,反转代理服务器，当连接Charles的代理访问互联网时，Charles可以监控浏览器发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括request, response和HTTP headers （包含cookies与caching信息）。<br><img src="/img/tools/charlets.jpeg" alt="charlets"></p><h4 id="2-Markman"><a href="#2-Markman" class="headerlink" title="2. Markman"></a>2. Markman</h4><p>Markman 是一个高效的设计稿标注、测量工具。这个工具主要是设计师使用，但偶尔开发也可以用下看下设计稿的标注等信息。主要功能，长度标记，坐标和矩形标记，颜色值标记，文字的标记说明。<br><img src="/img/tools/markman.jpeg" alt="markman"></p><h4 id="3-SourceTree"><a href="#3-SourceTree" class="headerlink" title="3. SourceTree"></a>3. SourceTree</h4><p>SourceTree 是一个简化了与Git存储库进行交互，从而可以专注于编码。通过Sourcetree的简单Git GUI可视化和管理您的存储库。可以与Github仓库绑定，点击某个提交，可以看到所有相关的修改信息。对开发者来说很是方便。<br><img src="/img/tools/sourcetree.jpeg" alt="sourcetree"></p><h4 id="4-1Password"><a href="#4-1Password" class="headerlink" title="4. 1Password"></a>4. 1Password</h4><p>1Password是管理网站登录和敏感信息的最好应用，它拥有友好的用户界面，可以在任何时刻在任何设备上使用，包括笔记本电脑、手机等。支持浏览器，可以在浏览器上不用输入账号密码实现登录功能，但是需要保存好主密码，不然其他密码都会泄露了。目前手机端的应用是免费的，PC端的需要收费。<br><img src="/img/tools/1password.jpeg" alt="1password"></p><h4 id="5-ohMyStar2-仅有mac端"><a href="#5-ohMyStar2-仅有mac端" class="headerlink" title="5. ohMyStar2  (仅有mac端)"></a>5. ohMyStar2  (仅有mac端)</h4><p>OhMyStar2 可以无缝同步你在Github star的所有repo，在本地浏览、搜索这些stared repo，还能根据语言自动分组（自动侦测你加星的repo所使用的语言，菜单栏-Tool-Group with languages），而且你能手动对所有repo进行group，可以按照日，周，月，发现流行的github仓库。所有数据都能通过iCloud进行备份/还原。<br><img src="/img/tools/ohmystart.jpeg" alt="onmystar2"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望上面10款工具可以给你带来工作上的便捷和帮助，如果喜欢，就把他分享出去吧，让更多人知道有这么多好的工具可提高我们的效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;熟话说“工欲善其事，必先利其器”，那么今天整理了些目前开发常用的一些软件或者插件，分享给大家，主要都是提高效率，便于开发的工具，希望能够对你的工作，学习有所帮助。&lt;/p&gt;
&lt;p&gt;那么本篇文章将推荐5个插件类工具和5个软件类工具。分别介绍如下：&lt;/p&gt;
&lt;h3 id=&quot;插件类&quot;&gt;&lt;a href=&quot;#插件类&quot; class=&quot;headerlink&quot; title=&quot;插件类&quot;&gt;&lt;/a&gt;插件类&lt;/h3&gt;&lt;h4 id=&quot;1-gliffy-Diagrams&quot;&gt;&lt;a href=&quot;#1-gliffy-Diagrams&quot; class=&quot;headerlink&quot; title=&quot;1. gliffy Diagrams&quot;&gt;&lt;/a&gt;1. gliffy Diagrams&lt;/h4&gt;&lt;p&gt;gliffy Diagrams一个轻量级Chrome 插件，简单易用，可以用它进行各种图形的绘制，比如：流程化，类图等，而且可以直接导入visio的文件进行二次编辑，绘制完成后，可以直接与google 云盘连接，便于保存和同步，当然其也有很多的主题与模板可供选择，绘制这些图，是开发理清思路的第一步。&lt;br&gt;界面如下：&lt;br&gt;&lt;img src=&quot;/img/tools/gliffy.jpeg&quot; alt=&quot;gliffy&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-Momentum&quot;&gt;&lt;a href=&quot;#2-Momentum&quot; class=&quot;headerlink&quot; title=&quot;2.Momentum&quot;&gt;&lt;/a&gt;2.Momentum&lt;/h4&gt;&lt;p&gt;Momentum 可以给Chrome浏览器每天更换新标签页，让你每天可以看到漂亮的美图，除了美图风景，还有很多附加小功能，比如，天气，todolist，时间，今日任务，搜索等，可以给你的浏览器焕然一新。&lt;br&gt;一起来感受下美观的界面：&lt;br&gt;&lt;img src=&quot;/img/tools/motion.jpeg&quot; alt=&quot;motion&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.wxtlife.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>十分钟理清常见的开源协议</title>
    <link href="http://www.wxtlife.com/2017/09/18/License-different/"/>
    <id>http://www.wxtlife.com/2017/09/18/License-different/</id>
    <published>2017-09-18T15:45:30.000Z</published>
    <updated>2018-03-16T15:49:44.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>从上次和大家聊了下 <a href="http://www.wxtlife.com/2017/09/10/00-ceo-fun-things/">00后CEO的那些趣事</a>，谈到了开源协议相关的内容，那么本篇文章，就主要介绍下大家在工作生活中常用到的开原协议。常见的协议如下：ApacheLicense 2.0 、GPLv3 、LGPL、、MIT License、BSD 和 Mozilla 2.0  。那么我们下面就分别介绍下这些协议的说明、允许项及禁止项。</p><h3 id="Apache-License-2-0"><a href="#Apache-License-2-0" class="headerlink" title="Apache License 2.0"></a>Apache License 2.0</h3><p>这是一个著名的非盈利开源组织Apache采用的协议，它励代码共享和尊重原作者的著作权，同时也允许代码修改，再发布（作为开源或商业软件）。</p><ul><li>要求</li></ul><ol><li>在代码中保留作者提供的协议和版权信息</li><li>如果修改了代码，则必须在被修改的文件中进行说明。</li></ol><ul><li><p>允许的权利<br>商用、分发、修改、专利授权、私用、附加协议</p></li><li><p>禁止项</p></li></ul><ol><li>禁止因使用等造成影响责任承担、也就是说免责申明</li><li>不能使用相应的商标。</li></ol><p><strong>提示：商业软件可以使用，也可以修改使用Apache协议的代码。</strong></p><h3 id="GPLv3"><a href="#GPLv3" class="headerlink" title="GPLv3"></a>GPLv3</h3><p>此协议是应用最为广泛的开源协议，拥有较强的版权自由要求,也赋予和保证了开源项目开发者广泛的权利。基本上，它允许用户合法复制，分发和修改软件，但衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，不同变种的要求略有不同。</p><a id="more"></a><ul><li>要求</li></ul><ol><li>修改后的源码也需要公开</li><li>版权及协议也要于此协议一致</li><li>修改后，需要在相应的文件做说明，</li></ol><ul><li><p>允许<br>商用，分发，修改，专利授权，私用</p></li><li><p>禁止</p></li></ul><ol><li>禁止因使用等造成影响责任承担、也就是说免责申明</li><li>静止在软件分发传播过程中附加上原来没有的协议条款等</li></ol><p><strong>提示：商业软件不能使用GPL协议的代码。</strong></p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>其主要用于一些代码库，LGPL比起GPL它授予的权限较少，LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。因此使用LGPL协议的开源代码可以被商业软件作为<strong>类库引用</strong>并发布和销售。注意是以类库的形式使用，也就是说如果修改了源代码的话则也必须使用LGPL协议贡献源码出来。</p><ul><li>要求</li></ul><ol><li>公开使用了LGPL部分的代码，其余部分不需要公开。</li><li>可以库引用的方式用于商业软件。</li><li>在代码中保留作者提供的协议和版权信息</li></ol><ul><li><p>允许<br>商用、分发、修改、专利授权、私用、附加协议</p></li><li><p>禁止<br>禁止承担责任，(免责申明)、</p></li></ul><p><strong>提示：商业软件可以使用，但不能修改LGPL协议的代码。</strong></p><p><strong>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品</strong></p><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>宽松简单且精要的一个协议。在适当标明来源及免责的情况下，它允许你对代码进行任何形式的使用,也就是原作者只想保留版权,而无任何其他了限制,而你必须在发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。</p><ul><li><p>要求<br>在代码中保留作者提供的协议和版权信息</p></li><li><p>允许<br>商用、分发、修改、私用、附加协议</p></li><li><p>禁止<br>禁止承担责任，(免责申明)</p></li></ul><p><strong>提示：商业软件可以使用，也可以修改MIT协议的代码，甚至可以出售MIT协议的代码。</strong></p><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。与MIT协议只存在细微差异。差别为MIT可以使用原名称进行宣传，而BSD不可以。</p><ul><li><p>要求<br>在代码中保留作者提供的协议和版权信息</p></li><li><p>允许<br>商用、分发、修改、私用、附加协议</p></li><li><p>禁止<br>禁止承担责任，(免责申明)</p></li></ul><p><strong>提示：商业软件可以使用，也可以修改使用BSD协议的代码。</strong></p><h3 id="Mozilla-2-0"><a href="#Mozilla-2-0" class="headerlink" title="Mozilla 2.0"></a>Mozilla 2.0</h3><p>是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点，允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者。这种授权维护了商业软件的利益，它要求基于这种软件得修改无偿贡献版权给该软件。</p><ul><li>要求</li></ul><ol><li>公开源代码</li><li>在代码中保留作者提供的协议和版权信息</li></ol><ul><li><p>允许<br>商用、分发、修改、专利授权、私用、附加协议</p></li><li><p>禁止</p></li></ul><ol><li>禁止承担责任，(免责申明)</li><li>禁止使用商标</li></ol><p><strong>提示：商业软件可以使用，也可以修改MPL协议的代码，但修改后的代码版权归软件的发起者。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是我们常见的开源协议的一些区别，后面三种协议的区别较小，需要特别注意。如果觉得上面不好记，那么久收藏本文吧，在需要的时候进行查看复习，或者提供下面网址供大家进行查看。<br><a href="http://choosealicense.online/appendix/" target="_blank" rel="noopener">http://choosealicense.online/appendix/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;从上次和大家聊了下 &lt;a href=&quot;http://www.wxtlife.com/2017/09/10/00-ceo-fun-things/&quot;&gt;00后CEO的那些趣事&lt;/a&gt;，谈到了开源协议相关的内容，那么本篇文章，就主要介绍下大家在工作生活中常用到的开原协议。常见的协议如下：ApacheLicense 2.0 、GPLv3 、LGPL、、MIT License、BSD 和 Mozilla 2.0  。那么我们下面就分别介绍下这些协议的说明、允许项及禁止项。&lt;/p&gt;
&lt;h3 id=&quot;Apache-License-2-0&quot;&gt;&lt;a href=&quot;#Apache-License-2-0&quot; class=&quot;headerlink&quot; title=&quot;Apache License 2.0&quot;&gt;&lt;/a&gt;Apache License 2.0&lt;/h3&gt;&lt;p&gt;这是一个著名的非盈利开源组织Apache采用的协议，它励代码共享和尊重原作者的著作权，同时也允许代码修改，再发布（作为开源或商业软件）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;在代码中保留作者提供的协议和版权信息&lt;/li&gt;
&lt;li&gt;如果修改了代码，则必须在被修改的文件中进行说明。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;允许的权利&lt;br&gt;商用、分发、修改、专利授权、私用、附加协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;禁止项&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;禁止因使用等造成影响责任承担、也就是说免责申明&lt;/li&gt;
&lt;li&gt;不能使用相应的商标。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;提示：商业软件可以使用，也可以修改使用Apache协议的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;GPLv3&quot;&gt;&lt;a href=&quot;#GPLv3&quot; class=&quot;headerlink&quot; title=&quot;GPLv3&quot;&gt;&lt;/a&gt;GPLv3&lt;/h3&gt;&lt;p&gt;此协议是应用最为广泛的开源协议，拥有较强的版权自由要求,也赋予和保证了开源项目开发者广泛的权利。基本上，它允许用户合法复制，分发和修改软件，但衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，不同变种的要求略有不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="License" scheme="http://www.wxtlife.com/tags/License/"/>
    
  </entry>
  
  <entry>
    <title>00后CEO引起的那些趣事</title>
    <link href="http://www.wxtlife.com/2017/09/10/00-ceo-fun-things/"/>
    <id>http://www.wxtlife.com/2017/09/10/00-ceo-fun-things/</id>
    <published>2017-09-10T15:24:08.000Z</published>
    <updated>2018-03-16T15:49:44.447Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>今天要来说点有趣的事情了，事情的大致起因呢是这样的，在前几天播出的一档节目中采访了<code>崇才网络科技</code>公司的CEO,然而这家CEO不简单，竟然是00后，这下子让还在为生活打拼的80及90后，开始不安了，在网络上引起极大的关注，再加上雷军转发了那位天才CEO的微博表示对00后CEO的祝贺和肯定。如下：</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/4/86a1ded6a7b86a0c393c49c827fabef0" alt=""></p><p>熟话说树大招风，不久的几天后，首位 00 后 CEO 遭“打脸”被指抄袭开源作品，被网名ID为<code>墨镜猫</code>发现其抄袭其在<code>github</code>上的开源作品。还被指责其抄袭都不够格，简直就是赤裸裸的复制粘贴，就连里面的图片素材都没有更换。这位墨镜猫的个人网址如下:<a href="http://www.jackywang.tech/" target="_blank" rel="noopener">http://www.jackywang.tech/</a> 其在主页上发表了一篇文章为<a href="http://www.jackywang.tech/2017/09/05/%E4%B8%AD%E5%9B%BD%E9%A6%96%E4%BD%8D00%E5%90%8ECEO%E5%85%AC%E7%84%B6%E6%8A%84%E8%A2%AD%E3%80%81%E5%A4%8D%E5%88%B6%E6%88%91%E7%9A%84%E5%BC%80%E6%BA%90%E4%BD%9C%E5%93%81/" target="_blank" rel="noopener">中国首位00后CEO公然抄袭、复制我的开源作品</a>。</p><a id="more"></a><p>侵权的画面截图：<br><img src="https://user-gold-cdn.xitu.io/2017/9/4/519632499c052e8dfd7defb9d5bf6c61" alt="侵权截图"></p><p>原作者的软件界面：<br><img src="https://user-gold-cdn.xitu.io/2017/9/4/ab4550b558c0fb7eb4091bc39e59e47b" alt="原作者"></p><p>程序员应该都知道在开源软件一般都是有开源协议的，有很多的类型，可以保护自己的知识产权，那说到这里，我们就直接找到<code>墨镜猫</code> 在github上开源的项目去看看到底使用的是什么开原协议呢，其github开源项目地址如下:<a href="https://github.com/JackyAndroid/AndroidTVLauncher" target="_blank" rel="noopener">https://github.com/JackyAndroid/AndroidTVLauncher</a></p><p>进到项目看到如下图的信息：<br><img src="/img/ceo/project.png" alt="项目主页"></p><p>初步看到开源协议是GPL3.0，这个协议是很少有商业公司使用的，因为使用者需要将修改后的代码也需要开源并且使用同样的协议， 看到这里真为这位00后CEO捏了一把汗，毕竟公司使用后，要想不维权，是需要开源修改后的代码的，这对商业公司是个不小的伤害，假装心痛一秒钟。</p><p>接着再仔细看看上图圆圈的部分，发现最近3天有修改，于是好奇的打开 提交历史页面，看到如下信息：<br><img src="/img/ceo/all-commit.png" alt="项目主页"></p><p>从commit用语很犀利，作者应该很生气，好奇心害死猫，于是从最开始的commit的开始看修改记录，然后看到下面的时候，震惊了，修改记录如下：</p><p><img src="/img/ceo/modify-lisence.png" alt="项目主页"></p><p>看到作者将原来的<code>Apache License 2.0</code>协议改为<code>GNU GPLv3</code>的协议了，这剧情反转的有点措手不及。然后顺便再看下后面的评论。也是挺有意思的。</p><p><img src="/img/ceo/pinglun1.png" alt="项目主页"></p><p>这位网友也是看热闹不怕事情大，不停的嘲讽说是太迟啦，来不及啦。。。</p><p><img src="/img/ceo/pinglun2.png" alt="项目主页"></p><p>这位程序员则认为在中国版权意识没有那么强，不管你啥协议都有人照抄，只是没出名，没被发现而已，版权都是大公司间的把戏。。想想似乎也是这么个理。。我竟无言以对。</p><p><img src="/img/ceo/pinglun3.png" alt="项目主页"></p><p>这位网友则比较同情作者，在帮助他从<code>Apache License 2.0</code>中找到可以维权的证据。然而这就需要看侵权者是否真的有这方面的维权喽。</p><p><img src="/img/ceo/pinglun4.png" alt="项目主页"></p><p>这位程序员也是使出了独门武器来告诉作者，现在修改协议似乎很容易被发现，有一种伪造修改记录时间的方法，使用<code>git filter-branch</code>来进行神操作，具体使用方法如下：<a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2#核弹级选项:-filter-branch" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2#核弹级选项:-filter-branch</a></p><p>看到这里似乎有些懂了，没有完全了解开源协议而随便使用的问题应该是比较普遍的，所以对于各种开源协议，以及知识共享协议等，都需要弄清它们的权利要求以及限制等，这样才能用的安心，那么后面就会说说，开源协议中常用协议的权利要求及限制等等，敬请期待！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;今天要来说点有趣的事情了，事情的大致起因呢是这样的，在前几天播出的一档节目中采访了&lt;code&gt;崇才网络科技&lt;/code&gt;公司的CEO,然而这家CEO不简单，竟然是00后，这下子让还在为生活打拼的80及90后，开始不安了，在网络上引起极大的关注，再加上雷军转发了那位天才CEO的微博表示对00后CEO的祝贺和肯定。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/9/4/86a1ded6a7b86a0c393c49c827fabef0&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;熟话说树大招风，不久的几天后，首位 00 后 CEO 遭“打脸”被指抄袭开源作品，被网名ID为&lt;code&gt;墨镜猫&lt;/code&gt;发现其抄袭其在&lt;code&gt;github&lt;/code&gt;上的开源作品。还被指责其抄袭都不够格，简直就是赤裸裸的复制粘贴，就连里面的图片素材都没有更换。这位墨镜猫的个人网址如下:&lt;a href=&quot;http://www.jackywang.tech/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jackywang.tech/&lt;/a&gt; 其在主页上发表了一篇文章为&lt;a href=&quot;http://www.jackywang.tech/2017/09/05/%E4%B8%AD%E5%9B%BD%E9%A6%96%E4%BD%8D00%E5%90%8ECEO%E5%85%AC%E7%84%B6%E6%8A%84%E8%A2%AD%E3%80%81%E5%A4%8D%E5%88%B6%E6%88%91%E7%9A%84%E5%BC%80%E6%BA%90%E4%BD%9C%E5%93%81/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中国首位00后CEO公然抄袭、复制我的开源作品&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="趣事" scheme="http://www.wxtlife.com/tags/%E8%B6%A3%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin开发基础（一）</title>
    <link href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/"/>
    <id>http://www.wxtlife.com/2017/09/08/kotlin-share-1/</id>
    <published>2017-09-08T15:17:40.000Z</published>
    <updated>2018-03-16T15:49:44.452Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><ul><li><strong><a href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/">Kotlin开发基础（一）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/">Kotlin开发基础（二）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/">Kotlin开发基础（三）</a></strong></li></ul><h3 id="为什么学习kotlin"><a href="#为什么学习kotlin" class="headerlink" title="为什么学习kotlin"></a>为什么学习kotlin</h3><p>kotlin在今年的Google IO 上正式被确认为Android的官方开发语言，想必原因大家也能猜到一二，一是Google与oracle关于Java相关的版权相关的问题，二是kotlin语言很简洁，不罗嗦，支持很多的新特性。</p><p>由于Google都已经官方支持了，语法简洁高效，和IOS的 swift 很是相似，发展趋势不可小觑，还有个大新闻就是我们的大神 <a href="https://github.com/JakeWharton" target="_blank" rel="noopener">Jake Wharton</a> 从square 辞职加入了Google，且其在最近的github中国fork了kotlin 仓库，想必是为kotlin在Android的发展做贡献，就从这可以断定kotlin的未来不会太差， 当然作为技术人就需要不断的学习，不段的挑战。如果想在Android上继续深造kotlin肯定是要学习的。</p><h3 id="怎么学习"><a href="#怎么学习" class="headerlink" title="怎么学习"></a>怎么学习</h3><p>我的想法是，大家都是学过基本的语言的，比如C，C++，做Android的肯定学过Java，所以我的想法是对照Java的基础与kotlin基础做对比着学习， 这样印象会深刻点，差异化学习。</p><h3 id="Kotlin基础"><a href="#Kotlin基础" class="headerlink" title="Kotlin基础"></a>Kotlin基础</h3><h4 id="Kotlin-数据类型"><a href="#Kotlin-数据类型" class="headerlink" title="Kotlin 数据类型"></a>Kotlin 数据类型</h4><p>在kotlin语言中，所有的类型都是都是对象，kotlin中没有了基础数据类型（int，boolean，char，byte）等。全部换为对象类型。类型如下：<br><code>Int</code>,<code>Boolean</code>,<code>String</code>,<code>Byte</code>,<code>Float</code>,<code>Char</code>,<code>Double</code>,<code>Short</code>，这些没有了Java中隐式拓宽转换，例如不能把Int类型直接赋值给Long类型了，如要要这样做这些书类型可以调用如下方法进行转换：</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">toByte():   <span class="built_in">Byte</span></span><br><span class="line">toShort():  <span class="built_in">Short</span></span><br><span class="line">toInt():    <span class="built_in">Int</span></span><br><span class="line">toLong():   <span class="built_in">Long</span></span><br><span class="line">toFloat():  <span class="built_in">Float</span></span><br><span class="line">toDouble(): <span class="built_in">Double</span></span><br><span class="line">toChar():   <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><p>kotlin 中各数字类型所占位数如下：</p><table><thead><tr><th>Type</th><th>bit</th></tr></thead><tbody><tr><td>Double</td><td>64</td></tr><tr><td>Long</td><td>64</td></tr><tr><td>Float</td><td>32</td></tr><tr><td>Int</td><td>32</td></tr><tr><td>Short</td><td>16</td></tr><tr><td>Byte</td><td>8</td></tr></tbody></table><p>数值常量和Java中基本无区别，十进制：123，十六进制：0x1F。</p><p>主要是以下几种字面值常量： </p><ul><li>十进制数值: 123</li><li>长整型要加大写 L : 123L</li><li>16进制：0x0f</li><li>二进制：0b00001011</li><li>默认双精度浮点数(Double) : 123.5 , 123.5e10</li><li>单精度浮点数(Float)要添加 f 或 F ：123.5f</li></ul><p><strong>注意: kotlin不支持八进制</strong></p><p><strong>黑魔法：</strong> 在我们写Int或者Long类型数据时，常常一写一长串，不便于识别，现在kotlin支持在数字常量中可以添加<code>_</code>了，便于阅读，不影响数据类型和值，例如电话号码可以这样写了。<code>val phone : Long = 186_****_0814</code>便于我们阅读。不得不说kotlin语言的灵活性。</p><p><strong>kotlin中不会在末尾写分号啦！！！！！</strong></p><h4 id="与-的区别"><a href="#与-的区别" class="headerlink" title="== 与 ===的区别"></a>== 与 ===的区别</h4><p>在kotlin中多了一种判断符<code>===</code>三个等号，这个特点呢就是判断两个对象是否指向同一个对象，也就是引用相等，而<code>==</code>则表示的数据的结构相等，也就是调用<code>equals</code>方法的返回值。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a : Int = 3 </span><br><span class="line">println(a===a)  // true </span><br><span class="line">var b : Int  = a</span><br><span class="line">var c : Int = a</span><br><span class="line">println(b===c) // false 因为指向的对象不是同一个</span><br><span class="line">println(b==c)  // true</span><br></pre></td></tr></table></figure></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串有两种表达方式，一种是可以带转义符的，另外一种是可以包含任意字符的。例如下面有转义的<code>val s = &quot;hello world \n&quot;</code> ，但如果真正的字符串就是上面带有转义字符<code>\n</code>的，那么要怎么表示呢，kotlin中使用三引号 <code>&quot;&quot;&quot;</code>来表示，例如：<code>val s = &quot;&quot;&quot;hello world \n&quot;&quot;&quot;</code> 这样<code>\n</code>就不会被转义为回车，而是原封原样的字符串了。</p><p>字符串还有了很好的模板特性，会极大的方便字符串拼接，操作等。下面就直接看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val a = 1</span><br><span class="line">var str : String = &quot;this num is $a&quot;</span><br><span class="line">a = 2</span><br><span class="line">val s2 = &quot;$&#123;str.replace(&quot;is&quot;, &quot;was&quot;)&#125;, but now is $a&quot;</span><br></pre></td></tr></table></figure></p><p>可以看到这极大的方便字符串的操作，使用$即可直接取到变量的值，如果在字符串中操作则使用表达式<code>${}</code>直接对字符串进行操作。</p><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><p>控制流基本与java中常用的保持一致，有<code>for</code>,<code>while</code>,但<code>switch</code>在kotlin中换为<code>when</code>，学过其他语言的应该都能很容易的掌握。</p><h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p>for循环使用 in 关键字进行遍历，普通的如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val array = 1..100</span><br><span class="line">for (value in array) &#123;</span><br><span class="line">    print(&quot;value = $value&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于之前for循环的步长使用<code>step</code>来表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1..100 step 2) &#123;</span><br><span class="line">    print(&quot;i = $i&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 1..100  表示是闭区间 ，[1,100]</span><br></pre></td></tr></table></figure></p><p>为了表示开闭区间，可以使用<code>until</code> 来表示。如下:<code>1 until 100</code> 表示 [1,100)</p><p>倒序的话将<code>..</code>替换为<code>downTo</code></p><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p><code>while</code> 循环与java 一样，不在多说，以及<code>do while</code></p><h5 id="when"><a href="#when" class="headerlink" title="when"></a>when</h5><p>when 的功能与java switch 功能类似，但是其便捷性不仅仅能case 一些基本数据类型，它可以支持表达式，这样会更加的灵活便捷。下面看个例子吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun describe(obj: Any): String =</span><br><span class="line">    when (obj) &#123;</span><br><span class="line">        1,&apos;1&apos; -&gt; &quot;One&quot;</span><br><span class="line">        &quot;Hello&quot;,&quot;Good&quot; -&gt; &quot;Greeting&quot;</span><br><span class="line">        is Long -&gt; &quot;Long&quot;</span><br><span class="line">        !is String -&gt; &quot;Not a string&quot;</span><br><span class="line">        else -&gt; &quot;Unknown&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到上面的是不是很灵活? 可以对不同的类型在同一个分支中进行判断，极大的提高了灵活性。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul><li>数组：</li></ul><p>在Kotlin中使用<code>Array</code>来表示数组，它本身定义了<code>set</code>,<code>get</code>,<code>size</code>等属性，可以使用<code>arrayOf</code>来创建数组，例如：<code>var test = arrayof(1,2,3)</code>,数组中的数据类型可以是任何类型，但是使用时需要注意类型，访问可以用<code>get(index)</code> 或者<code>[index]</code>来访问，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (ar in array) &#123;</span><br><span class="line">    print(&quot;array value = $ar&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i in array.indices) &#123;</span><br><span class="line">    print(&quot;array value = $array[i]&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>List</li></ul><p>list的创建也很简便，使用<code>listOf</code>创建，使用<code>val list = listOf(1,2,3,&quot;string&quot;)</code>, 当然遍历也提供了多种方式，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (it in list) &#123;</span><br><span class="line">    print(&quot;list value = $it&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 带下标，以及值的遍历方式</span><br><span class="line">for ((index,value) in list.withIndex()) &#123;</span><br><span class="line">    print(&quot;index = $index value = $value &quot; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Map</li></ul><p>map的创建<code>val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)</code>,访问也是很简单，比java中访问简单太多，方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ((key, value) in map) &#123;</span><br><span class="line">    print(&quot;key = $key  value = $value&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到上面常见集合的类型套路都是一样使用<code>类型Of()</code>来创建，访问遍历也是很方便。</p><h4 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h4><p>在kotlin是空类型安全的，所以如果要给一个变量赋值为null，则必须在其定义后面加上？,否则无法编译器会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str : String ? = null </span><br><span class="line">var  size =  str.length   //此时会编译报错，提示可能为空</span><br></pre></td></tr></table></figure></p><p>那么怎么获取呢，在kotlin中提供两种方法来访问，第一种为<code>?.</code>的访问形式，此种表示如果为空则不执行，非空再继续，则上面则可以写成这样<code>val size = str?.length</code>,第二种就是可能在执行前给变量赋值了，我们肯定它不为空，那么可以用<code>!!.</code>来获取，如下：<code>val size = str!!.length</code>,当然第二种你必须为运行时控制住做好心理准备。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在Java中变量有普通的变量，静态常量（<code>final</code>），静态编量(<code>static</code>)，但在kotlin中没有<code>static</code>关键字了，需要使用静态变量有另外的一种表示，后续在将这部分，那在kotlin中的变量的表示方式为<code>var</code>,常量的表达方式为<code>val</code>, 具体表达方式如下： </p><p><code>val a :Float = 1f</code>, <code>val a = &quot;Aaron&quot;, var c :Int = 2, c += 2</code><br>kotlin中定义的类型是放在变量后面的，且类型有时可省略。</p><p><code>var a : Int = 2</code>, <code>var a = 2</code> 这两个表达的是一样的，后面的表达式会进行自动类型推倒。</p><p>kotlin是空类型安全的，所以在赋值时也有些差别，如果想要空类型的则在赋值后面需要加<code>？</code>，</p><h4 id="延迟属性"><a href="#延迟属性" class="headerlink" title="延迟属性"></a>延迟属性</h4><p>延迟属性或者延初始化可以帮助我们在需要用到时在初始化，不需要时不初始化，帮助程序节省内存空间及启动速度。</p><p>在kotlin中使用<code>lazy</code>关键字来表示。直接看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val answer by lazy &#123;</span><br><span class="line">    println(&quot;Calculating the answer...&quot;)</span><br><span class="line">    42</span><br><span class="line">&#125;</span><br><span class="line">if (needAnswer()) &#123; // 返回随机值</span><br><span class="line">    println(&quot;The answer is $answer.&quot;) // 此时计算出答案</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    println(&quot;Sometimes no answer is the answer...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有执行到上面needAnswer()为true时，answer才会被初始化。<br>想想是不是我们写的很多初始化的代码，都可以用lazy来延迟初始化了。</p><ul><li>注意<code>by lazy</code>所赋值的变量必须为<code>val</code>类型</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数在kotlin中使用 <code>fun</code> 来表示，函数参数与定义变量一样放在变量后面，参数的类型不可省略，返回值也是在放在参数括号后面，当没有返回值的时候使用<code>Unit</code>代替 java中的<code>void</code>关键字，当然<code>Unit</code>也是可以省略的。下面我们看几个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">// 等同于下面语句，简称函数式表达式</span><br><span class="line">fun sum(a:Int, b:Int) = a + b</span><br><span class="line"></span><br><span class="line">val sum = &#123;x:Int ,y:Int -&gt; x + y&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是一个简单的函数，有参数又返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun printSum(a: Int, b: Int): Unit &#123;</span><br><span class="line">  println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 等同于下面</span><br><span class="line">fun printSum(a: Int, b: Int) &#123;</span><br><span class="line">  println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面则为没有返回值，其可以将函数后面的<code>Unit</code>省略掉。</p><h5 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h5><p>在java中我们如果对同一个方法名，但是有不同的参数个数，需要写多个方法出来，看起来很臃肿，对于少参数的来说，可能就是某个参数为固定或者默认值，那么在kotlin中有了默认参数的表示方式。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a :Int , b : Int = 3) : Int &#123;</span><br><span class="line">    return a +b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用 sum(1,2) // 代表 1 + 2 </span><br><span class="line">//调用 sum (2)  // 代表2 + 3</span><br></pre></td></tr></table></figure></p><h5 id="函数具名参数"><a href="#函数具名参数" class="headerlink" title="函数具名参数"></a>函数具名参数</h5><p>具名参数是对上面的一种特殊情况的考虑，比如我们将上面的代码改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a :Int = 3, b : Int) : Int &#123;</span><br><span class="line">    return a +b</span><br><span class="line">&#125;</span><br><span class="line">//调用 sum (2)   此时对于此调用，编译器认为2 是为a赋值，而b没有赋值，无法编译通过。那么要调用则采用具名参数来指明参数。</span><br><span class="line">// 改为 sum(b = 2) 这样既可指定将2赋值给b，则a使用默认的值。</span><br></pre></td></tr></table></figure></p><h5 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h5><p>在Android可能很常见的是有一个Utils包，专门放置一些常用的公共方法，比如String，Toast，File 操作等等，然而现在kotlin可以直接对系统类，进行扩展。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun Context.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) &#123;</span><br><span class="line">    Toast.makeText(this, message, duration).show()</span><br><span class="line">&#125;</span><br><span class="line">//在Activity，Context实例中就可以直接调用了。</span><br><span class="line">toast(&quot;我是Toast&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面讲述了kotlin 很基础的知识，讲解了些kotlin的特性，当然还有很多的特性，以及在Android上开发的便捷性等等，本篇就先说这么多，下一篇将会说到kotlin更多的特性，比如：自定义类的getter和setter 方法，inline 函数，高阶函数，数据类，单例类等。敬请期待！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/09/08/kotlin-share-1/&quot;&gt;Kotlin开发基础（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/12/kotlin-share-2/&quot;&gt;Kotlin开发基础（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/17/kotlin-share-3/&quot;&gt;Kotlin开发基础（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;为什么学习kotlin&quot;&gt;&lt;a href=&quot;#为什么学习kotlin&quot; class=&quot;headerlink&quot; title=&quot;为什么学习kotlin&quot;&gt;&lt;/a&gt;为什么学习kotlin&lt;/h3&gt;&lt;p&gt;kotlin在今年的Google IO 上正式被确认为Android的官方开发语言，想必原因大家也能猜到一二，一是Google与oracle关于Java相关的版权相关的问题，二是kotlin语言很简洁，不罗嗦，支持很多的新特性。&lt;/p&gt;
&lt;p&gt;由于Google都已经官方支持了，语法简洁高效，和IOS的 swift 很是相似，发展趋势不可小觑，还有个大新闻就是我们的大神 &lt;a href=&quot;https://github.com/JakeWharton&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jake Wharton&lt;/a&gt; 从square 辞职加入了Google，且其在最近的github中国fork了kotlin 仓库，想必是为kotlin在Android的发展做贡献，就从这可以断定kotlin的未来不会太差， 当然作为技术人就需要不断的学习，不段的挑战。如果想在Android上继续深造kotlin肯定是要学习的。&lt;/p&gt;
&lt;h3 id=&quot;怎么学习&quot;&gt;&lt;a href=&quot;#怎么学习&quot; class=&quot;headerlink&quot; title=&quot;怎么学习&quot;&gt;&lt;/a&gt;怎么学习&lt;/h3&gt;&lt;p&gt;我的想法是，大家都是学过基本的语言的，比如C，C++，做Android的肯定学过Java，所以我的想法是对照Java的基础与kotlin基础做对比着学习， 这样印象会深刻点，差异化学习。&lt;/p&gt;
&lt;h3 id=&quot;Kotlin基础&quot;&gt;&lt;a href=&quot;#Kotlin基础&quot; class=&quot;headerlink&quot; title=&quot;Kotlin基础&quot;&gt;&lt;/a&gt;Kotlin基础&lt;/h3&gt;&lt;h4 id=&quot;Kotlin-数据类型&quot;&gt;&lt;a href=&quot;#Kotlin-数据类型&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 数据类型&quot;&gt;&lt;/a&gt;Kotlin 数据类型&lt;/h4&gt;&lt;p&gt;在kotlin语言中，所有的类型都是都是对象，kotlin中没有了基础数据类型（int，boolean，char，byte）等。全部换为对象类型。类型如下：&lt;br&gt;&lt;code&gt;Int&lt;/code&gt;,&lt;code&gt;Boolean&lt;/code&gt;,&lt;code&gt;String&lt;/code&gt;,&lt;code&gt;Byte&lt;/code&gt;,&lt;code&gt;Float&lt;/code&gt;,&lt;code&gt;Char&lt;/code&gt;,&lt;code&gt;Double&lt;/code&gt;,&lt;code&gt;Short&lt;/code&gt;，这些没有了Java中隐式拓宽转换，例如不能把Int类型直接赋值给Long类型了，如要要这样做这些书类型可以调用如下方法进行转换：&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.wxtlife.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android adb 开发常用命令</title>
    <link href="http://www.wxtlife.com/2017/09/07/Android-adb-commond/"/>
    <id>http://www.wxtlife.com/2017/09/07/Android-adb-commond/</id>
    <published>2017-09-07T00:44:04.000Z</published>
    <updated>2018-03-16T15:49:44.447Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>adb 在开发中调试是很常用的命令，下面就来说说常用的adb命令。</p><h3 id="简化adb-连接命令"><a href="#简化adb-连接命令" class="headerlink" title="简化adb 连接命令"></a>简化adb 连接命令</h3><p>如果指定ip 连接，一般为 <code>adb conenct 172.18.xxx.xxx</code>,这样每次进行连接时，发现都有重复的的命令需要敲，程序员就是要减少重复工作，所以现在就将重复的命令省掉。（以下为mac下的配置的方法）:</p><ul><li>新建.alias_bash 文件</li><li><p>文件中使用<code>alias</code>别名关键字重新命令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias ac=&quot;adb connect $1&quot; </span><br><span class="line">alias ad=&quot;adb disconnect $1&quot;</span><br><span class="line">alias ak=&quot;adb kill-server&quot;</span><br><span class="line">alias as=&quot;adb start-server&quot;</span><br></pre></td></tr></table></figure></li><li><p>修改根目录下的<code>.bash_profile</code> , 或者其他以<code>.bash</code>的文件中，将最后加上<code>source ./.alias_bash</code> 然后重新执行<code>source ./.bash_profile</code>，或者直接关掉终端，重新打开一个。</p></li><li>尝试使用<code>ac 172.18.**.**</code>,则可直接连接上机器，在输入 <code>ad</code>即可看到adb连接到的设备。</li></ul><p>上面只是个例子，可以在文件<code>.alias_bash</code>文件中添加其他的简化命令。<br><a id="more"></a></p><h3 id="adb-多设备指定连接"><a href="#adb-多设备指定连接" class="headerlink" title="adb 多设备指定连接"></a>adb 多设备指定连接</h3><p>在使用adb连接多个设备，当想连接到某一个设备的shell时<code>adb -s 172.18.xx.xx:5555 shell</code> 。<br>如果是其他命令一样可以指定设备执行。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb -s 172.18.xx.xx:5555 install *.apk</span><br></pre></td></tr></table></figure></p><h3 id="adb-文件处理"><a href="#adb-文件处理" class="headerlink" title="adb 文件处理"></a>adb 文件处理</h3><h4 id="复制电脑里的文件到设备"><a href="#复制电脑里的文件到设备" class="headerlink" title="复制电脑里的文件到设备"></a>复制电脑里的文件到设备</h4><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push &lt;电脑上的文件路径&gt; &lt;设备里的目录&gt;</span><br></pre></td></tr></table></figure></p><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb push ~/sr.mp4 /sdcard/</span><br></pre></td></tr></table></figure></p><h4 id="复制设备里的文件到电脑"><a href="#复制设备里的文件到电脑" class="headerlink" title="复制设备里的文件到电脑"></a>复制设备里的文件到电脑</h4><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull &lt;设备里的文件路径&gt; [电脑上的目录]</span><br></pre></td></tr></table></figure></p><ul><li>其中 电脑上的目录 参数可以省略，默认复制到当前目录。</li></ul><p>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sdcard/sr.mp4 ~/tmp/</span><br></pre></td></tr></table></figure></p><h3 id="adb-安装卸载应用"><a href="#adb-安装卸载应用" class="headerlink" title="adb 安装卸载应用"></a>adb 安装卸载应用</h3><h4 id="adb-安装应用"><a href="#adb-安装应用" class="headerlink" title="adb 安装应用"></a>adb 安装应用</h4><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb install [-lrtsdg] &lt;path_to_apk&gt;</span><br></pre></td></tr></table></figure></p><p>参数：<br>adb install 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-l</td><td>将应用安装到保护目录 /mnt/asec</td></tr><tr><td>-r</td><td>允许覆盖安装</td></tr><tr><td>-t</td><td>允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=”true” 的应用</td></tr><tr><td>-s</td><td>将应用安装到 sdcard</td></tr><tr><td>-d</td><td>允许降级覆盖安装</td></tr><tr><td>-g</td><td>授予所有运行时权限</td></tr></tbody></table><p>运行命令后如果见到类似如下输出（状态为 Success）代表安装成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[100%] /data/local/tmp/1.apk</span><br><span class="line">pkg: /data/local/tmp/1.apk</span><br><span class="line">Success</span><br></pre></td></tr></table></figure></p><h4 id="adb-卸载应用"><a href="#adb-卸载应用" class="headerlink" title="adb 卸载应用"></a>adb 卸载应用</h4><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall [-k] &lt;packagename&gt;</span><br></pre></td></tr></table></figure></p><ul><li><packagename> 表示应用的包名，-k参数可选，表示卸载应用但保留数据和缓存目录。</packagename></li></ul><p>命令示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb uninstall com.aaron.test</span><br></pre></td></tr></table></figure></p><h3 id="adb-启动应用"><a href="#adb-启动应用" class="headerlink" title="adb 启动应用"></a>adb 启动应用</h3><h4 id="启动activity"><a href="#启动activity" class="headerlink" title="启动activity"></a>启动activity</h4><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n com.aaron.test/.LauncherActivity</span><br></pre></td></tr></table></figure></p><p>如果想要对启动的Intent添加参数可以按照key-value形式添加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am start -n org.mazhuang.boottimemeasure/.MainActivity --es &quot;url&quot; &quot;wxtlife.com&quot;</span><br></pre></td></tr></table></figure><h4 id="启动servies"><a href="#启动servies" class="headerlink" title="启动servies"></a>启动servies</h4><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am startservice [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure></p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am startservice -n com.aaron.test/.MusicService</span><br></pre></td></tr></table></figure></p><p>表示调起音乐服务Service。</p><h4 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h4><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast [options] &lt;INTENT&gt;</span><br></pre></td></tr></table></figure></p><p>可以向所有组件广播，也可以只向指定组件广播。</p><p>例如，向所有组件广播 BOOT_COMPLETED：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</span><br></pre></td></tr></table></figure></p><p>向指定的接收器发送广播，例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a com.aaron.action.SHOW_TIME -n com.aaron.test/.PlaySerices</span><br></pre></td></tr></table></figure></p><p>如果带参数的广播则在后面加上参数的key, value 。 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am broadcast -a com.aaron.action.SHOW_TIME -es &quot;url&quot; &quot;wxtlife.com&quot;</span><br></pre></td></tr></table></figure></p><h3 id="adb-杀进程"><a href="#adb-杀进程" class="headerlink" title="adb 杀进程"></a>adb 杀进程</h3><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am force-stop &lt;packagename&gt;</span><br></pre></td></tr></table></figure></p><p>命令示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell am force-stop com.aaron.test</span><br></pre></td></tr></table></figure></p><h3 id="adb-清除应用缓存等"><a href="#adb-清除应用缓存等" class="headerlink" title="adb 清除应用缓存等"></a>adb 清除应用缓存等</h3><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm clear &lt;packagename&gt;</span><br></pre></td></tr></table></figure></p><ul><li><packagename> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</packagename></li></ul><p>命令示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm clear com.aaron.test</span><br></pre></td></tr></table></figure></p><h3 id="adb-模拟事件"><a href="#adb-模拟事件" class="headerlink" title="adb 模拟事件"></a>adb 模拟事件</h3><p>命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent &lt;keycode&gt;</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell input keyevent 26  //模拟电源键</span><br></pre></td></tr></table></figure></p><h3 id="adb-查看日志"><a href="#adb-查看日志" class="headerlink" title="adb 查看日志"></a>adb 查看日志</h3><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[adb] logcat [&lt;option&gt;] ... [&lt;filter-spec&gt;] ...</span><br></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat *:W</span><br></pre></td></tr></table></figure></p><p>Android 的日志分为如下几个优先级（priority）：</p><ul><li>V —— Verbose（最低，输出得最多）</li><li>D —— Debug</li><li>I —— Info</li><li>W —— Warning</li><li>E —— Error</li><li>F —— Fatal</li><li>S —— Silent（最高，啥也不输出）</li></ul><p>过滤指定TAG<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb logcat -s &lt;TAG&gt;</span><br></pre></td></tr></table></figure></p><h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><h4 id="查看应用列表信息"><a href="#查看应用列表信息" class="headerlink" title="查看应用列表信息"></a>查看应用列表信息</h4><p>查看应用列表的基本命令格式是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]</span><br></pre></td></tr></table></figure></p><ul><li>即在 adb shell pm list packages 的基础上可以加一些参数进行过滤查看不同的列表，支持的过滤参数如下：</li></ul><table><thead><tr><th>参数</th><th>显示列表</th></tr></thead><tbody><tr><td>无</td><td>所有应用</td></tr><tr><td>-f</td><td>显示应用关联的 apk 文件</td></tr><tr><td>-d</td><td>只显示 disabled 的应用</td></tr><tr><td>-e</td><td>只显示 enabled 的应用</td></tr><tr><td>-s</td><td>只显示系统应用</td></tr><tr><td>-3</td><td>只显示第三方应用</td></tr><tr><td>-i</td><td>显示应用的 installer</td></tr><tr><td>-u</td><td>包含已卸载应用</td></tr><tr><td>FILTER</td><td>包名包含 FILTER 字符串</td></tr></tbody></table><p>例如：</p><ul><li><p>第三方应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm list packages -s</span><br></pre></td></tr></table></figure></li><li><p>包名包含某字符串的应用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages -3</span><br></pre></td></tr></table></figure></li><li><p>查看包名包含字符串aaron的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell pm list packages aaron</span><br></pre></td></tr></table></figure></li></ul><h4 id="查看前台-Activity"><a href="#查看前台-Activity" class="headerlink" title="查看前台 Activity"></a>查看前台 Activity</h4><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity activities | grep mFocusedActivity</span><br></pre></td></tr></table></figure></p><h4 id="查看正在运行的Services"><a href="#查看正在运行的Services" class="headerlink" title="查看正在运行的Services"></a>查看正在运行的Services</h4><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys activity services [&lt;packagename&gt;]</span><br></pre></td></tr></table></figure></p><ul><li><packagename> 参数不是必须的，指定 <packagename> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。</packagename></packagename></li></ul><h4 id="查看CPU信息"><a href="#查看CPU信息" class="headerlink" title="查看CPU信息"></a>查看CPU信息</h4><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/cpuinfo</span><br></pre></td></tr></table></figure></p><h4 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h4><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/meminfo</span><br></pre></td></tr></table></figure></p><ul><li>其中，MemTotal 就是设备的总内存，MemFree 是当前空闲内存。</li></ul><h4 id="查看占用cpu占用排行"><a href="#查看占用cpu占用排行" class="headerlink" title="查看占用cpu占用排行"></a>查看占用cpu占用排行</h4><p>命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell busybox top</span><br></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>adb 的使用还有很多的命令，这里不一一列举了。更多的可以查看adb 命令的帮助信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;adb 在开发中调试是很常用的命令，下面就来说说常用的adb命令。&lt;/p&gt;
&lt;h3 id=&quot;简化adb-连接命令&quot;&gt;&lt;a href=&quot;#简化adb-连接命令&quot; class=&quot;headerlink&quot; title=&quot;简化adb 连接命令&quot;&gt;&lt;/a&gt;简化adb 连接命令&lt;/h3&gt;&lt;p&gt;如果指定ip 连接，一般为 &lt;code&gt;adb conenct 172.18.xxx.xxx&lt;/code&gt;,这样每次进行连接时，发现都有重复的的命令需要敲，程序员就是要减少重复工作，所以现在就将重复的命令省掉。（以下为mac下的配置的方法）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建.alias_bash 文件&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件中使用&lt;code&gt;alias&lt;/code&gt;别名关键字重新命令 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;alias ac=&amp;quot;adb connect $1&amp;quot; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias ad=&amp;quot;adb disconnect $1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias ak=&amp;quot;adb kill-server&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alias as=&amp;quot;adb start-server&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改根目录下的&lt;code&gt;.bash_profile&lt;/code&gt; , 或者其他以&lt;code&gt;.bash&lt;/code&gt;的文件中，将最后加上&lt;code&gt;source ./.alias_bash&lt;/code&gt; 然后重新执行&lt;code&gt;source ./.bash_profile&lt;/code&gt;，或者直接关掉终端，重新打开一个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;尝试使用&lt;code&gt;ac 172.18.**.**&lt;/code&gt;,则可直接连接上机器，在输入 &lt;code&gt;ad&lt;/code&gt;即可看到adb连接到的设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面只是个例子，可以在文件&lt;code&gt;.alias_bash&lt;/code&gt;文件中添加其他的简化命令。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="adb" scheme="http://www.wxtlife.com/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>Android Framebuffer介绍及使用</title>
    <link href="http://www.wxtlife.com/2017/06/07/Android-framebuffer/"/>
    <id>http://www.wxtlife.com/2017/06/07/Android-framebuffer/</id>
    <published>2017-06-07T14:57:35.000Z</published>
    <updated>2018-03-16T15:49:44.448Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h2 id="FrameBuffer-介绍"><a href="#FrameBuffer-介绍" class="headerlink" title="FrameBuffer 介绍"></a>FrameBuffer 介绍</h2><p>FrameBuffer中文译名为帧缓冲驱动，它是出现在2.2.xx内核中的一种驱动程序接口。主设备号为29，次设备号递增。<br>Linux抽象出FrameBuffer这个设备来供用户态进程实现直接写屏。<code>FrameBuffer机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过FrameBuffer的读写直接对显存进行操作。用户可以将FrameBuffer看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。</code>这种操作是抽象的，统一的。用户不必关心物理显存的位置、换页机制等等具体细节，这些都是由FrameBuffer设备驱动来完成的。<br>FrameBuffer实际上就是嵌入式系统中专门为GPU所保留的一块连续的物理内存，LCD通过专门的总线从framebuffer读取数据，显示到屏幕上。<br>FrameBuffer本质上是一块显示缓存，往显示缓存中写入特定格式的数据就意味着向屏幕输出内容。所以说FrameBuffer就是一块白板。</p><p><strong>屏幕位置从上到下，从左至右与内存地址是顺序的线性关系</strong><br><a id="more"></a></p><h2 id="FrameBuffer-使用"><a href="#FrameBuffer-使用" class="headerlink" title="FrameBuffer 使用"></a>FrameBuffer 使用</h2><p>framebuffer的设备文件在Linux下一般是 <code>/dev/fb0</code>、<code>/dev/fb1</code> 等，但在Android下面一般为<code>/dev/graphics/fb0</code>,<code>/dev/graphics/fb1</code>等<br><strong>注意：</strong> 系统中至少要存在一个显示屏，因此，名称为“fb0”的设备是肯定会存在的，否则的话，就是出错了。</p><h3 id="操作framebuffer的主要步骤"><a href="#操作framebuffer的主要步骤" class="headerlink" title="操作framebuffer的主要步骤"></a>操作framebuffer的主要步骤</h3><h4 id="1、打开可用的FrameBuffer设备；"><a href="#1、打开可用的FrameBuffer设备；" class="headerlink" title="1、打开可用的FrameBuffer设备；"></a>1、打开可用的FrameBuffer设备；</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fbfd = open(&quot;/dev/graphics/fb0&quot;, O_RDWR);</span><br></pre></td></tr></table></figure><p><code>O_RDWR</code>是已可读写的方式打开文件  </p><h4 id="2、计算映射大小"><a href="#2、计算映射大小" class="headerlink" title="2、计算映射大小"></a>2、计算映射大小</h4><p>用ioctrl操作取得当前显示屏幕的参数，如屏幕分辨率，每个像素点的比特数。根据屏幕参数可计算屏幕缓冲区的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ioctl(fbfd, FBIOGET_FSCREENINFO, &amp;finfo); // fb_fix_screeninfo 通过fbfd获取屏幕固定的相关信息</span><br><span class="line">ioctl(fbfd, FBIOGET_VSCREENINFO, &amp;vinfo); // fb_var_screeninfo 通过fbfd获取可变的信息，可以调用参数为`FBIOPUT_VSCREENINFO`的重新进行设置</span><br></pre></td></tr></table></figure></p><p>从fb_var_screeninfo中可以获取xoffset ,yoffset的偏移量，以及屏幕可见行列像素点（xres，yres）,以及一个像素所占用的位数bits_per_pixel。<br>从fb_fix_screeninfo 中可以获取到framebuffer的内存空间大小finfo.smem_len，每行占用的字节数line_length等。</p><p>这些信息都是对我们下一步来计算需要映射多大的内存空间有很大的帮助，size 可以直接等于 finfo.smem_len, 或者 xres <em> yres </em> bits_per_pixel &gt;&gt; 3 </p><h4 id="3、通过mmap映射地址空间"><a href="#3、通过mmap映射地址空间" class="headerlink" title="3、通过mmap映射地址空间"></a>3、通过mmap映射地址空间</h4><p>通过mmap函数把显卡的物理内存空间映射到用户空间地址上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *fbp = (char *)mmap(start, size, PROT_READ | PROT_WRITE, MAP_SHARED,fbfd, offsize);</span><br></pre></td></tr></table></figure></p><p>各个参数的含义如下： </p><ul><li>start 指向欲映射的内存起始地址，通常设为 NULL，代表让系统自动选定地址，映射成功后返回该地址。  </li><li>size 代表将文件中多大的部分映射到内存。</li><li>PROT_READ | PROT_WRITE 为可读可写模式</li><li>MAP_SHARED 对映射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。   </li><li>fbfd 要映射到内存中的文件描述符,也就是open文件后的描述符。</li><li>offsize 文件映射的偏移量</li></ul><p>关于open、mmap的相关信息可以参考博客：<a href="http://www.wxtlife.com/2016/01/17/Android-memory-map/">http://www.wxtlife.com/2016/01/17/Android-memory-map/</a></p><h4 id="4、更改内存空间里的像素数据并显示；"><a href="#4、更改内存空间里的像素数据并显示；" class="headerlink" title="4、更改内存空间里的像素数据并显示；"></a>4、更改内存空间里的像素数据并显示；</h4><p>fbp则是映射framebuffer后的内存首地址，整个framebuffer的地址是线性的，与整个屏幕大小从左到右，从上到下映射的。所以操作framebuffer是按照每个像素去操作的，每个像素都需要计算他的偏移量也就是每个像素的内存地址空间.<br>例如在（x，y）位置写入颜色 pixel值。  </p><h5 id="4-1-首先先计算偏移量"><a href="#4-1-首先先计算偏移量" class="headerlink" title="4.1 首先先计算偏移量"></a>4.1 首先先计算偏移量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">offset = (x + y * screen_width) * 4; // (4个字节)</span><br></pre></td></tr></table></figure><p><strong>上面未考虑多buffer切换的地址空间的情况</strong></p><h5 id="4-2-给偏移量的内存地址赋值"><a href="#4-2-给偏移量的内存地址赋值" class="headerlink" title="4.2 给偏移量的内存地址赋值"></a>4.2 给偏移量的内存地址赋值</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*((uint32_t *)(fbp + offset)) = pixel;</span><br></pre></td></tr></table></figure><h4 id="5、退出时关闭framebuffer设备。"><a href="#5、退出时关闭framebuffer设备。" class="headerlink" title="5、退出时关闭framebuffer设备。"></a>5、退出时关闭framebuffer设备。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">munmap(fbp, size);  </span><br><span class="line">close(fbfd);</span><br></pre></td></tr></table></figure><p><strong>size需要与mmap时一样，会导致内存泄露问题。</strong><br>查看一个完整的示例demo ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">int main() &#123;</span><br><span class="line">int fbfd = 0;</span><br><span class="line">struct fb_var_screeninfo vinfo;</span><br><span class="line">struct fb_fix_screeninfo finfo;</span><br><span class="line">long int screensize = 0;</span><br><span class="line">char *fbp = 0;</span><br><span class="line">long int location = 0;</span><br><span class="line">// Open the file for reading and writing</span><br><span class="line">fbfd = open(&quot;/dev/graphics/fb0&quot;, O_RDWR);</span><br><span class="line">if (!fbfd) &#123;</span><br><span class="line">printf(&quot;Error: cannot open framebuffer device.\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;The framebuffer device was opened successfully.\n&quot;);</span><br><span class="line">// Get fixed screen information</span><br><span class="line">if (ioctl(fbfd, FBIOGET_FSCREENINFO, &amp;finfo)) &#123;</span><br><span class="line">printf(&quot;Error reading fixed information.\n&quot;);</span><br><span class="line">exit(2);</span><br><span class="line">&#125;</span><br><span class="line">// Get variable screen information</span><br><span class="line">if (ioctl(fbfd, FBIOGET_VSCREENINFO, &amp;vinfo)) &#123;</span><br><span class="line">printf(&quot;Error reading variable information.\n&quot;);</span><br><span class="line">exit(3);</span><br><span class="line">&#125;</span><br><span class="line">screensize =  finfo.smem_len;</span><br><span class="line">// screensize = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel &gt;&gt; 3  // &gt;&gt;3 表示算出字节数</span><br><span class="line">fbp = (char *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED,fbfd, 0);</span><br><span class="line"></span><br><span class="line">if ((int)fbp == -1) &#123;</span><br><span class="line">printf(&quot;Error: failed to map framebuffer device to memory.\n&quot;);</span><br><span class="line">exit(4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="FrameBuffer-相关结构"><a href="#FrameBuffer-相关结构" class="headerlink" title="FrameBuffer 相关结构"></a>FrameBuffer 相关结构</h3><p>FrameBuffer设备驱动基于如下两个文件：  </p><blockquote></blockquote><p>1) linux/include/linux/fb.h<br>2) linux/drivers/video/fbmem.c  </p><p>FrameBuffer 主要包含的结构有以下：fb_info ，fb_ops ，fb_var_screeninfo，fb_fix_screeninfo,上面的结构都定义在fb.h里。</p><h4 id="fb-var-screeninfo"><a href="#fb-var-screeninfo" class="headerlink" title="fb_var_screeninfo"></a>fb_var_screeninfo</h4><p>用于记录用户可修改的显示属性参数，包括屏幕分辨率、每个像素点的比特数等。<br>显卡的显示属性,用户可修改，此数据结构中，定义了偏移量（xoffset ,yoffset）、可见行列像素点（xres，yres）、每个像素所占bit位数（bits_per_pixel), 虚拟分辨率（xres_virtual、yres_virtual）在显存中包含的分辨率等信息，这些都是我们常见也是常用的到的。<br>这些数据我们是可以通过ioctl函数来获取，获取操作如下：<code>ioctl(fbfd, FBIOGET_FSCREENINFO, &amp;finfo)</code> 。也可以重新进行赋值，之后再将设置进系统：设置如下：<code>ioctl(fbfd, FBIOPUT_VSCREENINFO, &amp;finfo)</code></p><p>数据结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct fb_var_screeninfo &#123;  </span><br><span class="line">    __u32 xres;         /* 行可见像素*/  </span><br><span class="line">    __u32 yres;         /* 列可见像素*/  </span><br><span class="line">    __u32 xres_virtual; /* 行虚拟像素*/  </span><br><span class="line">    __u32 yres_virtual; /* 列虚拟像素*/  </span><br><span class="line">    __u32 xoffset;      /* 水平偏移量*/  </span><br><span class="line">    __u32 yoffset;      /* 垂直偏移量*/  </span><br><span class="line">    __u32 bits_per_pixel;/*每个像素所占bit位数*/  </span><br><span class="line">    __u32 grayscale;    /* 灰色刻度*/  </span><br><span class="line">    struct fb_bitfield red; /* bitfield in fb mem if true color, */  </span><br><span class="line">    struct fb_bitfield green;   /* else only length is significant */  </span><br><span class="line">    struct fb_bitfield blue;  </span><br><span class="line">    struct fb_bitfield transp;  /* transparency         */    </span><br><span class="line">    __u32 nonstd;           /* != 0 Non standard pixel format */  </span><br><span class="line">    __u32 activate;         /* see FB_ACTIVATE_*        */  </span><br><span class="line">    __u32 height;           /* 图像高度*/  </span><br><span class="line">    __u32 width;            /* 图像宽度*/  </span><br><span class="line">    __u32 accel_flags;      /* (OBSOLETE) see fb_info.flags */  </span><br><span class="line">    __u32 pixclock;         /* pixel clock in ps (pico seconds) */  </span><br><span class="line">    __u32 left_margin;      /* time from sync to picture    */  </span><br><span class="line">    __u32 right_margin;     /* time from picture to sync    */  </span><br><span class="line">    __u32 upper_margin;     /* time from sync to picture    */  </span><br><span class="line">    __u32 lower_margin;  </span><br><span class="line">    __u32 hsync_len;        /* length of horizontal sync    */  </span><br><span class="line">    __u32 vsync_len;        /* length of vertical sync  */  </span><br><span class="line">    __u32 sync;         /* see FB_SYNC_*        */  </span><br><span class="line">    __u32 vmode;            /* see FB_VMODE_*       */  </span><br><span class="line">    __u32 rotate;           /* angle we rotate counter clockwise */  </span><br><span class="line">    __u32 reserved[5];      /* Reserved for future compatibility */  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="fb-fix-screeninfo"><a href="#fb-fix-screeninfo" class="headerlink" title="fb_fix_screeninfo"></a>fb_fix_screeninfo</h4><p>这个结构在显卡被设定模式后创建，它描述显示卡的属性，并且系统运行时不能被修改；比如FrameBuffer内存的起始地址。它依赖于被设定的模式，当一个模式被设定后，内存信息由显示卡硬件给出，内存的位置等信息就不可以修改。<br>显卡的硬件属性, 用户不可修改, 驱动程序初始化时设置。比如可以获取内存空间大小，起始地址，每行占用的字节数line_length等等。</p><p>数据结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">struct fb_fix_screeninfo &#123;  </span><br><span class="line">    char id[16];            /* identification string eg &quot;TT Builtin&quot; */  </span><br><span class="line">    unsigned long smem_start;/* Start of frame buffer mem */  </span><br><span class="line">    __u32 smem_len;         /* Length of frame buffer mem */  </span><br><span class="line">    __u32 type;             /* see FB_TYPE_*        */  </span><br><span class="line">    __u32 type_aux;         /* Interleave for interleaved Planes */  </span><br><span class="line">    __u32 visual;           /* see FB_VISUAL_*      */   </span><br><span class="line">    __u16 xpanstep;         /* zero if no hardware panning  */  </span><br><span class="line">    __u16 ypanstep;         /* zero if no hardware panning  */  </span><br><span class="line">    __u16 ywrapstep;        /* zero if no hardware ywrap    */  </span><br><span class="line">    __u32 line_length;      /* length of a line in bytes    */  </span><br><span class="line">    unsigned long mmio_start;/* Start of Memory Mapped I/O   */  </span><br><span class="line">    __u32 mmio_len;         /* Length of Memory Mapped I/O  */  </span><br><span class="line">    __u32 accel;            /* Indicate to driver which */  </span><br><span class="line">    __u16 reserved[3];      /* Reserved for future compatibility */  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="fb-ops"><a href="#fb-ops" class="headerlink" title="fb_ops"></a>fb_ops</h4><p>是提供给底层设备驱动的一个接口，用户应用可以使用 ioctl() 系统调用来操作设备。</p><h4 id="fb-cmap"><a href="#fb-cmap" class="headerlink" title="fb_cmap"></a>fb_cmap</h4><p>描述设备无关的颜色映射信息。可以通过 FBIOGETCMAP 和 FBIOPUTCMAP 对应的 ioctl 操作设定或获取颜色映射信息。主要是颜色映射表，颜色相关一些映射信息。</p><h4 id="fb-info"><a href="#fb-info" class="headerlink" title="fb_info"></a>fb_info</h4><p>结构仅在内核中可见，在这个结构中有一个fb_ops指针，指向驱动设备工作所需的函数集，是Linux为帧缓冲设备定义的驱动层接口。它不仅包含了底层函数，而且还有记录设备状态的数据。每个帧缓冲设备都与一个fb_info结构相对应。</p><p>结构如下：<br><img src="http://images2015.cnblogs.com/blog/417887/201605/417887-20160512000159046-1661072189.jpg" alt="FrameBuffer结构图"></p><p><strong>ioctl中request参数：</strong></p><ul><li>FBIOGET_VSCREENINFO 表示用户获取屏幕的可变参数；</li><li>FBIOPUT_VSCREENINFO 表示用户设置可变的屏幕参数；</li><li>FBIOGET_FSCREENINFO 表示用户获得屏幕的固定参数；</li><li>FBIOBLANK表示调用sep4020fb_blank函数清空液晶屏；</li><li>FBIOPUTCMAP 表示设置屏幕的颜色表；</li><li>FBIOGETCMAP 表示获得颜色表。</li></ul><h2 id="双缓冲机制"><a href="#双缓冲机制" class="headerlink" title="双缓冲机制"></a>双缓冲机制</h2><p>Android 使用SurfaceFlinger作为屏幕合成引擎。它管理来自各个窗口的Surface objects，然后将其写入到framebuffer去。SurfaceFlinger使用前buffer来合成，后buffer来绘制。一旦绘制完成，Android通过页翻转操作，交换Y轴坐标的偏移量，选择不同buffer。在EGL显示服务初始化时，如果虚拟Y轴分辨率大于实际Y轴分辨率，说明framebuffer可以直接使用双缓冲。否则，后buffer要复制到前buffer，这样会导致页交换延迟。为了提高系统性能，Framebuffer驱动最好提供双缓冲机制。  </p><h3 id="双缓冲机制的原理"><a href="#双缓冲机制的原理" class="headerlink" title="双缓冲机制的原理"></a>双缓冲机制的原理</h3><p>所有画图操作将它们画图的结果保存在一块系统内存区域中，这块区域通常被称作“后缓冲区（backbuffer）”，当所有的绘图操作结束之后，系统通过换页机制将绘制区域指向先前的后缓冲区，然后进行绘制显示，而原来的绘制缓冲区就变为“后缓冲区”，之后按照这种情况不停循环切换。这个复制操作通常要跟显示器的光栈束同步，以避免撕裂。双缓冲机制必须要求有比单缓冲更多的显示内存和CPU消耗时间，因为“后缓冲区”需要显示内存，而复制操作和等待同步需要CPU时间。  </p><p><img src="http://hi.csdn.net/attachment/201107/14/0_1310644759mil1.gif" alt="FrameBuffer1"><br><img src="http://hi.csdn.net/attachment/201107/14/0_1310644815JN51.gif" alt="framebuffer2"> </p><p><strong>双缓冲是一种画图技术，使用这种技术可以使得画图没有（至少是减少）闪烁、撕裂等不良效果，并减少等待时间。</strong></p><h3 id="缓冲区切换步骤"><a href="#缓冲区切换步骤" class="headerlink" title="缓冲区切换步骤:"></a>缓冲区切换步骤:</h3><ol><li>把fb驱动的framebuffer通过mmap映射到应用空间的内存地址map_base，一般来说framebuffer size是2*framesize或者3*framesize 大小（和平台相关）  </li><li>把第一帧数据写入map_base  </li><li>调用FBIOPAN_DISPLAY显示  </li><li>把第二帧数据写入map_base+framesize处  </li><li>调用FBIOPAN_DISPLAY  </li><li>重复step2~step5  </li></ol><blockquote><p>FBIOPAN_DISPLAY  在linux的注释里是“平移显示”的意思,调用FBIOPAN_DISPLAY时，会传一个y坐标偏移量yoffset给驱动，然后驱动会把当前显存的指针偏移 “yoffset X 屏幕宽度 X 位色字节数” 个字节，这样就好像实现了图像的y坐标平移，也就是“平移显示”。当这个yoffset等于屏幕高度的时候，就实现了显存的切换。  </p></blockquote><p><strong>参考链接</strong> </p><p><a href="http://www.cnblogs.com/armlinux/archive/2012/02/25/2396760.html" target="_blank" rel="noopener">http://www.cnblogs.com/armlinux/archive/2012/02/25/2396760.html</a><br><a href="http://blog.csdn.net/yangwen123/article/details/12096483" target="_blank" rel="noopener">http://blog.csdn.net/yangwen123/article/details/12096483</a><br><a href="http://blog.csdn.net/louiswangbing/article/details/6606837" target="_blank" rel="noopener">http://blog.csdn.net/louiswangbing/article/details/6606837</a><br><a href="http://lib.csdn.net/article/android/4928" target="_blank" rel="noopener">http://lib.csdn.net/article/android/4928</a><br><a href="http://www.cnblogs.com/mfryf/archive/2013/05/22/3093912.html" target="_blank" rel="noopener">http://www.cnblogs.com/mfryf/archive/2013/05/22/3093912.html</a><br><a href="http://www.cnblogs.com/hzl6255/p/5476012.html" target="_blank" rel="noopener">http://www.cnblogs.com/mfryf/archive/2013/05/22/3093912.html</a><br><a href="http://blog.csdn.net/molibaobei90/article/details/40826791" target="_blank" rel="noopener">http://blog.csdn.net/molibaobei90/article/details/40826791</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;FrameBuffer-介绍&quot;&gt;&lt;a href=&quot;#FrameBuffer-介绍&quot; class=&quot;headerlink&quot; title=&quot;FrameBuffer 介绍&quot;&gt;&lt;/a&gt;FrameBuffer 介绍&lt;/h2&gt;&lt;p&gt;FrameBuffer中文译名为帧缓冲驱动，它是出现在2.2.xx内核中的一种驱动程序接口。主设备号为29，次设备号递增。&lt;br&gt;Linux抽象出FrameBuffer这个设备来供用户态进程实现直接写屏。&lt;code&gt;FrameBuffer机制模仿显卡的功能，将显卡硬件结构抽象掉，可以通过FrameBuffer的读写直接对显存进行操作。用户可以将FrameBuffer看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。&lt;/code&gt;这种操作是抽象的，统一的。用户不必关心物理显存的位置、换页机制等等具体细节，这些都是由FrameBuffer设备驱动来完成的。&lt;br&gt;FrameBuffer实际上就是嵌入式系统中专门为GPU所保留的一块连续的物理内存，LCD通过专门的总线从framebuffer读取数据，显示到屏幕上。&lt;br&gt;FrameBuffer本质上是一块显示缓存，往显示缓存中写入特定格式的数据就意味着向屏幕输出内容。所以说FrameBuffer就是一块白板。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;屏幕位置从上到下，从左至右与内存地址是顺序的线性关系&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="Framebuffer" scheme="http://www.wxtlife.com/tags/Framebuffer/"/>
    
  </entry>
  
  <entry>
    <title>Gradle 查看项目依赖情况</title>
    <link href="http://www.wxtlife.com/2017/04/16/check-gradle-dependency/"/>
    <id>http://www.wxtlife.com/2017/04/16/check-gradle-dependency/</id>
    <published>2017-04-16T06:06:53.000Z</published>
    <updated>2018-03-16T15:49:44.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h3 id="查看项目各个Library的依赖情况"><a href="#查看项目各个Library的依赖情况" class="headerlink" title="查看项目各个Library的依赖情况"></a>查看项目各个Library的依赖情况</h3><h4 id="通过引入第三方插件来实现"><a href="#通过引入第三方插件来实现" class="headerlink" title="通过引入第三方插件来实现"></a>通过引入第三方插件来实现</h4><ul><li>首先在应用app的下的build.gradle 文件上加上<code>apply plugin: &#39;project-report&#39;</code></li><li>然后在项目的根目录下执行gradle命令<code>./gradlew htmlDependencyReport</code> 之后会在Build目录下面生成report文件夹，里面生成的有html，里面会有compile的标签，打开即可看到相关的依赖包情况。</li></ul><p>此命令有助于查看依赖的版本，因为有的用的低版本，有的高版本，以及查看重复依赖的情况等等，里面还有其他很多的信息可以参考。</p><h4 id="AS自带的脚本实现查看依赖关系"><a href="#AS自带的脚本实现查看依赖关系" class="headerlink" title="AS自带的脚本实现查看依赖关系"></a>AS自带的脚本实现查看依赖关系</h4><p>在AS的右上方有个gradle的Project,点击后可以看到所有的moudle工程,选中所选工程后，在Tasks下的android，里面有个<code>androidDependencies</code>,右键后选择第一个<code>run...</code> ，等待执行完毕后，在“run”和“Messages”控制台下面就会列出此moudle所依赖的相关信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队
      
    
    </summary>
    
    
      <category term="Gradle" scheme="http://www.wxtlife.com/tags/Gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio 编译报错问题汇总</title>
    <link href="http://www.wxtlife.com/2017/03/12/gradle-error-collect/"/>
    <id>http://www.wxtlife.com/2017/03/12/gradle-error-collect/</id>
    <published>2017-03-12T02:26:55.000Z</published>
    <updated>2018-03-16T15:49:44.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>下面是在工作中Studio 中经常报错的一些问题，现汇总如下：</p><h2 id="由于引用库版本和编译版本不一致导致"><a href="#由于引用库版本和编译版本不一致导致" class="headerlink" title="由于引用库版本和编译版本不一致导致"></a>由于引用库版本和编译版本不一致导致</h2><p>studio 报错如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error:Execution failed for task &apos;:app:processcvtouchDebugResources&apos; </span><br><span class="line">com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &apos;command </span><br><span class="line">&apos;/Users/Aaron/Library/Android/sdk/build-tools/21.1.1/aapt&apos;&apos; finished with non-zero exit value 1</span><br></pre></td></tr></table></figure></p><ul><li>解决办法：<br>主要报错是说v21/values-v21.xml 文件中很多资源找不到，不匹配的问题。<br>最终发现在build.gradle 中配置的compileSdkVersion 与引用的库版本不一致导致，例如编译使用的是21，但是引用库是23的版本，例如:<code>compile &#39;com.android.support:recyclerview-v7:23.3.0&#39;</code></li></ul><p>此时将两个版本统一即可。比如修改compileSdkVersion 的版本为 23 则可以解决此问题。</p><a id="more"></a>  <h2 id="由于项目中与Library中jar包重复引起的异常。"><a href="#由于项目中与Library中jar包重复引起的异常。" class="headerlink" title="由于项目中与Library中jar包重复引起的异常。"></a>由于项目中与Library中jar包重复引起的异常。</h2><p>常见错误如下，一般在Multiple dex files 后面会跟上重复的jar的包名。<br><code>com.android.dex.DexException:Multiple dex files define Landroid/support/v4/*</code></p><ul><li>解决办法：<br>查看各个依赖的子工程的libs以及build.gradle文件夹下面是否有相同的jar包。将多余的去掉重新clean并build即可</li></ul><h2 id="由于引用不同sdk版本导致的问题"><a href="#由于引用不同sdk版本导致的问题" class="headerlink" title="由于引用不同sdk版本导致的问题"></a>由于引用不同sdk版本导致的问题</h2><p><code>Error:Execution failed for task &#39;:CommonLibrary:LibImageLoader:mockableAndroidJar&#39;.&gt; java.lang.NullPointerException (no error message)</code></p><ul><li>解决办法：在相关的build.gradle 文件中的末尾添加如下代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tasks.whenTaskAdded &#123; task -&gt;</span><br><span class="line">    if (task.name.contains(&apos;mockableAndroidJar&apos;)) &#123;</span><br><span class="line">        task.enabled = false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Unsupported-major-minor-version-52-0"><a href="#Unsupported-major-minor-version-52-0" class="headerlink" title="Unsupported major.minor version 52.0"></a>Unsupported major.minor version 52.0</h2><p><code>Error:(1, 0) Cause: com/android/build/gradle/AppPlugin : Unsupported major.minor version 52.0</code></p><p>此错误主要是因为本地的gradle build tools 版本比配置的低了，要么升级AS的版本，要么就是改project的build.gradle里的<code>dependencies</code>下面的classpath 与AS的版本保持一致就行。</p><h2 id="安装时提示-apk-在磁盘上未找到"><a href="#安装时提示-apk-在磁盘上未找到" class="headerlink" title="安装时提示 apk 在磁盘上未找到"></a>安装时提示 apk 在磁盘上未找到</h2><p>错误日志如下：<br><code>The APK file /Users/MyApplicationName/app/build/outputs/apk/app-debug.apk does not exist on disk.</code>   </p><ul><li>解决办法: 在AS工程的的右上角，<code>Gradle projects</code>上面点击刷新按钮，如下图：<br><img src="https://i.stack.imgur.com/2KSyU.png" alt="http://stackoverflow.com/questions/34039834/the-apk-file-does-not-exist-on-disk"></li></ul><h2 id="编译提示‘default-not-found’"><a href="#编译提示‘default-not-found’" class="headerlink" title="编译提示‘default not found’"></a>编译提示‘default not found’</h2><p>错误提示如下：<code>Error:Configuration with name &#39;default&#39; not found.</code></p><ul><li><p>解决办法： </p><ol><li><p>打开settings.gradle发现里面有很多个include ‘:app’这样的include，然而发现在工程的目录下面根本没有include的项目，所以将需要include的项目添加进来，如果include的项目不需要，则将其include语句直接删掉，重新sync尝试。</p></li><li><p>按照上面的操作，要么添加了相应inlcude的工程进来，但是发现还是会提示这样的default not found语句，怎么回事呢，原来用gradle编译的工程，每个工程下面都必须要有build.gradle文件,才能够编译include的工程。整个大工程才能sync通过。把include工程中都添加上相应的gradle配置文件，再重新进行sync，整个工程都通过了。</p></li></ol></li></ul><p>参考链接 <a href="http://www.wxtlife.com/2015/09/26/slove-studio-default-not-found/">http://www.wxtlife.com/2015/09/26/slove-studio-default-not-found/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;下面是在工作中Studio 中经常报错的一些问题，现汇总如下：&lt;/p&gt;
&lt;h2 id=&quot;由于引用库版本和编译版本不一致导致&quot;&gt;&lt;a href=&quot;#由于引用库版本和编译版本不一致导致&quot; class=&quot;headerlink&quot; title=&quot;由于引用库版本和编译版本不一致导致&quot;&gt;&lt;/a&gt;由于引用库版本和编译版本不一致导致&lt;/h2&gt;&lt;p&gt;studio 报错如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Error:Execution failed for task &amp;apos;:app:processcvtouchDebugResources&amp;apos; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;com.android.ide.common.process.ProcessException: org.gradle.process.internal.ExecException: Process &amp;apos;command &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;apos;/Users/Aaron/Library/Android/sdk/build-tools/21.1.1/aapt&amp;apos;&amp;apos; finished with non-zero exit value 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决办法：&lt;br&gt;主要报错是说v21/values-v21.xml 文件中很多资源找不到，不匹配的问题。&lt;br&gt;最终发现在build.gradle 中配置的compileSdkVersion 与引用的库版本不一致导致，例如编译使用的是21，但是引用库是23的版本，例如:&lt;code&gt;compile &amp;#39;com.android.support:recyclerview-v7:23.3.0&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此时将两个版本统一即可。比如修改compileSdkVersion 的版本为 23 则可以解决此问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="AndroidStudio" scheme="http://www.wxtlife.com/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>Android 设置无线热点模块隐藏SSID</title>
    <link href="http://www.wxtlife.com/2017/02/16/android-system-wifi-hide-ssid/"/>
    <id>http://www.wxtlife.com/2017/02/16/android-system-wifi-hide-ssid/</id>
    <published>2017-02-16T11:11:42.000Z</published>
    <updated>2018-03-16T15:49:44.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>在Android上需要将无线热点SSID设置为隐藏的，与系统沟通后发现在无线热点的配置文件中有相关的配置项可以实现方便实现此功能。</p><p>在<code>/data/misc/wifi/hostpad.confg</code> 文件中加入如下<code>ignore_broadcast_ssid=1</code>加入此配置项后重启启动wifi热点模块即可很方便的隐藏SSID，如需不隐藏则将值配置为0即可。</p><h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><p>在根据wifi名和密码连接热点时，如果热点SSID为隐藏的，则这时候可能会连接不上，需要在连接的配置文件中添加扫描连接隐藏SSID的配置，配置代码如下:<code>scan_ssid=1</code>即可实现扫描连接SSID的功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队
      
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="Android System" scheme="http://www.wxtlife.com/tags/Android-System/"/>
    
  </entry>
  
  <entry>
    <title>Android默认系统声音/大小修改及配置</title>
    <link href="http://www.wxtlife.com/2016/12/21/modify-android-media-default-voice/"/>
    <id>http://www.wxtlife.com/2016/12/21/modify-android-media-default-voice/</id>
    <published>2016-12-21T14:36:39.000Z</published>
    <updated>2018-03-16T15:49:44.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p><strong>本文是基于Android5.1的代码</strong><br>在做定制需求的时候，需要修改系统通知的声音，将其禁用掉，避免第三方应用发送通知时，声音很大，吓着用户。索性就把通知声音关掉。下面就说说关闭声音的几种方法,以及修改系统默认声音的方法。</p><h3 id="1-直接修改系统层默认的声音大小"><a href="#1-直接修改系统层默认的声音大小" class="headerlink" title="1. 直接修改系统层默认的声音大小"></a>1. 直接修改系统层默认的声音大小</h3><p>在系统代码<code>frameworks/base/media/java/android/media/AudioService.java</code>的开头定义了两个数组，一个<code>MAX_STREAM_VOLUME</code> 这里面定义了各种声音的最大值（<strong>最大值不是100</strong>，所以需要<code>AudioManager.getStreamMaxVolume(type)</code>来获取各个音量的最大值），然后进行设置。</p><a id="more"></a><p>还定义了一个数组<code>DEFAULT_STREAM_VOLUME</code> 这里面则和<code>MAX_STREAM_VOLUME</code>里定义的顺序是一样，表明了各种声音的默认的大小。此块代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> Maximum volume index values for audio streams */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] MAX_STREAM_VOLUME = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">     <span class="number">5</span>,  <span class="comment">// STREAM_VOICE_CALL</span></span><br><span class="line">     <span class="number">7</span>,  <span class="comment">// STREAM_SYSTEMX_STREAM_VOLUMEMAX_STREAM_VOLUMEMAX_STREAM_VOLUME</span></span><br><span class="line">     <span class="number">7</span>,  <span class="comment">// STREAM_RING</span></span><br><span class="line">     <span class="number">15</span>, <span class="comment">// STREAM_MUSIC</span></span><br><span class="line">     <span class="number">7</span>,  <span class="comment">// STREAM_ALARM</span></span><br><span class="line">     <span class="number">7</span>,  <span class="comment">// STREAM_NOTIFICATION</span></span><br><span class="line">     <span class="number">15</span>, <span class="comment">// STREAM_BLUETOOTH_SCO</span></span><br><span class="line">     <span class="number">7</span>,  <span class="comment">// STREAM_SYSTEM_ENFORCED</span></span><br><span class="line">     <span class="number">15</span>, <span class="comment">// STREAM_DTMF</span></span><br><span class="line">     <span class="number">15</span>  <span class="comment">// STREAM_TTS</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] DEFAULT_STREAM_VOLUME = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">     <span class="number">4</span>,  <span class="comment">// STREAM_VOICE_CALL</span></span><br><span class="line">     <span class="number">7</span>,  <span class="comment">// STREAM_SYSTEM</span></span><br><span class="line">     <span class="number">5</span>,  <span class="comment">// STREAM_RING</span></span><br><span class="line">     <span class="number">11</span>, <span class="comment">// STREAM_MUSIC</span></span><br><span class="line">     <span class="number">6</span>,  <span class="comment">// STREAM_ALARM</span></span><br><span class="line">     <span class="number">5</span>,  <span class="comment">// STREAM_NOTIFICATION</span></span><br><span class="line">     <span class="number">7</span>,  <span class="comment">// STREAM_BLUETOOTH_SCO</span></span><br><span class="line">     <span class="number">7</span>,  <span class="comment">// STREAM_SYSTEM_ENFORCED</span></span><br><span class="line">     <span class="number">11</span>, <span class="comment">// STREAM_DTMF</span></span><br><span class="line">     <span class="number">11</span>  <span class="comment">// STREAM_TTS</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>如果我们需要修改默认的通知声音，则可以将<code>STREAM_NOTIFICATION</code> 前面的数值 5 给为 0即可，这样默认声音就为0 了。</p><h3 id="2-修改数据库中的通知声音值"><a href="#2-修改数据库中的通知声音值" class="headerlink" title="2. 修改数据库中的通知声音值"></a>2. 修改数据库中的通知声音值</h3><p>媒体声音这些数据在数据库中都会默认的存放数据，我们知道大多数的数据都是系统初次启动的时候在<code>SettingProvider</code>应用中加载初始化的值，当然通知的声音也在里面。</p><p>具体的代码在<code>frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java</code> 其中有个方法<code>loadVolumeLevels(db)</code> 此方法则是加载所有默认声音大小的地方，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">stmt = db.compileStatement(<span class="string">"INSERT OR IGNORE INTO system(name,value)"</span> + <span class="string">" VALUES(?,?);"</span>);</span><br><span class="line"></span><br><span class="line">loadSetting(stmt, Settings.System.VOLUME_MUSIC,     AudioService.getDefaultStreamVolume(AudioManager.STREAM_MUSIC));</span><br><span class="line"></span><br><span class="line">loadSetting(stmt, Settings.System.VOLUME_RING,          AudioService.getDefaultStreamVolume(AudioManager.STREAM_RING));</span><br><span class="line"></span><br><span class="line">loadSetting(stmt, Settings.System.VOLUME_SYSTEM,        AudioService.getDefaultStreamVolume(AudioManager.STREAM_SYSTEM));</span><br><span class="line"></span><br><span class="line">loadSetting(stmt,Settings.System.VOLUME_VOICE,</span><br><span class="line">AudioService.getDefaultStreamVolume(AudioManager.STREAM_VOICE_CALL));</span><br><span class="line"></span><br><span class="line">loadSetting(stmt, Settings.System.VOLUME_ALARM,         AudioService.getDefaultStreamVolume(AudioManager.STREAM_ALARM));</span><br><span class="line"></span><br><span class="line">loadSetting(stmt,Settings.System.VOLUME_NOTIFICATION,</span><br><span class="line">AudioService.getDefaultStreamVolume(AudioManager.STREAM_NOTIFICATION));</span><br><span class="line"></span><br><span class="line">loadSetting(stmt,Settings.System.VOLUME_BLUETOOTH_SCO,</span><br><span class="line">AudioService.getDefaultStreamVolume(AudioManager.STREAM_BLUETOOTH_SCO));</span><br></pre></td></tr></table></figure></p><p>我们发现loadSetting中把所有声音相关默认值大小的都写入数据库中了，那么我们就可以从这里下手了，在<code>Settings.System.VOLUME_NOTIFICATION</code>的设置项中我们就把他设置为0，则系统通知默认的声音就为0 ，我们再看看<code>AudioService.getDefaultStreamVolume</code>这个方法的实现.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultStreamVolume</span><span class="params">(<span class="keyword">int</span> streamType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DEFAULT_STREAM_VOLUME[streamType];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际就是返回了我们在方案一中系统里面默认音量大小数组里面的值。所以方案一和方案二实际是一个效果</p><h3 id="3-修改ro-config-notification-sound的属性值"><a href="#3-修改ro-config-notification-sound的属性值" class="headerlink" title="3. 修改ro.config.notification_sound的属性值"></a>3. 修改ro.config.notification_sound的属性值</h3><p>此属性值的意思就是通知默认的音乐文件文件名，我们在系统代码<code>build/target/product/full_base.mk</code> 中定义了，如果我们不想有声音那么我们可以将默认值改为不存在的文件，则不会播放通知声音了，当然我们也可以在客户定义的mk中使用<code>PRODUCT_PROPERTY_OVERRIDES</code> 去复写此属性，将其指定为不存在文件或者为空，这样就不会有通知声音响了。</p><h3 id="4-修改默认的声音"><a href="#4-修改默认的声音" class="headerlink" title="4. 修改默认的声音"></a>4. 修改默认的声音</h3><p>系统默认了很多的声音，那么我们要修改一些系统里默认的音效文件呢，那么我们可以修改<code>frameworks/base/data/sounds</code>下面文件及文件夹中的声音文件，如果改了名字记得要在mk中将原来的替换为新的名字。这下面的mk的作用是将这些音乐文件全部打包到系统<code>system/media/audio</code>下面各个模块的文件，然后在系统开机的时候，扫描这些文件，将其加入到数据库中，之后在设置中更换声音时，则直接从数据库中查询这些音乐文件，然后供用户选择。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>系统的媒体这块是很重也很大的一块，这里只是一点点皮毛，只是用到时查到的，要想系统系统学习还得很多工作需要研究。如有问题请及时留言反馈。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文是基于Android5.1的代码&lt;/strong&gt;&lt;br&gt;在做定制需求的时候，需要修改系统通知的声音，将其禁用掉，避免第三方应用发送通知时，声音很大，吓着用户。索性就把通知声音关掉。下面就说说关闭声音的几种方法,以及修改系统默认声音的方法。&lt;/p&gt;
&lt;h3 id=&quot;1-直接修改系统层默认的声音大小&quot;&gt;&lt;a href=&quot;#1-直接修改系统层默认的声音大小&quot; class=&quot;headerlink&quot; title=&quot;1. 直接修改系统层默认的声音大小&quot;&gt;&lt;/a&gt;1. 直接修改系统层默认的声音大小&lt;/h3&gt;&lt;p&gt;在系统代码&lt;code&gt;frameworks/base/media/java/android/media/AudioService.java&lt;/code&gt;的开头定义了两个数组，一个&lt;code&gt;MAX_STREAM_VOLUME&lt;/code&gt; 这里面定义了各种声音的最大值（&lt;strong&gt;最大值不是100&lt;/strong&gt;，所以需要&lt;code&gt;AudioManager.getStreamMaxVolume(type)&lt;/code&gt;来获取各个音量的最大值），然后进行设置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="Android系统" scheme="http://www.wxtlife.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Anroid系统解决扫码枪无法输入字母和字符问题</title>
    <link href="http://www.wxtlife.com/2016/11/09/slove-android-can-not-input-char/"/>
    <id>http://www.wxtlife.com/2016/11/09/slove-android-can-not-input-char/</id>
    <published>2016-11-09T14:19:43.000Z</published>
    <updated>2018-03-16T15:49:44.455Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>在使用扫码枪扫码条码的时候明明有字母和字符，但是输入到Android系统却没哟，输入到电脑是正常的，这就很奇怪，让一个搞上层开发的摸不着头脑，最后和系统讨论才知道是系统按键部分映射被删除导致的。</p><a id="more"></a><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><ol><li>在Android系统层<code>frameworks/base/data/keyboards</code>文件夹下面有<code>Generic.kl</code>这个文件，此文件为Android默认的按键映射对应表，还有其他的比如：<code>qwerty.kl</code>文件，以及一些自定义码值的kl文件。</li><li>打开<code>Generic.kl</code>看看类型也许就明白了.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">key 11      0</span><br><span class="line">key 2       1</span><br><span class="line">key 3       2</span><br><span class="line">key 4       3</span><br><span class="line">key 5       4</span><br><span class="line">key 6       5</span><br><span class="line">key 7       6</span><br><span class="line">key 8       7</span><br><span class="line">key 9       8</span><br><span class="line">key 10      9</span><br><span class="line">key 12      MINUS</span><br><span class="line">key 13      EQUALS</span><br><span class="line">key 14      DEL</span><br><span class="line">key 15      TAB</span><br></pre></td></tr></table></figure></li></ol><p>里面是键与键值的映射，比如：键值11 对应的按键为 0 这个，以此类推。那解决就明朗了，将所有字母和字符的按键映射添加进行就ok了，至于按键值是多少我这边直接参考了另外一个平台的<code>Generic.kl</code>文件。重新编译系统验证，此问题解决了。</p><h3 id="疑惑问题："><a href="#疑惑问题：" class="headerlink" title="疑惑问题："></a>疑惑问题：</h3><ol><li>用相同Android版本的android.jar 查看keyCode对应的值和<code>Generic.kl</code>文件里描述的不一样，此问题还没有弄明白为什么，系统说两个是不相关的？</li><li>发现在两个平台上有大部分按键值在一致的，但存在分别的是不样的，不明白怎么定义的。依据是啥？</li></ol><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/kangear/article/details/12110951" target="_blank" rel="noopener">http://blog.csdn.net/kangear/article/details/12110951</a><br><a href="http://blog.csdn.net/mjsornp/article/details/39988275" target="_blank" rel="noopener">http://blog.csdn.net/mjsornp/article/details/39988275</a><br><a href="https://www.zhihu.com/question/20830530" target="_blank" rel="noopener">https://www.zhihu.com/question/20830530</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;问题：&quot;&gt;&lt;a href=&quot;#问题：&quot; class=&quot;headerlink&quot; title=&quot;问题：&quot;&gt;&lt;/a&gt;问题：&lt;/h3&gt;&lt;p&gt;在使用扫码枪扫码条码的时候明明有字母和字符，但是输入到Android系统却没哟，输入到电脑是正常的，这就很奇怪，让一个搞上层开发的摸不着头脑，最后和系统讨论才知道是系统按键部分映射被删除导致的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android系统" scheme="http://www.wxtlife.com/tags/Android%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
