<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术特工队</title>
  
  <subtitle>人因梦想而伟大，因坚持而可贵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wxtlife.com/"/>
  <updated>2020-04-06T07:02:42.636Z</updated>
  <id>http://www.wxtlife.com/</id>
  
  <author>
    <name>WangXin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文章首发公众号【技术特工队】</title>
    <link href="http://www.wxtlife.com/2021/01/01/my-blog-step-wxtlife-com/"/>
    <id>http://www.wxtlife.com/2021/01/01/my-blog-step-wxtlife-com/</id>
    <published>2020-12-31T16:00:00.000Z</published>
    <updated>2020-04-06T07:02:42.636Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h3 id="【技术特工队】"><a href="#【技术特工队】" class="headerlink" title="【技术特工队】"></a><a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">【技术特工队】</a></h3><p><img src="http://www.wxtlife.com/img/qrcode/qrcode.jpg" alt="技术特工队"> </p><h5 id="分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。"><a href="#分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。" class="headerlink" title="分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。"></a>分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。</h5></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;vip-container&quot;&gt;&lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一
      
    
    </summary>
    
      <category term="Blog" scheme="http://www.wxtlife.com/categories/Blog/"/>
    
    
      <category term="Blog" scheme="http://www.wxtlife.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>react-native-hooks-intro</title>
    <link href="http://www.wxtlife.com/2020/01/18/react-native-hooks-intro/"/>
    <id>http://www.wxtlife.com/2020/01/18/react-native-hooks-intro/</id>
    <published>2020-01-18T14:45:16.000Z</published>
    <updated>2020-04-12T14:46:41.866Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h4 id="React-Hooks-产生的原因"><a href="#React-Hooks-产生的原因" class="headerlink" title="React Hooks 产生的原因"></a>React Hooks 产生的原因</h4><p>在平时的React开发中，我们常用的是使用 Class 来封装一个组件，这也是我们常常使用的方法，看似使用起来很好用，很方便的，那有没有一些让你不舒服的地方呢? 让我们往下看。</p><h4 id="改造成本大"><a href="#改造成本大" class="headerlink" title="改造成本大"></a>改造成本大</h4><p>封装一个组件常常使用Class类来进行，如果够简单很普通的组件，就只有一个render函数，通常这种会被直接写成函数组件，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的组件其实等效于下面的class<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但如果我们使用的函数式组件，这时候如果需要在组件内不得不加状态时，我们就必须把函数式组件改造为class 类型的组件，才能满足我们的需求，如果对于很多的函数式组件，那这是致命的，会产生很大的工作量及不稳定的因素在里面了。所以想要复用一个有状态的组件太麻烦了！</p><a id="more"></a><h4 id="业务不聚焦"><a href="#业务不聚焦" class="headerlink" title="业务不聚焦"></a>业务不聚焦</h4><p>在来看一个组件，即使这个组件比较简单，但代码较多比较复杂了，需要定义 构造函数，响应函数，render函数，生命周期函数等等，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default class Button extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.state = &#123; buttonText: &quot;Click me, please&quot; &#125;;</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    // add back key Listern </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">      // remove back key listener</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.setState(() =&gt; &#123;</span><br><span class="line">      return &#123; buttonText: &quot;Thanks, been clicked!&quot; &#125;;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; buttonText &#125; = this.state;</span><br><span class="line">    return &lt;button onClick=&#123;this.handleClick&#125;&gt;&#123;buttonText&#125;&lt;/button&gt;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在这个组件中<code>componentDidMount</code> 和 <code>componentWillUnmount</code> 按逻辑应该是add 和 remove 同一个业务的listener，但它的业务被分到两个方法中，若这种方法较多，就会比较零散，且这两个生命周期中包含的业务就比较复杂了，所以这也是一个较大的问题。</p><h3 id="复用性较复杂"><a href="#复用性较复杂" class="headerlink" title="复用性较复杂"></a>复用性较复杂</h3><p>比如一个通用的组件中包含不同的子组件，可能需要使用到 <a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener"><code>Render Props</code></a> 和 <a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener"><code>高阶组件</code></a>  来进行组合，但是这样使用的成本实际上比较高的。</p><h3 id="React-Hooks-什么"><a href="#React-Hooks-什么" class="headerlink" title="React Hooks 什么"></a>React Hooks 什么</h3><p>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。 React Hooks 就是那些钩子。</p><p>下面介绍的 <code>useState</code>, <code>useEffect</code>, <code>useRef</code>, <code>useContext</code> 等都为官方提供的一些常用的hooks方法，基本上这几类都能解决大部分的函数式组件的需求。<br>下面我们大概进行介绍 </p><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p>useState 是官方提供的一个函数式组件中管理 State<br>的hook函数，相当于之前的 this.state, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// count为定义的状态为 count</span><br><span class="line">// setCount 为提供的改变count属性的方法</span><br><span class="line">// 0 为属性 count 的默认值，当然也可以为对象</span><br><span class="line">const [count, setCount] = useState(0);</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>上面的代码就相当于之前state的下面写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123; </span><br><span class="line">    count: 0,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于多个方法State的使用useState写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [count, setCount] = useState(0);</span><br><span class="line">const [age, setAge] = useState(0);</span><br></pre></td></tr></table></figure></p><p><strong>注意： 必须按照顺序写在函数最外层执行，不能使用 if else 进行条件判断，</strong> </p><p>如果要更新state的值，则使用素组中第二个方法调用<code>setCount</code> 或者 <code>setAge</code>方法进行更新，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setAge(18) </span><br><span class="line"></span><br><span class="line">// 等价于 </span><br><span class="line">this.setState(&#123;</span><br><span class="line">    age: 18</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>这样整体上看，也是更加的简洁了。</p><h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><p>上面有了state，但是在class中，还会有生命周期的函数，对于函数式组件，则没法直接表示生命周期，所以就有了<code>useEffect</code>。<br><code>useEffect</code> 代表 <code>componentDidMount</code> and <code>componentDidUpdate</code> and <code>componentWillUnmount</code>， 当然代表不同的函数肯定有不同的写法。基本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">    document.title = &apos;use effect demo&apos;</span><br><span class="line">&#125;)</span><br><span class="line">// 以上代码就相当于在 `componentDidMount` and `componentDidUpdate` 中执行方法中的语句。等同于如下：</span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">    document.title = `use effect demo`</span><br><span class="line"> &#125;</span><br><span class="line"> componentDidUpdate() &#123;</span><br><span class="line">     document.title = `use effect demo`</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>那么要实现<code>componentWillUnmount</code> 如何处理呢？ 方法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">        // foreample add listener </span><br><span class="line">        API.addListener(*)</span><br><span class="line">        // 这里返回就是清除操作的函数方法</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            API.removeListener(*)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>通过在函数中返回一个析构的方法，来释放相对应的资源。但是上面这种会在每次render渲染的收都会执行一次add，在下次渲染时，先执行remove，然后在进行add，所以导致每次render时会造成很多不必要的方法执行，那当然 React 官方也知道问题点了，所以就有了与某个state状态绑定的关系，写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 只会在count变化的时候才会执行此方法。</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">        document.title = `use effect demo count = $&#123;count&#125;`</span><br><span class="line">    &#125;, [count])</span><br><span class="line"></span><br><span class="line">// 在userId变化的时候，重新添加listener，并移除原来的</span><br><span class="line">useEffect(() =&gt; &#123;</span><br><span class="line">        // foreample add listener </span><br><span class="line">        API.addListener(*, userId)</span><br><span class="line">        // 这里返回就是清除操作的函数方法</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            API.removeListener(*, userId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, [userId])</span><br></pre></td></tr></table></figure></p><p>就 <code>useEffect</code> 这一个会是经常用到的方法。掌握了她，后面其他的几个也就很容易理解和掌握了。</p><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p><code>useRef</code> 主要是对一些控件操作时，需要用到的，比如说textinput焦点等，这个使用和 <code>useState</code>类似 ，下面举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function LoginView() &#123;</span><br><span class="line">    const input = useRef(null)</span><br><span class="line">    const forceInpput = () =&gt; &#123;</span><br><span class="line">        input.current.force()</span><br><span class="line">    &#125;</span><br><span class="line">    return () =&gt; &#123;</span><br><span class="line">        &lt;View&gt;</span><br><span class="line">            &lt;TextInput ref=&#123;input&#125; /&gt;</span><br><span class="line">            &lt;Button onpressed=&#123;forceInput&#125; /&gt;</span><br><span class="line">        &lt;/view&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样可以直接拿到函数中空间的ref对象，进行相应控制操作。</p><h4 id="其他几种React的使用"><a href="#其他几种React的使用" class="headerlink" title="其他几种React的使用"></a>其他几种React的使用</h4><p>参考： <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/hooks-reference.html</a></p><h3 id="自定义React-hooks"><a href="#自定义React-hooks" class="headerlink" title="自定义React hooks"></a>自定义React hooks</h3><p>对于可以提取复用的组件，则可以定义一起通用的React custom hooks ,这里其实也是对 上面几种react hooks的组合使用，这里就不多介绍了，具体参考<br><a href="https://zh-hans.reactjs.org/docs/hooks-custom.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/hooks-custom.html</a></p><h3 id="React-Hook-总结"><a href="#React-Hook-总结" class="headerlink" title="React Hook 总结"></a>React Hook 总结</h3><p>使用React hook模式代码看起来确认很精简，看起来也很舒服，当前如果要使用这一套还必须团队的成员一起进行执行。对于之前已经时间的 <code>Component</code> 就没必要进行重写了，实际上他们是一样的效果。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://zh-hans.reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/hooks-intro.html</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;React-Hooks-产生的原因&quot;&gt;&lt;a href=&quot;#React-Hooks-产生的原因&quot; class=&quot;headerlink&quot; title=&quot;React Hooks 产生的原因&quot;&gt;&lt;/a&gt;React Hooks 产生的原因&lt;/h4&gt;&lt;p&gt;在平时的React开发中，我们常用的是使用 Class 来封装一个组件，这也是我们常常使用的方法，看似使用起来很好用，很方便的，那有没有一些让你不舒服的地方呢? 让我们往下看。&lt;/p&gt;
&lt;h4 id=&quot;改造成本大&quot;&gt;&lt;a href=&quot;#改造成本大&quot; class=&quot;headerlink&quot; title=&quot;改造成本大&quot;&gt;&lt;/a&gt;改造成本大&lt;/h4&gt;&lt;p&gt;封装一个组件常常使用Class类来进行，如果够简单很普通的组件，就只有一个render函数，通常这种会被直接写成函数组件，如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;export function Welcome(props) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return &amp;lt;h1&amp;gt;Hello, &amp;#123;props.name&amp;#125;&amp;lt;/h1&amp;gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的组件其实等效于下面的class&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Welcome extends React.Component &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  render() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &amp;lt;h1&amp;gt;Hello, &amp;#123;this.props.name&amp;#125;&amp;lt;/h1&amp;gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但如果我们使用的函数式组件，这时候如果需要在组件内不得不加状态时，我们就必须把函数式组件改造为class 类型的组件，才能满足我们的需求，如果对于很多的函数式组件，那这是致命的，会产生很大的工作量及不稳定的因素在里面了。所以想要复用一个有状态的组件太麻烦了！&lt;/p&gt;
    
    </summary>
    
      <category term="React native" scheme="http://www.wxtlife.com/categories/React-native/"/>
    
    
      <category term="react-native" scheme="http://www.wxtlife.com/tags/react-native/"/>
    
      <category term="js" scheme="http://www.wxtlife.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>React 中 State 的那点事</title>
    <link href="http://www.wxtlife.com/2020/01/04/react-state-async/"/>
    <id>http://www.wxtlife.com/2020/01/04/react-state-async/</id>
    <published>2020-01-04T07:59:08.000Z</published>
    <updated>2020-04-06T08:02:56.444Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3><p><img src="http://www.wxtlife.com/img/qrcode/qrcode.jpg" alt="技术特工队"> </p><h4 id="setState-为什么是异步的"><a href="#setState-为什么是异步的" class="headerlink" title="setState 为什么是异步的"></a>setState 为什么是异步的</h4><p>首先我们先来看一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState( &#123; <span class="attr">num</span>: <span class="keyword">this</span>.state.num + <span class="number">1</span> &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果每次都立马执行的，再短短的时间里，会有100次的渲染，这显然对于React来说是很大的一个渲染性能问题，所以针对setState做了一些特别的优化：<strong>React会将多个setState的调用合并成一个来执行，这意味着当调用setState时，state并不会立即更新</strong></p><p>具体来说是在 setState之后并不会立马执行，而是放到一个队列中，在合适的时机，批量更新state，队列机制可以批量的合并更新State。<br>最终被react合并后效果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(</span><br><span class="line">  previousState,</span><br><span class="line">  &#123; num: this.state.num + 1 &#125;,</span><br><span class="line">  &#123; num: this.state.num + 1 &#125;,  </span><br><span class="line">  &#123; num: this.state.num + 1 &#125;,</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>再看这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const b = &#123; name: &apos;brian&apos;, name: &apos;peter&apos; , name: &apos;Dave&apos;&#125;;</span><br><span class="line">//  b的结果为 &#123;name: &apos;Dave&apos;&#125;</span><br></pre></td></tr></table></figure><p>这个问题也就解释了，上面的循环逻辑执行，每次拿到的 this.state.num 始终是0，最值在最后合并后，num的值再变为1 ，所以对于react内部渲染最终只会执行一次最终的渲染，因为这部分React将其进行了合并处理。</p><a id="more"></a><p><a href="https://juejin.im/post/5bf55878e51d452b19649eae" target="_blank" rel="noopener">https://juejin.im/post/5bf55878e51d452b19649eae</a></p><p><a href="https://medium.com/@brianwu291/learn-basic-react-setstate-function-2aec5018a38a" target="_blank" rel="noopener">https://medium.com/@brianwu291/learn-basic-react-setstate-function-2aec5018a38a</a></p><h3 id="js单线程"><a href="#js单线程" class="headerlink" title="js单线程"></a>js单线程</h3><p>那我们再来看一次例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">this.setState( &#123; num: this.state.num + 1 &#125; );</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">      this.setState(&#123; num: this.state.num + 1 &#125;);</span><br><span class="line">     &#125;, 0)</span><br></pre></td></tr></table></figure></p><p>在这个例子中，执行了两遍setState，第二句是放在了setTimeout中进行执行，但是时间间隔是0，这样的情况下，我们得到的输出结果就是正常，符合预期的，这是为什么呢？</p><p>这里需要了解js的单线程的逻辑，单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。但是对于多核cpu，就有些浪费了，所有就将执行的任务分为同步任务和异步任务，同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”被主线程通知，某个异步任务可以执行了，该任务才会进入主线程执行。</p><p>同步任务就在主线程上执行，形成一个执行任务栈，只有当任务栈中的任务执行完后，才会让任务队列中第一位进入主线程，而这里一般也会检测一个执行时间，可能任务是延时任务，只有等到规定时间才会回到主线程中执行。</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(function()&#123;console.log(2);&#125;,0);</span><br><span class="line">console.log(3);</span><br><span class="line">console.log(4);</span><br><span class="line"></span><br><span class="line">// 输出结果： 1 -&gt; 3 -&gt; 4 -&gt; 2</span><br></pre></td></tr></table></figure></p><p>原因为外层的console输出都是同步任务，直接在主线程任务栈中进行执行，只有这部分执行完后，才会检测位于 任务队列的任务即（setTimeout console ） 方法，所以这个2一定是最后输出的。</p><h4 id="如果非要每次都执行有没有办法呢？"><a href="#如果非要每次都执行有没有办法呢？" class="headerlink" title="如果非要每次都执行有没有办法呢？"></a>如果非要每次都执行有没有办法呢？</h4><p>React 提供了更新的方法，可以拿到前一个state的状态，然后进行更新，例子如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">preState, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">counter</span>: preState.counter + <span class="number">1</span>&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>上面的方法react会保证preState能够每次都拿到最新的值，所以在特殊场景下，可以这样更新state，那么就可以每次都能拿到最新的值。</p><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p><h3 id="题外话："><a href="#题外话：" class="headerlink" title="题外话："></a>题外话：</h3><h4 id="setTimeout-和-setInterval-等的区别"><a href="#setTimeout-和-setInterval-等的区别" class="headerlink" title="setTimeout 和 setInterval 等的区别"></a>setTimeout 和 setInterval 等的区别</h4><ul><li>setTimeout 在指定时间后，仅执行一次</li><li>setInterval 每隔指定时间后，就执行一次</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot; alt=&quot;技术特工队&quot;&gt; &lt;/p&gt;
&lt;h4 id=&quot;setState-为什么是异步的&quot;&gt;&lt;a href=&quot;#setState-为什么是异步的&quot; class=&quot;headerlink&quot; title=&quot;setState 为什么是异步的&quot;&gt;&lt;/a&gt;setState 为什么是异步的&lt;/h4&gt;&lt;p&gt;首先我们先来看一个例子：&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; i++ ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.setState( &amp;#123; &lt;span class=&quot;attr&quot;&gt;num&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state.num + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &amp;#125; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果每次都立马执行的，再短短的时间里，会有100次的渲染，这显然对于React来说是很大的一个渲染性能问题，所以针对setState做了一些特别的优化：&lt;strong&gt;React会将多个setState的调用合并成一个来执行，这意味着当调用setState时，state并不会立即更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体来说是在 setState之后并不会立马执行，而是放到一个队列中，在合适的时机，批量更新state，队列机制可以批量的合并更新State。&lt;br&gt;最终被react合并后效果如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Object.assign(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  previousState,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; num: this.state.num + 1 &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; num: this.state.num + 1 &amp;#125;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123; num: this.state.num + 1 &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;再看这个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const b = &amp;#123; name: &amp;apos;brian&amp;apos;, name: &amp;apos;peter&amp;apos; , name: &amp;apos;Dave&amp;apos;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  b的结果为 &amp;#123;name: &amp;apos;Dave&amp;apos;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个问题也就解释了，上面的循环逻辑执行，每次拿到的 this.state.num 始终是0，最值在最后合并后，num的值再变为1 ，所以对于react内部渲染最终只会执行一次最终的渲染，因为这部分React将其进行了合并处理。&lt;/p&gt;
    
    </summary>
    
      <category term="React native" scheme="http://www.wxtlife.com/categories/React-native/"/>
    
    
      <category term="react-native" scheme="http://www.wxtlife.com/tags/react-native/"/>
    
      <category term="js" scheme="http://www.wxtlife.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>React native 中原生层与js数据交互的几种方式</title>
    <link href="http://www.wxtlife.com/2019/11/17/react-native-data-exchange/"/>
    <id>http://www.wxtlife.com/2019/11/17/react-native-data-exchange/</id>
    <published>2019-11-17T06:56:31.000Z</published>
    <updated>2020-04-06T07:02:12.144Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3><p><img src="http://www.wxtlife.com/img/qrcode/qrcode.jpg" alt="技术特工队"> </p><h3 id="RN-方法的调用的几种方法"><a href="#RN-方法的调用的几种方法" class="headerlink" title="RN 方法的调用的几种方法"></a>RN 方法的调用的几种方法</h3><p>从数据的交互上来看，调用方无非从 native 调用 js 层，或 从 js 调用 native 方法，常用的主要是通过 <code>JavaModule</code> 来提供方法调动，但常常我们有一些自定义的native view，而这部分也是需要和 js进行相关的交互，那么下面进行调用的一些统一的整理。</p><h3 id="js-调用-native-方法"><a href="#js-调用-native-方法" class="headerlink" title="js 调用 native 方法"></a>js 调用 native 方法</h3><h4 id="js-通过-JavaModule-方式进行调用。"><a href="#js-通过-JavaModule-方式进行调用。" class="headerlink" title="js 通过 JavaModule 方式进行调用。"></a>js 通过 <code>JavaModule</code> 方式进行调用。</h4><p>在 RN 中需要调用 native 的方法，常用的是通过在 native 继承 <code>ReactContextBaseJavaModule</code>  然后注册 <code>ReactMethod</code> 方法，供js层进行调用。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ToastWidget extends ReactContextBaseJavaModule &#123;</span><br><span class="line"></span><br><span class="line">     @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return &quot;ToastWidget&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @ReactMethod</span><br><span class="line">    public void showToast(String message) &#123;</span><br><span class="line">        Toast.makeText(getCurrentActivity(), message, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后此 module 在 ReactPackage 中进行注册，最后此package在 Application 中进行注册处理。</p><p>在 js 中 可以按如下方式即可调用 native 层的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;  NativeModules &#125; <span class="keyword">from</span> <span class="string">'react-native'</span></span><br><span class="line"><span class="keyword">const</span> &#123; ToastWidget &#125; = NativeModules</span><br><span class="line"></span><br><span class="line">ToastWidget.showToast(<span class="string">'这是一个Toast'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="自定义native-view，js-如果调用native-view中的方法"><a href="#自定义native-view，js-如果调用native-view中的方法" class="headerlink" title="自定义native view，js 如果调用native view中的方法"></a>自定义native view，js 如果调用native view中的方法</h4><p>常常在native层需要实现一些 js 无法达到效果或者满足需求的界面，这时候就需要native层自定义view来实现了，而这部分 RN 提供了ViewManger 来满足需求，那如何在自定义view中的方法能够让 js 调用呢，一般的可以通过props进行控制，如果是一些特殊的方法呢，RN提供了<code>getCommandsMap</code> 和 <code>receiveCommand</code> 两个方法来实现，js调用viewManger中的方法，commands 为提供的命令集合，receiveCommand接收命名，并执行相应的native代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Map&lt;String, Integer&gt; getCommandsMap() &#123;</span><br><span class="line">    // 导出 command </span><br><span class="line">    return MapBuilder.&lt;String, Integer&gt;builder()</span><br><span class="line">            .put(&quot;scrollTo&quot;, COMMAND_SCROLL_TO)</span><br><span class="line">            .put(&quot;atUser&quot;, COMMAND_AT_USER)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void receiveCommand(@Nonnull ChatView root, int commandId, @Nullable ReadableArray args) &#123;</span><br><span class="line">    // 根据命令执行对应的native方法</span><br><span class="line">    switch (commandId) &#123;</span><br><span class="line">        case COMMAND_SCROLL_TO:</span><br><span class="line">            Logger.v(MODULE_NAME, &quot;receiveCommand scroll to args = &quot; + args);</span><br><span class="line">            break;</span><br><span class="line">        case COMMAND_AT_USER:</span><br><span class="line">            Logger.v(MODULE_NAME, &quot;receiveCommand at user args = &quot; + args);</span><br><span class="line">            break;</span><br><span class="line">         default:</span><br><span class="line">            Logger.v(MODULE_NAME, &quot;receiveCommand not found args = &quot; + args);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在js中可使用如下进行调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 导入native view ，进行布局显示</span><br><span class="line">const NativeView = requireNativeComponent(&apos;NativeView&apos;)</span><br><span class="line">UIManager.dispatchViewManagerCommand(</span><br><span class="line">  findNodeHandle(this._chatViewRef),  // _chatViewRef 为native view的引用</span><br><span class="line">  NativeView.Commands.scrollTo, // 对应native层getCommandsMap定义</span><br><span class="line">  args,  // 参数，参数为数组对象</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>通过上面代码即可实现 js层调用自定义 view 中的方法了。</p><h3 id="native-调用-js-方法"><a href="#native-调用-js-方法" class="headerlink" title="native 调用 js 方法"></a>native 调用 js 方法</h3><p>这部分主要是传递 native 的回调事件及数据给到js或者直接调用js层的方法。</p><h4 id="native-回调数据给到js层"><a href="#native-回调数据给到js层" class="headerlink" title="native 回调数据给到js层"></a>native 回调数据给到js层</h4><p>这部分常见于注册一些native的listener接口，后续数据有变化后，在通过<code>RCTDeviceEventEmitter</code>此部分给到js层，示例如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context.runOnNativeModulesQueueThread(() -&gt; &#123;</span><br><span class="line">    // 获取deviceEventmanager 然后发送事件及数据</span><br><span class="line">    DeviceEventManagerModule.RCTDeviceEventEmitter emitter = context.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class);</span><br><span class="line">    emitter.emit(eventName, message); // eventName 为事件名， message为具体的消息内容，需要为RN支持的数据类型 </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 js层添加数据的监听，监听数据的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123; NativeModules, NativeEventEmitter &#125; from &apos;react-native&apos;</span><br><span class="line"></span><br><span class="line">const nativeEventEmitter = new NativeEventEmitter(&quot;nativeModuleName&quot;)</span><br><span class="line">return nativeEventEmitter.addListener(&quot;eventName&quot;, listener) // eventName 为上层发送的事件名， listener 为添加的事件监听函数</span><br></pre></td></tr></table></figure></p><p>这种方案即可实现数据的监听。</p><h4 id="native直接调用js中的方法"><a href="#native直接调用js中的方法" class="headerlink" title="native直接调用js中的方法"></a>native直接调用js中的方法</h4><p>这种操作一般是在界面层，想要直接调用js中的方法而进行的操作，native层在继承自 SimpleViewManager 中复写 <code>addEventEmitters</code> 方法，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addEventEmitters</span><span class="params">(@Nonnull ThemedReactContext reactContext, @Nonnull CustomView view)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里添加调用的执行方法</span></span><br><span class="line">    reactContext.getJSModule(RCTEventEmitter<span class="class">.<span class="keyword">class</span>).<span class="title">receiveEvent</span>(</span></span><br><span class="line"><span class="class">        <span class="title">view</span>.<span class="title">getId</span>(),</span></span><br><span class="line">        "EVENT_METHOD_1", // 调用js的方法名</span><br><span class="line">        data <span class="comment">// 调用传递的数据</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getExportedCustomDirectEventTypeConstants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注册支持的调用的方法名</span></span><br><span class="line">    <span class="keyword">return</span> MapBuilder.&lt;String, Object&gt;builder()</span><br><span class="line">            .put(<span class="string">"EVENT_METHOD_1"</span>, MapBuilder.of(<span class="string">"registrationName"</span>, <span class="string">"EVENT_METHOD_1"</span>))</span><br><span class="line">            .put(<span class="string">"EVENT_METHOD_2"</span>, MapBuilder.of(<span class="string">"registrationName"</span>, <span class="string">"EVENT_METHOD_2"</span>))</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>addEventEmitters</code>的方法参数中能够拿到自定义的View，所以这里可以设置一个回调函数给到View，当View调用方法后，这里就可以直接调用相关方法到js层，接下来再来看下js层要如何处理。</p><p>在js中按照属性的方式进行设置方法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_eventMethode(event) &#123;</span><br><span class="line">    console.log(&apos;_eventMethode event = &apos;, event.nativeEvent)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NativeCustomView</span><br><span class="line">      ref=&#123;this._createViewRef&#125;</span><br><span class="line">      style=&#123;styles.container&#125;</span><br><span class="line">      eventMethod1=&#123;this._eventMethode&#125;</span><br><span class="line">      eventSendMessage=&#123;this._eventMethode&#125;</span><br><span class="line">      /&gt;</span><br></pre></td></tr></table></figure></p><p>在js层<code>eventMethod1</code>可以理解为属性，但在这里为 native 层中向下调用的方法名，native 调用过则会回调到此方法传递的方法，也就是<code>_eventMethode</code>方法，<br>这样在native中执行 addEventEmitters方法中 “EVENT_METHOD_1” ，即可实现调用 js 层的<code>_eventMethode</code>方法</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>要实现 js 与 native 的互相通信，则必不可少会有这些操作，所以在什么情况下使用什么方式进行数据传递或方法的调用需考虑清楚。以上几种方式基本上涵盖了大部分的消息数据通信的场景。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot; alt=&quot;技术特工队&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;RN-方法的调用的几种方法&quot;&gt;&lt;a href=&quot;#RN-方法的调用的几种方法&quot; class=&quot;headerlink&quot; title=&quot;RN 方法的调用的几种方法&quot;&gt;&lt;/a&gt;RN 方法的调用的几种方法&lt;/h3&gt;&lt;p&gt;从数据的交互上来看，调用方无非从 native 调用 js 层，或 从 js 调用 native 方法，常用的主要是通过 &lt;code&gt;JavaModule&lt;/code&gt; 来提供方法调动，但常常我们有一些自定义的native view，而这部分也是需要和 js进行相关的交互，那么下面进行调用的一些统一的整理。&lt;/p&gt;
&lt;h3 id=&quot;js-调用-native-方法&quot;&gt;&lt;a href=&quot;#js-调用-native-方法&quot; class=&quot;headerlink&quot; title=&quot;js 调用 native 方法&quot;&gt;&lt;/a&gt;js 调用 native 方法&lt;/h3&gt;&lt;h4 id=&quot;js-通过-JavaModule-方式进行调用。&quot;&gt;&lt;a href=&quot;#js-通过-JavaModule-方式进行调用。&quot; class=&quot;headerlink&quot; title=&quot;js 通过 JavaModule 方式进行调用。&quot;&gt;&lt;/a&gt;js 通过 &lt;code&gt;JavaModule&lt;/code&gt; 方式进行调用。&lt;/h4&gt;&lt;p&gt;在 RN 中需要调用 native 的方法，常用的是通过在 native 继承 &lt;code&gt;ReactContextBaseJavaModule&lt;/code&gt;  然后注册 &lt;code&gt;ReactMethod&lt;/code&gt; 方法，供js层进行调用。&lt;br&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class ToastWidget extends ReactContextBaseJavaModule &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public String getName() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return &amp;quot;ToastWidget&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @ReactMethod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void showToast(String message) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Toast.makeText(getCurrentActivity(), message, Toast.LENGTH_SHORT).show();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后此 module 在 ReactPackage 中进行注册，最后此package在 Application 中进行注册处理。&lt;/p&gt;
&lt;p&gt;在 js 中 可以按如下方式即可调用 native 层的方法。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &amp;#123;  NativeModules &amp;#125; &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react-native&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &amp;#123; ToastWidget &amp;#125; = NativeModules&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ToastWidget.showToast(&lt;span class=&quot;string&quot;&gt;&#39;这是一个Toast&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="React native" scheme="http://www.wxtlife.com/categories/React-native/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="react-native" scheme="http://www.wxtlife.com/tags/react-native/"/>
    
      <category term="js" scheme="http://www.wxtlife.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>OSX AutoLayout原理介绍</title>
    <link href="http://www.wxtlife.com/2018/11/06/osx-autolayout/"/>
    <id>http://www.wxtlife.com/2018/11/06/osx-autolayout/</id>
    <published>2018-11-06T13:25:58.000Z</published>
    <updated>2019-10-20T15:57:59.603Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3><h3 id="AutoLayout介绍"><a href="#AutoLayout介绍" class="headerlink" title="AutoLayout介绍"></a>AutoLayout介绍</h3><p>Auto Layout 是苹果公司在iOS6发布的界面布局技术，为了适配不同大小屏幕及屏幕变化而推出的一种技术方案，旨在实现一次编写布局界面UI，自动适应所有屏幕布局，并随着iOS SDK的迭代逐步完善了各种布局API、提供多种使用Auto Layout的布局方式。实际上Auto Layout算法本身并非有Apple发明，Auto Layout源于Cassary约束解析工具包。该算法由Alan Borning、Kim Marriott、Peter Stuckey、Yi Xiao于1997年发布，该算法的主要思想是：将基于约束系统的布局规则（本质上是表示视图布局关系的线性方程组）转化为表示规则的视图几何参数。</p><h3 id="传统的布局"><a href="#传统的布局" class="headerlink" title="传统的布局"></a>传统的布局</h3><h4 id="frame-布局"><a href="#frame-布局" class="headerlink" title="frame 布局"></a>frame 布局</h4><p>传统的布局方式是基于Frame来做UI控件的界面布局的,即设置控件在父视图中的起始坐标点Origin(x,y)和控件的大小Size(width,height)，为了精确，我们必须计算每个视图的frame。但布局一旦发生变化，相关frame都需要重新计算。然后这些计算都需要不断的手动动态的去计算，导致一旦有变化，就会需要去维护和调试。</p><h4 id="自动缩放（auto-resizing）"><a href="#自动缩放（auto-resizing）" class="headerlink" title="自动缩放（auto resizing）"></a>自动缩放（auto resizing）</h4><p>自动缩放的出现在一定程度上减轻了我们的负担。自动缩放规定父视图的frame变化时，视图的frame如何应对。如此一来，简化了布局响应外部变化所需的工作。但是他仅能应对外部父布局的变化，自身大小的变化则无法进行处理。</p><a id="more"></a><h3 id="AutoLayout剖析"><a href="#AutoLayout剖析" class="headerlink" title="AutoLayout剖析"></a>AutoLayout剖析</h3><h4 id="布局变化原因"><a href="#布局变化原因" class="headerlink" title="布局变化原因"></a>布局变化原因</h4><p><strong>外在变化：</strong> 窗口缩放，设备旋转，屏幕尺寸不同，分屏模式等。<br><strong>内在变化：</strong> 内容展示变化，国际化，字体变化等。</p><h4 id="AutoLayout方程式"><a href="#AutoLayout方程式" class="headerlink" title="AutoLayout方程式"></a>AutoLayout方程式</h4><p>先来看一张官方的图，表示一个约束的表达式。</p><p><img src="https://upload-images.jianshu.io/upload_images/696463-66769da1d41fafac.png" alt="autoLayout"></p><p>下面来具体介绍下其各个变量的意义。</p><ul><li>Item1、Item2：一般是UIView，表示该约束关系对应的两个视图，当约束等式表示尺寸时，其中一个Item为nil。</li><li>Attribute1、Attribute2：NSLayoutAttribute类型，表示约束属性。当约束等式表示尺寸时，其中一个Attribute为NSLayoutAttributeNotAnAttribute，表示占位，无任何意义。具体看下图</li><li>Relationship：NSLayoutRelation类型，表示约束关系，可以是=、&gt;=、&lt;=。</li><li>Multiplier：CGFloat类型，表示倍数关系，一般用于尺寸（eg：Item1的宽度为Item2的两倍，则Multiplier为2.0）</li><li>Constant：CGFloat类型，表示常数。</li></ul><p><img src="http://macdev.io/ebook/media/14503524325175/AutoLayoutAttributes.png" alt="Attribute"></p><blockquote><p><strong>注意</strong></p><ul><li>只有同类型的约束才能互相做约束</li><li>建议开发中一直使用leading、trailing。leading表示前边、trailing表示后边，在阅读习惯从左到右的语言中，leading相当于left、trailing相当于right。在从右到左的语言中，leading相当于right、trailing相当于left。</li></ul></blockquote><h4 id="AutoLayout-本质"><a href="#AutoLayout-本质" class="headerlink" title="AutoLayout 本质"></a>AutoLayout 本质</h4><p>Auto Layout本质就是一个线性方程解析Engine。基于Auto Layout的布局，不在需要像frame时代一样，关注视图尺寸、位置的常数，转而关注视图之间关系，描述一个表示视图间布局关系的约束集合，由Engine解析出最终数值。</p><p>一个约束对象NSLayoutConstraint，本质上是表示两个视图之间（当表示尺寸时只表示视图本身）布局关系的一个线性方程，该方程可以是线性等式、也可以是线性不等式。</p><p>多个约束对象组成是一个约束集合，本质上是表示某个界面上多个视图之间布局关系的线性方程组。方程组中的多个线性方程，以数字标识的优先级进行排序（UILayoutPriority，本质上是浮点型float）。</p><p>Auto Layout Engine根据按照线性方程的优先级从高到底对线性方程组进行解析，求得方程组的解。</p><ul><li>当设置的约束欠缺，即存在约束歧义，线性方程组有多个解，而不是唯一解。这便是约束错误的一种：约束不充分，可能导致视图丢失，视图错位。</li><li>当设置的约束过多，存在多个优先级相同的描述同一个关系的线性方程，并且约束产生的效果不同（例如 View1.left = View2.right + 10 ; View1.left = View2.right + 20，优先级都为1000），线程方程组无解。这是约束错误的另一种：约束不可满足，产生约束约束冲突，控制台会Log错误日志，同样可能造成布局错误。</li></ul><h4 id="约束优先级"><a href="#约束优先级" class="headerlink" title="约束优先级"></a>约束优先级</h4><p>默认创建出来的约束优先级为UILayoutPriorityRequired（1000），称为必需约束；其他优先级小于1000的约束称为可选约束。Auto Layout Engine进行约束解析时，尝试着按优先级从高到低满足约束集合中的每一个约束，如果无法满足某个可选约束，则跳过；当优先级不同的两个约束描述的是同一个布局关系，Auto Layout会跳过优先级较低的约束。</p><h4 id="Intrinsic-Content-Size"><a href="#Intrinsic-Content-Size" class="headerlink" title="Intrinsic Content Size"></a>Intrinsic Content Size</h4><p>对于文本/图片等一些视图控件，可以通过其内在content推算出控件的大小。不是所有的控件都有Intrinsic Content Size。按钮,文本label,文字输入TextField,TextView,ImageView都可以根据内在的content内容计算控件的大小。</p><p>基于控件的内容content，有2个特定的约束:content hugging 收缩约束 和 content compression 扩张约束，这2个约束简称为CHCR。</p><p><img src="http://macdev.io/ebook/media/14503524325175/AutoLayoutCHCR.png" alt></p><p>IntrinsicHeight代表内部内容的高，IntrinsicWidth代表内部内容的宽</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//content compression的约束条件：</span><br><span class="line">View.height &gt;= IntrinsicHeight</span><br><span class="line">View.width &gt;= IntrinsicWidth</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//content hugging的约束条件：</span><br><span class="line">View.height &lt;= IntrinsicHeight</span><br><span class="line">View.width &lt;= IntrinsicWidth</span><br></pre></td></tr></table></figure><p>从这几组约束来看，如果需要完整的显示内容就需要content compression的优先级尽量高，而如果需要尽量显示的紧凑一些占用空间小一些可以将content hugging优先级尽量设置高一些。</p><p>更加简洁易懂点的描述如下：</p><ul><li>Content Hugging Priority: 该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸</li><li>Content Compression Resistance Priority: 该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩</li></ul><h3 id="Auto-Layout布局机制"><a href="#Auto-Layout布局机制" class="headerlink" title="Auto Layout布局机制"></a>Auto Layout布局机制</h3><p><img src="https://upload-images.jianshu.io/upload_images/696463-22995f9148fa634e.jpg" alt><br>创建视图树、描述视图之间的约束、设置优先级、设置视图内容，Layout Engine计算出视图位置、尺寸，绘制出对应的图层。</p><p>Auto Layout布局过程涉及延迟机制，并非一有约束更新就马上进行布局重绘，当有约束更改时，系统的默认做法是延迟更新，目的是实现批量更改约束、绘制视图，避免频繁遍历视图层级，优化性能。当更新约束太慢影响到后序代码逻辑，也可强制马上更新。</p><p><img src="https://upload-images.jianshu.io/upload_images/696463-13cb1bc293287cf9.jpg" alt></p><ul><li>App启动后开启RunLoop，循环检测图层树中是否存在约束变化；</li><li>当发生Constrints Change（直接or间接设置、更新、移除约束）,RunLoop检测到约束变化；</li><li>RunLoop发现约束变化后，就会进入Deferred Layout阶段，视图的位置、尺寸值会在这个过程计算，设置到对应视图上，并绘制出来；</li><li>执行完一轮布局，RunLoop会继续检查视图树的约束更新情况，当再次发现约束更新，则执行新一轮布局……</li></ul><h4 id="VFL"><a href="#VFL" class="headerlink" title="VFL"></a>VFL</h4><p>略<br>官方文档<br><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html#//apple_ref/doc/uid/TP40010853-CH27-SW1</a></p><h3 id="约束库使用建议"><a href="#约束库使用建议" class="headerlink" title="约束库使用建议"></a>约束库使用建议</h3><p>使用 <a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry</a> 来进行代码控制布局约束。</p><blockquote><p>参考连接：<br><a href="http://macdev.io/ebook/autoLayout.html" target="_blank" rel="noopener">http://macdev.io/ebook/autoLayout.html</a><br><a href="https://juejin.im/post/5b1ea5046fb9a01e2b2cc4a7" target="_blank" rel="noopener">https://juejin.im/post/5b1ea5046fb9a01e2b2cc4a7</a>  </p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;AutoLayout介绍&quot;&gt;&lt;a href=&quot;#AutoLayout介绍&quot; class=&quot;headerlink&quot; title=&quot;AutoLayout介绍&quot;&gt;&lt;/a&gt;AutoLayout介绍&lt;/h3&gt;&lt;p&gt;Auto Layout 是苹果公司在iOS6发布的界面布局技术，为了适配不同大小屏幕及屏幕变化而推出的一种技术方案，旨在实现一次编写布局界面UI，自动适应所有屏幕布局，并随着iOS SDK的迭代逐步完善了各种布局API、提供多种使用Auto Layout的布局方式。实际上Auto Layout算法本身并非有Apple发明，Auto Layout源于Cassary约束解析工具包。该算法由Alan Borning、Kim Marriott、Peter Stuckey、Yi Xiao于1997年发布，该算法的主要思想是：将基于约束系统的布局规则（本质上是表示视图布局关系的线性方程组）转化为表示规则的视图几何参数。&lt;/p&gt;
&lt;h3 id=&quot;传统的布局&quot;&gt;&lt;a href=&quot;#传统的布局&quot; class=&quot;headerlink&quot; title=&quot;传统的布局&quot;&gt;&lt;/a&gt;传统的布局&lt;/h3&gt;&lt;h4 id=&quot;frame-布局&quot;&gt;&lt;a href=&quot;#frame-布局&quot; class=&quot;headerlink&quot; title=&quot;frame 布局&quot;&gt;&lt;/a&gt;frame 布局&lt;/h4&gt;&lt;p&gt;传统的布局方式是基于Frame来做UI控件的界面布局的,即设置控件在父视图中的起始坐标点Origin(x,y)和控件的大小Size(width,height)，为了精确，我们必须计算每个视图的frame。但布局一旦发生变化，相关frame都需要重新计算。然后这些计算都需要不断的手动动态的去计算，导致一旦有变化，就会需要去维护和调试。&lt;/p&gt;
&lt;h4 id=&quot;自动缩放（auto-resizing）&quot;&gt;&lt;a href=&quot;#自动缩放（auto-resizing）&quot; class=&quot;headerlink&quot; title=&quot;自动缩放（auto resizing）&quot;&gt;&lt;/a&gt;自动缩放（auto resizing）&lt;/h4&gt;&lt;p&gt;自动缩放的出现在一定程度上减轻了我们的负担。自动缩放规定父视图的frame变化时，视图的frame如何应对。如此一来，简化了布局响应外部变化所需的工作。但是他仅能应对外部父布局的变化，自身大小的变化则无法进行处理。&lt;/p&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（五）</title>
    <link href="http://www.wxtlife.com/2018/08/27/osx-dev-summary-5/"/>
    <id>http://www.wxtlife.com/2018/08/27/osx-dev-summary-5/</id>
    <published>2018-08-27T11:52:08.000Z</published>
    <updated>2018-08-27T11:58:05.169Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3><h3 id="TableView"><a href="#TableView" class="headerlink" title="TableView"></a>TableView</h3><p>在 OSX 中有一些列表的需求，这时候需要使用 OSX 中 TableView 来实现，但是这个 TableView 与 Android的 ListView 不太一样。使用还是比较复杂的。下面做一个简单的介绍，</p><h4 id="TableView-的使用"><a href="#TableView-的使用" class="headerlink" title="TableView 的使用"></a>TableView 的使用</h4><ol><li><p>首先需要在布局文件中，拖出一个TableView，并且添加相应的每列的数据源，主要是 使用 <code>TableCellView</code>， 里面默认的控件有一个<code>TextFiled</code>和一个<code>ImageView</code>,如果需要其他控件则需要自己进行自定义进行实现，下一小节会说到。</p></li><li><p>需要对 TableView 设置一个数据源，需要实现 <code>NSTableViewDataSource</code>接口, 并对 <code>TableView</code> 设置数据源，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tableView.dataSource = self</span><br><span class="line"></span><br><span class="line">extension MainView: NSTableViewDataSource &#123;</span><br><span class="line">    func numberOfRows(in tableView: NSTableView) -&gt; Int &#123;</span><br><span class="line">        return dataSources.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对每行的数据进行渲染处理，设置<code>delegate</code>和<code>target</code>代理，并实现 <code>NSTableViewDelegate</code>接口中如下方法 </p></li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tableView.delegate = self</span><br><span class="line">tableView.target = self</span><br></pre></td></tr></table></figure><p>下面为实现<code>NSTableViewDelegate</code>接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">extension MainView: NSTableViewDelegate &#123;</span><br><span class="line">    fileprivate enum CellIdentifiers &#123;</span><br><span class="line">        static let avatarImgCell = NSUserInterfaceItemIdentifier(&quot;image&quot;)</span><br><span class="line">        static let nickNameCell = NSUserInterfaceItemIdentifier(&quot;name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -&gt; NSView? &#123;</span><br><span class="line">        let item = dataSouece[row]</span><br><span class="line">        // 图片的资源</span><br><span class="line">        var image: NSImage?</span><br><span class="line">        //名称</span><br><span class="line">        var nickName: String = &quot;&quot;</span><br><span class="line">        var cellIdentifier: NSUserInterfaceItemIdentifier = CellIdentifiers.nickNameCell</span><br><span class="line">        if tableColumn == tableView.tableColumns[0] &#123;</span><br><span class="line">            image = #imageLiteral(resourceName: &quot;member_avatar&quot;)</span><br><span class="line">            cellIdentifier = CellIdentifiers.avatarImgCell</span><br><span class="line">        &#125; else if tableColumn == tableView.tableColumns[1] &#123;</span><br><span class="line">            nickName = item.nickName</span><br><span class="line">            cellIdentifier = CellIdentifiers.nickNameCell</span><br><span class="line">        &#125;</span><br><span class="line">        // 通过 NSUserInterfaceItemIdentifier 构建每一个 CellView </span><br><span class="line">        let view = tableView.makeView(withIdentifier: cellIdentifier, owner: nil)</span><br><span class="line">        if let cellItem = view as? NSTableCellView &#123;</span><br><span class="line">            // 对 CellView 中默认控件进行设置每个资源</span><br><span class="line">            cellItem.textField?.stringValue = nickName</span><br><span class="line">            cellItem.imageView?.image = image</span><br><span class="line">            return cellItem </span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的方法可以对基本的 TableView 进行渲染处理，可以看到 <code>NSTableCellView</code> 类中也只有默认 <code>textFiled</code> 与 <code>NSImageView</code> 控件，如果需要在一个<code>NSTableCellView</code>中有两个控件，或者有其他的控件如：NSButton等，则目前是无法完成的，那接下来就介绍下 <code>NSTableCellView</code>的自定义操作。</p><h4 id="TableView-中-TableCellView的自定义"><a href="#TableView-中-TableCellView的自定义" class="headerlink" title="TableView 中 TableCellView的自定义"></a>TableView 中 TableCellView的自定义</h4><ol><li>自定义<code>NSTableCellView</code>，首先先创建一个<code>CustomerTableViewCell</code>类，其继承自<code>NSTableCellView</code>,</li><li>其次主要在 xib 或者 storyboard 的 <code>TableView</code> 中 <code>NSTableCellView</code> 添加新的控件，或者移除掉原来的，添加新的控件进去，并设置相应的约束，与普通 View 操作一致的。最后将自定义的<code>NSTableCellView</code>的类名指定为自定义的类名。</li><li>将新添加的控件拖到<code>CustomerTableViewCell</code>中连线，这样 <code>CustomerTableViewCell</code>就可以控制自定义添加的控件了。</li><li>在上面的TableView 回调中设置相应的值。</li></ol><p>我们拿上面的例子来改造下，</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomerNSTableCellView</span>: <span class="title">NSTableCellView</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加了一个 age 的label 在同一个CellView中</span></span><br><span class="line">    <span class="meta">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> ageLabel: <span class="type">NSTextField!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(frame frameRect: <span class="type">NSRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frameRect)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">awakeFromNib</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.awakeFromNib()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MainView</span>: <span class="title">NSTableViewDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int)</span></span> -&gt; <span class="type">NSView?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> item = dataSouece[row]</span><br><span class="line">        <span class="comment">// 图片的资源</span></span><br><span class="line">        <span class="keyword">var</span> image: <span class="type">NSImage?</span></span><br><span class="line">        <span class="comment">//名称</span></span><br><span class="line">        <span class="keyword">var</span> nickName: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">        <span class="keyword">var</span> age : <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> cellIdentifier: <span class="type">NSUserInterfaceItemIdentifier</span> = <span class="type">CellIdentifiers</span>.nickNameCell</span><br><span class="line">        <span class="keyword">if</span> tableColumn == tableView.tableColumns[<span class="number">0</span>] &#123;</span><br><span class="line">            image = #imageLiteral(resourceName: <span class="string">"member_avatar"</span>)</span><br><span class="line">            cellIdentifier = <span class="type">CellIdentifiers</span>.avatarImgCell</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> tableColumn == tableView.tableColumns[<span class="number">1</span>] &#123;</span><br><span class="line">            nickName = item.nickName</span><br><span class="line">            age = item.age</span><br><span class="line">            cellIdentifier = <span class="type">CellIdentifiers</span>.nickNameCell</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通过 NSUserInterfaceItemIdentifier 构建每一个 CellView </span></span><br><span class="line">        <span class="keyword">let</span> view = tableView.makeView(withIdentifier: cellIdentifier, owner: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> cellItem = view <span class="keyword">as</span>? <span class="type">NSTableCellView</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> cellItem <span class="keyword">is</span> <span class="type">CustomerNSTableCellView</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> userCellItem  = cellItem <span class="keyword">as</span>! <span class="type">CustomerNSTableCellView</span></span><br><span class="line">                userCellItem.ageLabel.stringValue = age</span><br><span class="line">                userCellItem.textField?.stringValue = nickName</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 对 CellView 中默认控件进行设置每个资源</span></span><br><span class="line">                cellItem.textField?.stringValue = nickName <span class="comment">// 这里默认的Cell里没有则控件会为空。</span></span><br><span class="line">                cellItem.imageView?.image = image</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cellItem </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此可以在每个 <code>NSTableCellView</code>中进行任意的自定义了，实现自己想要实现的功能。</p><h3 id="NSStoryboardSegue-的自定义"><a href="#NSStoryboardSegue-的自定义" class="headerlink" title="NSStoryboardSegue 的自定义"></a>NSStoryboardSegue 的自定义</h3><p><code>NSStoryboardSegue</code> 的功能是什么呢？官方文档是这样介绍的: <code>A transition or containment relationship between two scenes in a storyboard.</code>  也就是在多个 storyboard 或者 window 中进行的连线，这个连线可以定义一些功能，比如说<code>show</code>操作等等，比如我们点击一个按钮，打开（show）另外一个 window 则可以使用它进行连线操作后，这条线就是<code>NSStoryboardSegue</code>类型的。</p><p>那么为什么要自定义它呢？ 因为如果在 storyboard 中对某个控件连线使用 <code>NSStoryboardSegue</code> 后，如果在对该控件执行 <code>action</code> 操作时，<code>action</code>操作会不起作用，这点需要吐槽下苹果的设计了。如果要想再使用<code>NSStoryboardSegue</code>后还可以指定其他操作，则只能自定义 <code>NSStoryboardSegue</code>了。</p><p>在自定义中复写<code>perform()</code>方法，可以添加自定义的一些操作了。<br>如果一个项目中有多个需要自定义，可以使用<code>NSStoryboardSegue</code>中的<code>identifier</code>来区分不同的<code>NSStoryboardSegue</code>。<code>identifier</code> 是在每个每条连线<code>Segue</code>上设置，同时记得把类指定为我们定义的类型。</p><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class CustomerStoryboardSegue: NSStoryboardSegue &#123;</span><br><span class="line">    </span><br><span class="line">    override func perform() &#123;</span><br><span class="line">        super.perform()</span><br><span class="line">        // 下面则可以做其他的事情了。通过self.identifier 来区分不同的 Sugue,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;TableView&quot;&gt;&lt;a href=&quot;#TableView&quot; class=&quot;headerlink&quot; title=&quot;TableView&quot;&gt;&lt;/a&gt;TableView&lt;/h3&gt;&lt;p&gt;在 OSX 中有一些列表的需求，这时候需要使用 OSX 中 TableView 来实现，但是这个 TableView 与 Android的 ListView 不太一样。使用还是比较复杂的。下面做一个简单的介绍，&lt;/p&gt;
&lt;h4 id=&quot;TableView-的使用&quot;&gt;&lt;a href=&quot;#TableView-的使用&quot; class=&quot;headerlink&quot; title=&quot;TableView 的使用&quot;&gt;&lt;/a&gt;TableView 的使用&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先需要在布局文件中，拖出一个TableView，并且添加相应的每列的数据源，主要是 使用 &lt;code&gt;TableCellView&lt;/code&gt;， 里面默认的控件有一个&lt;code&gt;TextFiled&lt;/code&gt;和一个&lt;code&gt;ImageView&lt;/code&gt;,如果需要其他控件则需要自己进行自定义进行实现，下一小节会说到。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要对 TableView 设置一个数据源，需要实现 &lt;code&gt;NSTableViewDataSource&lt;/code&gt;接口, 并对 &lt;code&gt;TableView&lt;/code&gt; 设置数据源，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tableView.dataSource = self&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;extension MainView: NSTableViewDataSource &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func numberOfRows(in tableView: NSTableView) -&amp;gt; Int &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return dataSources.count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对每行的数据进行渲染处理，设置&lt;code&gt;delegate&lt;/code&gt;和&lt;code&gt;target&lt;/code&gt;代理，并实现 &lt;code&gt;NSTableViewDelegate&lt;/code&gt;接口中如下方法 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（四）</title>
    <link href="http://www.wxtlife.com/2018/08/19/osx-dev-summary-4/"/>
    <id>http://www.wxtlife.com/2018/08/19/osx-dev-summary-4/</id>
    <published>2018-08-19T14:04:25.000Z</published>
    <updated>2018-08-19T14:07:57.510Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3><h3 id="OSX-中Window中常用的一些属性"><a href="#OSX-中Window中常用的一些属性" class="headerlink" title="OSX 中Window中常用的一些属性"></a>OSX 中Window中常用的一些属性</h3><h4 id="1-applicationShouldTerminate"><a href="#1-applicationShouldTerminate" class="headerlink" title="1. applicationShouldTerminate"></a>1. applicationShouldTerminate</h4><p>在 AppDelegate 中，复写<code>applicationShouldTerminate</code>方法可以达到控制是否点击关闭按钮是否关闭应用的效果，其返回值<code>TerminateReply</code>有三个值，具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public enum TerminateReply : UInt &#123;</span><br><span class="line">    case terminateCancel // 取消掉关闭，等于点击无作用</span><br><span class="line">    case terminateNow   // 现在直接关闭</span><br><span class="line">    case terminateLater  // 暂且不关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在下面的返回值可根据一些条件进行判断，比如有些应用点击关闭按钮是仅将窗口关闭，并最小化应用不退出，则可以根据设置情况进行返回不同的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func applicationShouldTerminate(_ sender: NSApplication) -&gt; NSApplication.TerminateReply &#123;</span><br><span class="line">    return .terminateNow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-applicationShouldTerminateAfterLastWindowClosed"><a href="#2-applicationShouldTerminateAfterLastWindowClosed" class="headerlink" title="2. applicationShouldTerminateAfterLastWindowClosed"></a>2. applicationShouldTerminateAfterLastWindowClosed</h4><p>在 AppDelegate中 <code>applicationShouldTerminateAfterLastWindowClosed</code>中的作用为确认是否是等待所有窗口关闭后才关闭整个应用的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -&gt; Bool &#123;</span><br><span class="line">    return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a> <h4 id="3-NSWindow-windowShouldClose"><a href="#3-NSWindow-windowShouldClose" class="headerlink" title="3. NSWindow windowShouldClose"></a>3. NSWindow windowShouldClose</h4><p>在每个NSWindow中,有很多的NSWindowDelegate方法，其中<code>windowShouldClose</code>可以根据返回值控制是否可以关闭此窗口，比如有些情况我们的内容没保存，而直接点击<code>关闭</code>按钮时，可进行不关闭此窗口，而是进行提示，那么就可以通过此属性进行控制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func windowShouldClose(_ sender: NSWindow) -&gt; Bool &#123;</span><br><span class="line">    return false // window 不关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-NSWindow-单例"><a href="#4-NSWindow-单例" class="headerlink" title="4. NSWindow 单例"></a>4. NSWindow 单例</h4><p>在应用中经常会有很多的弹窗，但这些弹框是需要只弹一个的（未关闭多次点击不新建，显示原来的那个），这时候就需要设置Window的属性。具体如下：<br>选中 <code>目标window</code> 上的<code>Window Controller</code>然后在属性栏中选中<code>show the attributes inspector</code>即可看到<code>Presentation</code>,然后选则<code>single</code>即可，默认是<code>Multiple</code>。</p><h3 id="自定义控件属性"><a href="#自定义控件属性" class="headerlink" title="自定义控件属性"></a>自定义控件属性</h3><p>在 Android 中自定义View，可以自定义很多的属性，对控件进行设置，在 iOS/OSX 中同样存在对自定义控件添加属性的方法，具体为<code>IBInspectable</code>和<code>IBDesignable</code>两个属性，定义了此属性后，在XCode中设置了View为此类型后，可以有可视化的设置项，很是方便，具体可以参考这篇文章:<a href="https://zhangbuhuai.com/ibinspectable-and-ibdesignable/" target="_blank" rel="noopener">https://zhangbuhuai.com/ibinspectable-and-ibdesignable/</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;OSX-中Window中常用的一些属性&quot;&gt;&lt;a href=&quot;#OSX-中Window中常用的一些属性&quot; class=&quot;headerlink&quot; title=&quot;OSX 中Window中常用的一些属性&quot;&gt;&lt;/a&gt;OSX 中Window中常用的一些属性&lt;/h3&gt;&lt;h4 id=&quot;1-applicationShouldTerminate&quot;&gt;&lt;a href=&quot;#1-applicationShouldTerminate&quot; class=&quot;headerlink&quot; title=&quot;1. applicationShouldTerminate&quot;&gt;&lt;/a&gt;1. applicationShouldTerminate&lt;/h4&gt;&lt;p&gt;在 AppDelegate 中，复写&lt;code&gt;applicationShouldTerminate&lt;/code&gt;方法可以达到控制是否点击关闭按钮是否关闭应用的效果，其返回值&lt;code&gt;TerminateReply&lt;/code&gt;有三个值，具体如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public enum TerminateReply : UInt &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case terminateCancel // 取消掉关闭，等于点击无作用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case terminateNow   // 现在直接关闭&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    case terminateLater  // 暂且不关闭&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在下面的返回值可根据一些条件进行判断，比如有些应用点击关闭按钮是仅将窗口关闭，并最小化应用不退出，则可以根据设置情况进行返回不同的值。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func applicationShouldTerminate(_ sender: NSApplication) -&amp;gt; NSApplication.TerminateReply &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return .terminateNow&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-applicationShouldTerminateAfterLastWindowClosed&quot;&gt;&lt;a href=&quot;#2-applicationShouldTerminateAfterLastWindowClosed&quot; class=&quot;headerlink&quot; title=&quot;2. applicationShouldTerminateAfterLastWindowClosed&quot;&gt;&lt;/a&gt;2. applicationShouldTerminateAfterLastWindowClosed&lt;/h4&gt;&lt;p&gt;在 AppDelegate中 &lt;code&gt;applicationShouldTerminateAfterLastWindowClosed&lt;/code&gt;中的作用为确认是否是等待所有窗口关闭后才关闭整个应用的作用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -&amp;gt; Bool &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（三）</title>
    <link href="http://www.wxtlife.com/2018/08/12/osx-dev-summary-3/"/>
    <id>http://www.wxtlife.com/2018/08/12/osx-dev-summary-3/</id>
    <published>2018-08-12T15:51:41.000Z</published>
    <updated>2018-08-27T12:00:34.640Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3><h3 id="NSStackView"><a href="#NSStackView" class="headerlink" title="NSStackView"></a>NSStackView</h3><p>OSX 中 NSStackView  使用自动布局（系统的自动布局特性）来根据你的要求管理和对齐一组视图。可以设置为 水平方向，或者垂直方向。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.orientation = .horizontal //水平方向</span><br><span class="line">stackView.orientation = .vertical  //垂直方向</span><br></pre></td></tr></table></figure></p><h4 id="添加子view"><a href="#添加子view" class="headerlink" title="添加子view"></a>添加子view</h4><p>为stackView 中添加 子view的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stackView.addArrangedSubview(view)</span><br></pre></td></tr></table></figure></p><p><strong>注意： 由于stackView 是继承自 NSView， 所有也会有 <code>addSubview(view)</code> 的方法，但是调用此方法，不会自动扩大 stackView 的宽高，而导致新加的view 显示不出来。</strong></p><h4 id="移除子view"><a href="#移除子view" class="headerlink" title="移除子view"></a>移除子view</h4><p>移除子 View 采用如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.removeArrangedSubview(view) </span><br><span class="line">view.removeFromSuperview()</span><br></pre></td></tr></table></figure></p><p><strong>注意：子view从stackView移除后，还必须将子view从父view中移除</strong></p><a id="more"></a><h4 id="指定添加的每个View的间距"><a href="#指定添加的每个View的间距" class="headerlink" title="指定添加的每个View的间距"></a>指定添加的每个View的间距</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//指定每个添加的每个View间的间距</span><br><span class="line">stackView.spacing = 5</span><br><span class="line"></span><br><span class="line">// 在customerView 后设置space为10</span><br><span class="line">stackView.setCustomSpacing(10, customerView）</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：<br><a href="https://swift.gg/2016/03/31/ios9-uistackview-guide-swift/" target="_blank" rel="noopener">https://swift.gg/2016/03/31/ios9-uistackview-guide-swift/</a>  </p></blockquote><h3 id="OSX坐标系翻转"><a href="#OSX坐标系翻转" class="headerlink" title="OSX坐标系翻转"></a>OSX坐标系翻转</h3><p>这里为什么要说坐标系呢？ 因为在 iOS等其他移动设备上远点都左上角，而在OSX中坐标原点在左下角，这导致在有些 iOS 库想兼容到 OSX就要做很多的适配的问题。然而系统提供了坐标翻转的函数，可以很方便的将 OSX 坐标原点转化为 左上角，保持与iOS一致，在使用的NSView中复写如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isFlipped &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://www.macdev.io/ebook/nsview.html" target="_blank" rel="noopener">http://www.macdev.io/ebook/nsview.html</a></p><h3 id="Swift-倒序循环"><a href="#Swift-倒序循环" class="headerlink" title="Swift 倒序循环"></a>Swift 倒序循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in (0..&lt;3).reversed()</span><br><span class="line">//表示：2，1，0</span><br><span class="line"></span><br><span class="line">for i in stride(from:3, through:0, by:-1)  </span><br><span class="line">//表示3，2，1，0</span><br></pre></td></tr></table></figure><h3 id="NSWindow"><a href="#NSWindow" class="headerlink" title="NSWindow"></a>NSWindow</h3><h4 id="NSApp-keyWindow"><a href="#NSApp-keyWindow" class="headerlink" title="NSApp.keyWindow"></a>NSApp.keyWindow</h4><p>表示当前正在接受键盘事件的窗口，比如一个应用有多个窗口，当前窗口正在接受键盘事件或状态栏未灰掉的当前的窗口为 keyWindow, 官方文档对返回值解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The value of this property is nil when there is no window receiving keyboard events. </span><br><span class="line">The property might be nil because the app’s storyboard file has not yet finished loading or when the receiver is not active.</span><br></pre></td></tr></table></figure></p><p>也就是说如果如果没有窗口接收键盘事件或者storyboard文件还未加载完，或窗口未激活，将返回的都是 nil。</p><h4 id="NSApp-mainWindow"><a href="#NSApp-mainWindow" class="headerlink" title="NSApp.mainWindow"></a>NSApp.mainWindow</h4><p>表示一个应用程序的主Window，官方的返回值说明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The value in this property is nil when the app’s storyboard or nib file has not yet finished loading. It might also be nil when the app is inactive or hidden.</span><br></pre></td></tr></table></figure></p><p>当app的 storyboard 或者 xib文件未加载完成，或者当前窗口为未激活状态或者是隐藏状态时，将返回nil。</p><p><strong>注意： 所以项目中需要使用mainWindow 或者keyWinodw 时需要注意为空的情况。</strong></p><p><a href="https://zonble.net/archives/2010_08/1352.php" target="_blank" rel="noopener">https://zonble.net/archives/2010_08/1352.php</a></p><h4 id="window-窗口最小化"><a href="#window-窗口最小化" class="headerlink" title="window 窗口最小化"></a>window 窗口最小化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使当前的窗口最小化</span><br><span class="line">window.miniaturize(self)</span><br><span class="line">// 使当前的窗口恢复原来状态取消最小化</span><br><span class="line">window.deminiaturize(self)</span><br><span class="line">// 如果当前为最小化则最大化，如果当前为最大化则最小化，取反。</span><br><span class="line">window.toggleFullScreen(nil)</span><br><span class="line">// 判断是否为全屏的状态</span><br><span class="line">let isFullScreen = window.styleMask.contains(.fullScreen)</span><br></pre></td></tr></table></figure><h4 id="window-storyboard-代码加载"><a href="#window-storyboard-代码加载" class="headerlink" title="window storyboard 代码加载"></a>window storyboard 代码加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let mainStoryboard = NSStoryboard(name: NSStoryboard.Name(rawValue: &quot;main&quot;), bundle: nil)</span><br><span class="line">// 使用mainStoryboard自动连线控制的NSWindowController，</span><br><span class="line">let mainWindowController = mainStoryboard.instantiateInitialController() as! MainWindowController</span><br><span class="line">mainWindowController.showWindow(nil) // 显示出来。</span><br></pre></td></tr></table></figure><p>如果storyboard 不是我们默认启动，需要代码启动的化，上面需要我们自行定义一个NSWindow的子类<code>MainWindowController</code>，在初始化完成后强制转化为 <code>MainWindowController</code></p><p>如果已经有一个window启动，需要加载storyboard中的某个viewControl进行替换。可以使用下面的语句进行初始化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mainStoryboard = NSStoryboard(name: NSStoryboard.Name(rawValue: &quot;main&quot;), bundle: nil)</span><br><span class="line">//得到指定的storyboard中指定的ViewController。</span><br><span class="line">let mainViewController = mainStoryboard.instantiateController(withIdentifier: NSStoryboard.SceneIdentifier(rawValue: &quot;InMeetingViewController&quot;)) as? NSViewController</span><br><span class="line">// 将新创建的viewController 赋值给已经存在的Window中的contentViewController。</span><br><span class="line">otherWindowController.contentViewController = mainViewController</span><br></pre></td></tr></table></figure></p><h3 id="objc-setAssociatedObject-objc-getAssociatedObject"><a href="#objc-setAssociatedObject-objc-getAssociatedObject" class="headerlink" title="objc_setAssociatedObject/objc_getAssociatedObject"></a>objc_setAssociatedObject/objc_getAssociatedObject</h3><p>这两个方式是oc中方法，主要功能是什么呢？。在 oc 中可以使用 <code>Category</code>可以对一些系统类进行添加方法，相当于 Swift 中的 <code>extension</code>的概念，但是我们常用有需求希望能够对一个类中添加一个属性，经常是很难弄，但是 oc 就很好的提供了一个方法 <code>objc_setAssociatedObject</code> 来对一个类进行属性的添加扩展。这是一个运行时修改的库，<br>所以必须要先引入 <code>objc/runtime.h</code> </p><h4 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h4><p>具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// object 为需要添加属性的类</span><br><span class="line">// key 为保证对象级别唯一的常量</span><br><span class="line">// value 为object 对所添加对象的值</span><br><span class="line">// policy 为关联的策略。</span><br><span class="line">public func objc_setAssociatedObject(_ object: Any, _ key: UnsafeRawPointer, _ value: Any?, _ policy: objc_AssociationPolicy)</span><br></pre></td></tr></table></figure></p><p>关联的策略就像是在 oc 中自定义 property 的引用类型一样。具体对应的类型如下：</p><table><thead><tr><th>策略</th><th>等价属性</th><th>说明</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>@property (assign) or @property (unsafe_unretained)</td><td>弱引用关联对象 </td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>@property (strong, nonatomic)</td><td>强引用关联对象，且为非原子操作 </td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>@property (copy, nonatomic)</td><td>复制关联对象，且为非原子操作 </td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>@property (strong, atomic)</td><td>强引用关联对象，且为原子操作 </td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>@property (copy, atomic)</td><td>复制关联对象，且为原子操作 </td></tr></tbody></table><p>实例如下对 NSApp 添加一个属性值为test:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 执行一个对象变量，后面使用该对象的地址。</span><br><span class="line"> var keyMainString:UInt8 = 0</span><br><span class="line"> objc_setAssociatedObject(NSApplication.shared, &amp;keyMainString, &quot;test&quot;, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br></pre></td></tr></table></figure></p><h4 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h4><p>上面添加了相应的属性，下面则要获取添加的属性 <code>objc_getAssociatedObject</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let value = objc_getAssociatedObject(NSApplication.shared, &amp;keyMainString)</span><br><span class="line">// 如果上面进行了设置，那么这里将获得的值为“test”</span><br></pre></td></tr></table></figure></p><p>通过上面两个方法就可以对系统类添加一个任意的属性值，和获取系统类的添加的属性值，对了，<strong>如果要移除关联的对象，可以对上面设置的值重新设置为 nil 即可。</strong><br>当然还有一个 <code>objc_removeAssociatedObjects</code>,这样可以把某个对象所设置的所有关联属性全部移除掉，一般都不会这样做，避免引起其他异常。</p><blockquote><p>参考资料：<br><a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/</a><br><a href="https://www.jianshu.com/p/7f7255d4e76d" target="_blank" rel="noopener">https://www.jianshu.com/p/7f7255d4e76d</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;h3 id=&quot;NSStackView&quot;&gt;&lt;a href=&quot;#NSStackView&quot; class=&quot;headerlink&quot; title=&quot;NSStackView&quot;&gt;&lt;/a&gt;NSStackView&lt;/h3&gt;&lt;p&gt;OSX 中 NSStackView  使用自动布局（系统的自动布局特性）来根据你的要求管理和对齐一组视图。可以设置为 水平方向，或者垂直方向。如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stackView.orientation = .horizontal //水平方向&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stackView.orientation = .vertical  //垂直方向&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加子view&quot;&gt;&lt;a href=&quot;#添加子view&quot; class=&quot;headerlink&quot; title=&quot;添加子view&quot;&gt;&lt;/a&gt;添加子view&lt;/h4&gt;&lt;p&gt;为stackView 中添加 子view的方式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stackView.addArrangedSubview(view)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意： 由于stackView 是继承自 NSView， 所有也会有 &lt;code&gt;addSubview(view)&lt;/code&gt; 的方法，但是调用此方法，不会自动扩大 stackView 的宽高，而导致新加的view 显示不出来。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;移除子view&quot;&gt;&lt;a href=&quot;#移除子view&quot; class=&quot;headerlink&quot; title=&quot;移除子view&quot;&gt;&lt;/a&gt;移除子view&lt;/h4&gt;&lt;p&gt;移除子 View 采用如下方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stackView.removeArrangedSubview(view) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;view.removeFromSuperview()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：子view从stackView移除后，还必须将子view从父view中移除&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS UIWindow 覆盖 StatusBar</title>
    <link href="http://www.wxtlife.com/2018/08/05/iOS-UIWindow-overlay-StatusBar/"/>
    <id>http://www.wxtlife.com/2018/08/05/iOS-UIWindow-overlay-StatusBar/</id>
    <published>2018-08-05T14:38:07.000Z</published>
    <updated>2018-08-05T14:45:00.591Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>最近产品要做一个消息的通知，而且通知是覆盖在 StatusBar 上面的。如果是普通的 UIView 则肯定是不行的，因为 StatusBar 为系统全局性的视图，所以要想覆盖它，则必须为 Statusbar 类型的，那么也就是 UIWindow 了。</p><h3 id="UIWindow-的基础介绍"><a href="#UIWindow-的基础介绍" class="headerlink" title="UIWindow 的基础介绍"></a>UIWindow 的基础介绍</h3><ul><li>UIWindow是一种特殊的UIView,通常在一个app中至少会有一个UIWindow。</li><li>iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的View,最后将控制器的View添加到UIWindow上，于是控制器的View就显示在屏幕上了。</li><li>一个iOS程序之所以能显示在屏幕上，完全是因为它有UIWindow，也就是说，没有UIWindow就看不到任何UI界面。</li><li>状态栏和键盘都是特殊的UIWindow。</li></ul><blockquote><p>这里有三个重要的对象UIScreen，UIWindow，UIView。</p><ol><li>UIScreen对象识别物理屏幕连接到设备</li><li>UIWindow对象提供绘画支持给屏幕</li><li>UIView执行绘画，当窗口要显示内容的时候，UIView绘画出他们的内容并附加到窗口上。</li></ol></blockquote><a id="more"></a><h3 id="UIWindow-等级"><a href="#UIWindow-等级" class="headerlink" title="UIWindow 等级"></a>UIWindow 等级</h3><p>window等级，即window在z轴上的层级关系,默认是0。UIWindowLevel 本身是一个 CGFloat 类型,可以随意设置或进行加减，高等级会显示在低等级上面。系统给出了三种常用等级:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal;      0</span><br><span class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert;       2000</span><br><span class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar;   4000</span><br></pre></td></tr></table></figure></p><h3 id="初始化-UIWindow-覆盖-StatusBar"><a href="#初始化-UIWindow-覆盖-StatusBar" class="headerlink" title="初始化 UIWindow 覆盖 StatusBar"></a>初始化 UIWindow 覆盖 StatusBar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)initWindow &#123;</span><br><span class="line">  //初始化statusView,可在其上添加控件</span><br><span class="line">  CGRect statusBarFrame = [UIApplication sharedApplication].statusBarFrame;</span><br><span class="line">  stateWindow = [[UIWindow alloc] initWithFrame:statusBarFrame];</span><br><span class="line">  // 设置windowLevel为statusbar + 1 保证可以显示在statusbar上面</span><br><span class="line">  stateWindow.windowLevel = UIWindowLevelStatusBar + 1;</span><br><span class="line">  stateWindow.backgroundColor = [UIColor orangeColor];</span><br><span class="line">  stateWindow.userInteractionEnabled = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样创建的与 statusbar 大小一样的UIWindow 已经好了，默认创建好 这个UIWindow 则已经添加上去了，只是默认不显示，可以使用下面来控制显示和隐藏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.hidden = YES; </span><br><span class="line">window.hidden = NO;</span><br></pre></td></tr></table></figure></p><p>当然 UIwindow 还有个 <code>makeKeyAndVisible</code> 方法，这个方法会将新建的 UIWindow 设置为主窗口并显示，之后如果消失后，需要将原来的主窗口设置回来，不然会出现很多异常的问题，这里切记。</p><p><strong>注意：控制新添加的 UIWindow 使用 hidden 来控制。尽量不要使用 makeKeyAndVisible</strong></p><p>这里的 stateWindow 必须是私有变量或者全局变量，生命周期随所在控制器的生命周期。</p><h3 id="添加Label"><a href="#添加Label" class="headerlink" title="添加Label"></a>添加Label</h3><p>上面的 UIWindow 创建好了，那么要显示相关的提示文字，还需要添加 label，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">label = [[UILabel alloc] initWithFrame:stateWindow.frame];</span><br><span class="line">label.backgroundColor = [UIColor blackColor];</span><br><span class="line">label.textColor = [UIColor whiteColor];</span><br><span class="line">label.font=[UIFont systemFontOfSize:12];</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">[stateWindow addSubview:label];</span><br></pre></td></tr></table></figure></p><p>之后设置 label的文字即可进行对其内容控制。</p><h3 id="旋转问题处理"><a href="#旋转问题处理" class="headerlink" title="旋转问题处理"></a>旋转问题处理</h3><p>上面弄完基本上都完成，但是在旋转屏幕后，发现显示还是在原来的位置上，无法跟随系统的状态栏一起旋转。需要对 Window 设置空的UIViewController后才会跟着状态栏旋转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 需要设置一个空的ViewController 不然旋转屏幕后，不会跟着旋转坐标系</span><br><span class="line">stateWindow.rootViewController = [UIViewController new];</span><br></pre></td></tr></table></figure></p><p>旋转后，又发现了新的问题，在新建的 UIWindow 根据的是一开始时的状态长宽，但是旋转为横屏时，尺寸会发生变化，所以在每次显示 statusWindow 时重新设置下frame的大小，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGRect newFrame = CGRectMake(0, 0, [[UIScreen mainScreen] bounds].size.width, STATUSBAR_HEIGHT);</span><br><span class="line">stateWindow.frame = newFrame;</span><br><span class="line">label.frame = newFrame;</span><br></pre></td></tr></table></figure></p><p>这里不直接取 statusbar 的frame，因为在statusbar 隐藏时获取的长宽为0，所以上面设置时取值为宽度和statusbar的高度，高度在一开始进行获取保存进常量中。</p><blockquote><p>综上：对于显示覆盖 statusbar 的 UIWindow 已经完成啦，</p></blockquote><h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><p>当我们显示了之后一般需要在延迟几秒后进行隐藏，在 Android 中一般实用Handler进行，或者实用timer进行执行操作。那么 ios 中怎么实用呢? 请看如下方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//延迟 3s 后执行 hideStateMsg 方法。</span><br><span class="line"> [self performSelector:@selector(hideStateMsg) withObject:nil afterDelay:3.0];</span><br><span class="line"> </span><br><span class="line"> -(void)hideStateMsg &#123;</span><br><span class="line">  stateWindow.hidden = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然在执行之前可能还需要把之前的延时任务取消了，则有如下两种方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 取消 self 对象中所有的延迟任务。</span><br><span class="line">[NSObject cancelPreviousPerformRequestsWithTarget:self];</span><br><span class="line"></span><br><span class="line">// 取消指定的函数的延迟执行操作。</span><br><span class="line">[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(hideStateMsg) object:nil];</span><br></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过上面的一些问题处理解决，最终能够实现一个覆盖 Statusbar 的View，并且能够在指定时间后消失，达到消息提醒的功能。</p><blockquote><p>参考地址：<br><a href="https://www.cnblogs.com/CoderAlex/p/4762210.html" target="_blank" rel="noopener">https://www.cnblogs.com/CoderAlex/p/4762210.html</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近产品要做一个消息的通知，而且通知是覆盖在 StatusBar 上面的。如果是普通的 UIView 则肯定是不行的，因为 StatusBar 为系统全局性的视图，所以要想覆盖它，则必须为 Statusbar 类型的，那么也就是 UIWindow 了。&lt;/p&gt;
&lt;h3 id=&quot;UIWindow-的基础介绍&quot;&gt;&lt;a href=&quot;#UIWindow-的基础介绍&quot; class=&quot;headerlink&quot; title=&quot;UIWindow 的基础介绍&quot;&gt;&lt;/a&gt;UIWindow 的基础介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;UIWindow是一种特殊的UIView,通常在一个app中至少会有一个UIWindow。&lt;/li&gt;
&lt;li&gt;iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的View,最后将控制器的View添加到UIWindow上，于是控制器的View就显示在屏幕上了。&lt;/li&gt;
&lt;li&gt;一个iOS程序之所以能显示在屏幕上，完全是因为它有UIWindow，也就是说，没有UIWindow就看不到任何UI界面。&lt;/li&gt;
&lt;li&gt;状态栏和键盘都是特殊的UIWindow。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里有三个重要的对象UIScreen，UIWindow，UIView。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UIScreen对象识别物理屏幕连接到设备&lt;/li&gt;
&lt;li&gt;UIWindow对象提供绘画支持给屏幕&lt;/li&gt;
&lt;li&gt;UIView执行绘画，当窗口要显示内容的时候，UIView绘画出他们的内容并附加到窗口上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.wxtlife.com/categories/iOS/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="object-c" scheme="http://www.wxtlife.com/tags/object-c/"/>
    
      <category term="iOS" scheme="http://www.wxtlife.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OSX webview 与 native 通信简单介绍</title>
    <link href="http://www.wxtlife.com/2018/07/29/osx-webview-native-bridge/"/>
    <id>http://www.wxtlife.com/2018/07/29/osx-webview-native-bridge/</id>
    <published>2018-07-29T15:36:55.000Z</published>
    <updated>2018-07-29T15:44:26.851Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>在开发混合应用中，经常需要 js 与 webview 进行通信，那么官方也提供了一些方法进行消息处理，今天这里介绍一款开源库来更好的解决的 native 与 js 通信的问题，也就是 <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a></p><h3 id="基本配置使用"><a href="#基本配置使用" class="headerlink" title="基本配置使用"></a>基本配置使用</h3><ol><li>在 Podfile 文件中添加库稳健配置<code>pod &#39;WebViewJavascriptBridge&#39;, &#39;~&gt; 6.0&#39;</code>,然后执行<code>pod install</code></li><li><p>使 WebViewJavascriptBridge 初始化与 Webview 进行绑定 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let bridge: WebViewJavascriptBridge = WebViewJavascriptBridge.init(forWebView: webview)</span><br></pre></td></tr></table></figure></li><li><p>在js层中进行注册处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 将该方法写入 javascript 中</span><br><span class="line">function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">    if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">    if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">    window.WVJBCallbacks = [callback];</span><br><span class="line">    var WVJBIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    WVJBIframe.style.display = &apos;none&apos;;</span><br><span class="line">    WVJBIframe.src = &apos;https://__bridge_loaded__&apos;;</span><br><span class="line">    document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">    setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>经过上面的步骤，基本的搭建就完成了，下面就是要相互注册调用的函数，以及互相调用的方法。</p></li><li>native 层注册方法供 js 调用，以及 native 层调用的js方法。</li></ol><a id="more"></a><h3 id="注册及调用方法"><a href="#注册及调用方法" class="headerlink" title="注册及调用方法"></a>注册及调用方法</h3><ul><li>native 注册方法供 js 调用 （registerHandler）</li></ul><p>native拿到bridge对象后，即可对native的方法进行注册，以便供 js 调用。注册方也比较简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bridge.registerHandler(&quot;methodName&quot;) &#123; (jsCallData, responseCallback) in</span><br><span class="line">    // 通过jsCallData 来获取js层调用的方法。</span><br><span class="line">    print(&quot;jsCallData = &quot;, jsCallData)</span><br><span class="line">    let result = &quot;ok&quot;</span><br><span class="line">    // resonpseCallback 用来将处理的结果在返回给到 js 层</span><br><span class="line">    responseCallback(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>js 层注册方法供 native 调用 （registerHandler）</li></ul><p>调用 js 层前面注册的函数进行注册，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line">    bridge.registerHandler(&apos;methodName&apos;, function(data, responseCallback) &#123;</span><br><span class="line">            // data 为 native 调用的方法参数</span><br><span class="line">            log(&apos;ObjC called testJavascriptHandler with&apos;, data)</span><br><span class="line">            var responseData = &#123; &apos;Javascript Says&apos;:&apos;Right back atcha!&apos; &#125;</span><br><span class="line">            log(&apos;JS responding with&apos;, responseData)</span><br><span class="line">            // resonpsecallback 为js处理完告诉native 的结果</span><br><span class="line">            responseCallback(responseData)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的 native 注册供 js 调用的模式，与 js 注册供 native 调用的方法基本上是一样的，方法，参数，回调等都基本上一致。</p><ul><li><p>native 调用 js  层注册的方法 （callhandler）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bridge 为native 绑定后的 WebViewJavascriptBridge 对象</span><br><span class="line">// methodName 为js 注册的方法</span><br><span class="line">// data 为调用js的方法参数</span><br><span class="line">// callback 为 js 方法执行后的回调方法。</span><br><span class="line">bridge.callHandler(methodName, data: data, responseCallback: callback)</span><br></pre></td></tr></table></figure></li><li><p>js 调用 native 层注册的方法 （callHanlder）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line">    // data 构造调用native的参数</span><br><span class="line">    var data = &#123;&quot;action&quot;:&quot;connectstate&quot;,&quot;payload&quot;:&#123;&quot;isConnect&quot;: true&#125;&#125;</span><br><span class="line">    // methodName 为native 注册的方法。</span><br><span class="line">    bridge.callHandler(&apos;methodName&apos;, data, function(response) &#123;</span><br><span class="line">        // response 为native 回调的值</span><br><span class="line">        log(&apos;JS got response&apos;, response)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过上面的4个方法，已经把native 与 js 两端的互相注册及调用的讲完。整体上比较简单，两端的方法注册及调用都是互等性的，方法名、参数、回调都一样。理解起来也比较容易。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>主要的原理的通过 <code>function setupWebViewJavascriptBridge(callback) {}</code>方法里添加一个不显示的iframe view， 然后在native 层通过对注定的请求 url 进行拦截，解析出相应的参数。然后利用此特性进行 js 与 native 的互相通信。详细的可以参考文章：</p><blockquote><p>参数文章：<br><a href="https://www.jianshu.com/p/8bd6aeb719ff" target="_blank" rel="noopener">https://www.jianshu.com/p/8bd6aeb719ff</a><br><a href="https://www.jianshu.com/p/d45ce14278c7" target="_blank" rel="noopener">https://www.jianshu.com/p/d45ce14278c7</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;在开发混合应用中，经常需要 js 与 webview 进行通信，那么官方也提供了一些方法进行消息处理，今天这里介绍一款开源库来更好的解决的 native 与 js 通信的问题，也就是 &lt;a href=&quot;https://github.com/marcuswestin/WebViewJavascriptBridge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebViewJavascriptBridge&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;基本配置使用&quot;&gt;&lt;a href=&quot;#基本配置使用&quot; class=&quot;headerlink&quot; title=&quot;基本配置使用&quot;&gt;&lt;/a&gt;基本配置使用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在 Podfile 文件中添加库稳健配置&lt;code&gt;pod &amp;#39;WebViewJavascriptBridge&amp;#39;, &amp;#39;~&amp;gt; 6.0&amp;#39;&lt;/code&gt;,然后执行&lt;code&gt;pod install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使 WebViewJavascriptBridge 初始化与 Webview 进行绑定 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let bridge: WebViewJavascriptBridge = WebViewJavascriptBridge.init(forWebView: webview)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在js层中进行注册处理&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 将该方法写入 javascript 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function setupWebViewJavascriptBridge(callback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (window.WebViewJavascriptBridge) &amp;#123; return callback(WebViewJavascriptBridge); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (window.WVJBCallbacks) &amp;#123; return window.WVJBCallbacks.push(callback); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    window.WVJBCallbacks = [callback];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var WVJBIframe = document.createElement(&amp;apos;iframe&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WVJBIframe.style.display = &amp;apos;none&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WVJBIframe.src = &amp;apos;https://__bridge_loaded__&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    document.documentElement.appendChild(WVJBIframe);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(function() &amp;#123; document.documentElement.removeChild(WVJBIframe) &amp;#125;, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;经过上面的步骤，基本的搭建就完成了，下面就是要相互注册调用的函数，以及互相调用的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;native 层注册方法供 js 调用，以及 native 层调用的js方法。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（二）</title>
    <link href="http://www.wxtlife.com/2018/07/29/osx-dev-summary-2/"/>
    <id>http://www.wxtlife.com/2018/07/29/osx-dev-summary-2/</id>
    <published>2018-07-29T15:34:48.000Z</published>
    <updated>2018-07-29T15:40:43.472Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><h3 id="在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，"><a href="#在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，" class="headerlink" title="在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，"></a>在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，</h3><ul><li>1.启动沙盒<br>需要在APP需要启动沙盒具体为：<br>target -&gt; Capabilities -&gt; App Sandbox 将Outgoing Connenctions 沟选上。</li><li>2.在项目Info.Plist 中添加设置<br>添加<code>App Transport Security Settings</code> 设置<code>Allow Arbitrary Loads</code> 为 true</li></ul><h3 id="为OSX项目添加Podfile"><a href="#为OSX项目添加Podfile" class="headerlink" title="为OSX项目添加Podfile"></a>为OSX项目添加Podfile</h3><p>新建一个工程时，需要引用第三方库时，一般实用OPodfile 进行引用，初始化podfile，在项目根目录下执行 <code>pod init</code>， 之后产生 Podfile，然后在产生的文件中添加依赖，再在根目录下执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br><span class="line">pod install</span><br></pre></td></tr></table></figure></p><p>然后项目根目录下会产生<code>.xcworkspace</code> 的文件，这时需要将新建的工程关闭，然后使用双击<code>xcworkspace</code>来打开项目。后续添加新的库，只需执行 <code>pod install</code>即可。</p><h3 id="swift-引用-oc-库桥接"><a href="#swift-引用-oc-库桥接" class="headerlink" title="swift 引用 oc 库桥接"></a>swift 引用 oc 库桥接</h3><p>如果开发中使用swift 语言，而库还是用oc语言开发的，如要使用oc库则需要添加一个配置bridge文件并配置在xcode中。</p><ol><li>首先在项目文件名下面新建一个 .h 的文件，文件名一般为<code>项目名+bridge.h</code>,例如<code>TestDemo-Bridging-Header.h</code></li><li>在该 .h 的文件中添加引入 oc 库的头文件，例如<code>#import &lt;DevMateKit/DevMateKit.h&gt;</code></li><li>选中项目根目录，进入项目设置，选中 target 选项，找到<code>swift Compiler -General</code>,下面有项为：<code>Object-C Bridging Header</code>, 双击进入编辑状态，然后将前面新建的.h文件拖到编辑框内，路径会自动填充上（绝对路径），然后重新编译项目即可。</li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div id=&quot;vip-container&quot;&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一
      
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（一）</title>
    <link href="http://www.wxtlife.com/2018/07/22/osx-dev-summary-1/"/>
    <id>http://www.wxtlife.com/2018/07/22/osx-dev-summary-1/</id>
    <published>2018-07-22T09:33:41.000Z</published>
    <updated>2018-07-29T15:35:52.637Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>下面为最近使用swift 进行 OSX 开发中，对于一些知识点的总结与汇总，主要是跨行过来，很多内容都不太熟悉，所以这里进行一部分的记录与总结，方便日后的回顾与思考，后续有新的也会继续进行补充。</p><h3 id="swift-代码同步块"><a href="#swift-代码同步块" class="headerlink" title="swift 代码同步块"></a>swift 代码同步块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_sync_enter(Obj)</span><br><span class="line"> //code </span><br><span class="line">objc_sync_exit(Obj)</span><br></pre></td></tr></table></figure><p>在上面两句话中间的语句则为同步代码块，Obj 为锁的对象。类似Java中的 synchronized(Obj)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//代码块</span><br><span class="line">synchronized(Obj) &#123;</span><br><span class="line">    //cide </span><br><span class="line">&#125;</span><br><span class="line">// synchronized 用到方法上</span><br><span class="line">public void synchronized method() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/" target="_blank" rel="noopener">http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/</a></p><h3 id="swift-布局约束"><a href="#swift-布局约束" class="headerlink" title="swift 布局约束"></a>swift 布局约束</h3><p>1、在Xib或者StoryBoard中的view间的依赖，都正常但是无法按照我们预期的显示，这时需要检查 约束之间的优先级，通常这部分很容易导致View依赖出现错误，而很难排查。</p><p>2、在定义布局时，有图片控件ImageView的时候，默认指定了图片，这时相当于控件的大小是固定的，如果我们想让其铺满父view，设置了相应的约束，但是实际运行中不起作用</p><p>原因： ImageView已经有图片，所以默认其图片是固定大小了，也就意味着ImageView是固定的了，所以这时view不会跟随父view铺满全屏，想要以 ImageView 的大小铺满父View，则 ImageView 的优先级则应该要低一些。 在xib中选中相应的ImageView，在约束那找到 Content compression resistance priority,将其优先级进行降低，也就是视图越容易被压缩。</p><p>如果在其他需求中ImageView不想被压缩，想要拉伸，而是设置Content Hugging Priority</p><p>约束优先级: 在Autolayout中每个约束都有一个优先级, 优先级的范围是1 ~ 1000。创建一个约束，默认的优先级是最高的1000</p><p>下面是关于两种属性的解释说明：</p><a id="more"></a><p><strong>Content Hugging Priority:</strong> 该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸，默认是250。</p><p><strong>Content Compression Resistance Priority:</strong> 该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩，默认是750</p><p>下面是第二种解释说法：</p><p><strong>Content Hugging Priority：</strong> 直译成中文就是“内容拥抱优先级”，从字面意思上来看就是两个视图，谁的“内容拥抱优先级”高，谁就优先环绕其内容。稍后我们会根据一些示例进行介绍。</p><p><strong>Content Compression Resistance Priority：</strong> 该优先级直译成中文就是“内容压缩阻力优先级”。也就是视图的“内容压缩阻力优先级”越大，那么该视图中的内容越难被压缩。而该优先级小的视图，则内容优先被压缩。稍后我们也会通过相应的实例来看一下这个优先级的具体表现。</p><blockquote><p>参考链接:<br><a href="https://www.cnblogs.com/ludashi/p/7373051.html" target="_blank" rel="noopener">https://www.cnblogs.com/ludashi/p/7373051.html</a><br><a href="https://juejin.im/entry/58b3d97c8d6d810057f5b647" target="_blank" rel="noopener">https://juejin.im/entry/58b3d97c8d6d810057f5b647</a></p></blockquote><h3 id="osx中监听窗口大小及状态的变化"><a href="#osx中监听窗口大小及状态的变化" class="headerlink" title="osx中监听窗口大小及状态的变化"></a>osx中监听窗口大小及状态的变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(self.enterFullScreen), name: NSWindow.willEnterFullScreenNotification, object: nil)</span><br><span class="line"></span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(self.exitFullScreen), name: NSWindow.willExitFullScreenNotification, object: nil)</span><br><span class="line"></span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(self.didResizeChanged), name: NSWindow.didResizeNotification, object: nil)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@objc dynamic func enterFullScreen() &#123;</span><br><span class="line">    print(&quot;窗口将进入全屏&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@objc dynamic func exitFullScreen() &#123;</span><br><span class="line">    print(&quot;窗口将退出全屏&quot;)   </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@objc dynamic func didResizeChanged() &#123;</span><br><span class="line">    print(&quot;窗口大小变化&quot;)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取消监听：</span><br><span class="line">NotificationCenter.default.removeObserver(self)</span><br></pre></td></tr></table></figure><p>当然在还有其他的 NSWindow.***Notification 类型的通知，按需监听，并进行处理。</p><h3 id="使用-Masonry-如何删掉约束"><a href="#使用-Masonry-如何删掉约束" class="headerlink" title="使用 Masonry 如何删掉约束"></a>使用 Masonry 如何删掉约束</h3><p>Masonry 是在ios与osx开发中 autolayout 进行动态布局约束不可或缺的一个好帮手，可以描述为可视化的语言去描述约束的情况。对于开发非常的方便。</p><p>对于删除动态约束可使用 MASConstraint 的 uninstall 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var constraint: MASConstraint? </span><br><span class="line"></span><br><span class="line">// 设置约束，并赋值</span><br><span class="line">view.remakeConstraints&#123; maker in </span><br><span class="line">  constraint = maker?.width.equal()(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除约束</span><br><span class="line">constraint?.uninstall()</span><br><span class="line"></span><br><span class="line">//当然也可以使用 install添加约束</span><br><span class="line">constraint?.install()</span><br></pre></td></tr></table></figure></p><h3 id="RxSwift-中debounce-与-throttle-的区别"><a href="#RxSwift-中debounce-与-throttle-的区别" class="headerlink" title="RxSwift 中debounce 与 throttle 的区别"></a>RxSwift 中debounce 与 throttle 的区别</h3><p>下面是官方的意思</p><ul><li>Throttle: the original function be called at most once per specified period.</li><li>Debounce: the original function be called after the caller stops calling the decorated function after a specified period.</li></ul><p>下面为我个人的理解，及使用场景</p><ul><li>throttle  :  一般会指定一个时间值，在这个时间里，最多只执行一次，比如常见开发中避免狂点 button，需要对点击时间进行控制的， 就可以使用来指定</li><li>debounce： 指定的一个时间值内，没有新消息触发，则返回最后一个值，如果指定事件内有新消息触发，则取消旧消息，直到没有新消息来在执行后面的操作，这种应用场景在，数据不断变化时，可以对中间的数据变化不做处理，直到指定时间不再变化时在进行以最后一次的数据进行刷新。</li></ul><p>参考链接: <a href="https://medium.com/@dkhuong291/throttle-vs-debounce-in-rxswift-86f8b303d5d4" target="_blank" rel="noopener">https://medium.com/@dkhuong291/throttle-vs-debounce-in-rxswift-86f8b303d5d4</a></p><h3 id="OSX-上NSTextField-支持复制粘贴"><a href="#OSX-上NSTextField-支持复制粘贴" class="headerlink" title="OSX 上NSTextField 支持复制粘贴"></a>OSX 上NSTextField 支持复制粘贴</h3><p>在mac os 上开发，去掉了应用的edit menu后导致后续的 NSTextField 无法直接使用 command + c或者 command + v 进行复制粘贴。所以想要支持的化，需要复写 performKeyEquivalent 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private let commandKey = NSEvent.ModifierFlags.command.rawValue</span><br><span class="line">private let commandShiftKey = NSEvent.ModifierFlags.command.rawValue | NSEvent.ModifierFlags.shift.rawValue</span><br><span class="line">// 在 NSTextField 子类中进行复写 performKeyEquivalent 方法。    </span><br><span class="line">override func performKeyEquivalent(with event: NSEvent) -&gt; Bool &#123;</span><br><span class="line">        if event.type == NSEvent.EventType.keyDown &#123;</span><br><span class="line">            if (event.modifierFlags.rawValue &amp; NSEvent.ModifierFlags.deviceIndependentFlagsMask.rawValue) == commandKey &#123;</span><br><span class="line">                switch event.charactersIgnoringModifiers! &#123;</span><br><span class="line">                case &quot;x&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSText.cut(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;c&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSText.copy(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;v&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSText.paste(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;z&quot;:</span><br><span class="line">                    if NSApp.sendAction(Selector((&quot;undo:&quot;)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;a&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSResponder.selectAll(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                default:</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (event.modifierFlags.rawValue &amp; NSEvent.ModifierFlags.deviceIndependentFlagsMask.rawValue) == commandShiftKey &#123;</span><br><span class="line">                if event.charactersIgnoringModifiers == &quot;Z&quot; &#123;</span><br><span class="line">                    if NSApp.sendAction(Selector((&quot;redo:&quot;)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.performKeyEquivalent(with: event)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加上上面的复写方法后，即可对NSTextField的控件支持复制粘贴快捷键操作。</p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/970707/cocoa-keyboard-shortcuts-in-dialog-without-an-edit-menu/3746058" target="_blank" rel="noopener">https://stackoverflow.com/questions/970707/cocoa-keyboard-shortcuts-in-dialog-without-an-edit-menu/3746058</a></p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;下面为最近使用swift 进行 OSX 开发中，对于一些知识点的总结与汇总，主要是跨行过来，很多内容都不太熟悉，所以这里进行一部分的记录与总结，方便日后的回顾与思考，后续有新的也会继续进行补充。&lt;/p&gt;
&lt;h3 id=&quot;swift-代码同步块&quot;&gt;&lt;a href=&quot;#swift-代码同步块&quot; class=&quot;headerlink&quot; title=&quot;swift 代码同步块&quot;&gt;&lt;/a&gt;swift 代码同步块&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_sync_enter(Obj)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; //code &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_sync_exit(Obj)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面两句话中间的语句则为同步代码块，Obj 为锁的对象。类似Java中的 synchronized(Obj)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//代码块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;synchronized(Obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //cide &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// synchronized 用到方法上&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void synchronized method() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;swift-布局约束&quot;&gt;&lt;a href=&quot;#swift-布局约束&quot; class=&quot;headerlink&quot; title=&quot;swift 布局约束&quot;&gt;&lt;/a&gt;swift 布局约束&lt;/h3&gt;&lt;p&gt;1、在Xib或者StoryBoard中的view间的依赖，都正常但是无法按照我们预期的显示，这时需要检查 约束之间的优先级，通常这部分很容易导致View依赖出现错误，而很难排查。&lt;/p&gt;
&lt;p&gt;2、在定义布局时，有图片控件ImageView的时候，默认指定了图片，这时相当于控件的大小是固定的，如果我们想让其铺满父view，设置了相应的约束，但是实际运行中不起作用&lt;/p&gt;
&lt;p&gt;原因： ImageView已经有图片，所以默认其图片是固定大小了，也就意味着ImageView是固定的了，所以这时view不会跟随父view铺满全屏，想要以 ImageView 的大小铺满父View，则 ImageView 的优先级则应该要低一些。 在xib中选中相应的ImageView，在约束那找到 Content compression resistance priority,将其优先级进行降低，也就是视图越容易被压缩。&lt;/p&gt;
&lt;p&gt;如果在其他需求中ImageView不想被压缩，想要拉伸，而是设置Content Hugging Priority&lt;/p&gt;
&lt;p&gt;约束优先级: 在Autolayout中每个约束都有一个优先级, 优先级的范围是1 ~ 1000。创建一个约束，默认的优先级是最高的1000&lt;/p&gt;
&lt;p&gt;下面是关于两种属性的解释说明：&lt;/p&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>比 cat 更好用的命令了解一下？</title>
    <link href="http://www.wxtlife.com/2018/05/20/bat-tool/"/>
    <id>http://www.wxtlife.com/2018/05/20/bat-tool/</id>
    <published>2018-05-20T13:50:58.000Z</published>
    <updated>2018-05-20T14:32:08.629Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>作为程序员经常使用命令行来进行一些文件的处理，比如常见的：<code>git</code>， <code>vim</code> ，以及不同语言下的一些命令等。那么这么多的命令中，相信你肯定有用过<code>cat</code>命令用来查看文件的内容，但是这个命令仅仅只能将文本展示出来，并不会很好的辅助我们阅读和理解里面的内容，尤其是文件中内容为 代码时，看起来就特别的痛苦了。那么这篇文章就要介绍更好命令来替代 <code>cat</code>命令，它就是<code>bat</code>命令。（不是windows中的那个脚本哟）</p><h3 id="bat介绍"><a href="#bat介绍" class="headerlink" title="bat介绍"></a>bat介绍</h3><p><code>bat</code> 是一个语法高亮显示和<code>Git</code>集成的<code>cat</code>高级版本，也就是说，<code>bat</code> 有 <code>cat</code>的所有功能，且已经集成了代码高亮，和<code>git</code>版本管理的工具，并且会对过长的文件进行自动分页，不会像 <code>cat</code> 一样全部一次打印,先来看张效果图：</p><p><img src="https://camo.githubusercontent.com/9d3d89364f2cc83ace8f29646a6236bc15ea1da0/68747470733a2f2f696d6775722e636f6d2f724773646e44652e706e67" alt></p><a id="more"></a><h3 id="bat安装"><a href="#bat安装" class="headerlink" title="bat安装"></a>bat安装</h3><p>安装的方法也是超级的简单，具体安装如下：</p><ul><li>Linux 上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://aur.archlinux.org/bat.git</span><br><span class="line">cd bat</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><ul><li>MACOS 上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install bat</span><br></pre></td></tr></table></figure></li></ul><p>安装完成后，输入<code>bat -help</code> 看下是否会出现相关的提示信息，来确认是否安装成功。</p><h3 id="bat使用"><a href="#bat使用" class="headerlink" title="bat使用"></a>bat使用</h3><p>使用与 <code>cat</code> 类似，在 <code>bat</code> 后面紧跟文件 就行了， 也可以同时打开过个，但结果是以一个接一个展示出来。</p><p>如打开一个有 <code>git</code> 管理的文件，会展示出文件中添加与删除的部分，如下图所示：<br><img src="https://camo.githubusercontent.com/67e44f4a68150325f74b3a46820b7473ff7b91a6/68747470733a2f2f692e696d6775722e636f6d2f326c53573452452e706e67" alt></p><p>如果需要制定文件中高亮的语言，可以使用 <code>-l</code> 参数来制定语言，例如：<br><code>bat  ./test.json -l json</code> 则指定文件中高亮为 json 模式，当然不指定也没有问题，默认会自动识别。<br>总之使用还是比较简单，一点都不复杂。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果有了这个命令，我想一般都不会再用 <code>cat</code>命令了，但每次敲命令都习惯使用 <code>cat</code> 了， 那么建议将 cat 命令使用 <code>alias cat= &#39;bat&#39;</code> 将其指定为 <code>bat</code> 这样就可以使用<code>cat</code> 命令，而达到 <code>bat</code> 的使用效果。</p><p>希望大家能够喜欢这篇文章，喜欢就分享出去吧。 如果你有更好的命令，欢迎留言交流。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;作为程序员经常使用命令行来进行一些文件的处理，比如常见的：&lt;code&gt;git&lt;/code&gt;， &lt;code&gt;vim&lt;/code&gt; ，以及不同语言下的一些命令等。那么这么多的命令中，相信你肯定有用过&lt;code&gt;cat&lt;/code&gt;命令用来查看文件的内容，但是这个命令仅仅只能将文本展示出来，并不会很好的辅助我们阅读和理解里面的内容，尤其是文件中内容为 代码时，看起来就特别的痛苦了。那么这篇文章就要介绍更好命令来替代 &lt;code&gt;cat&lt;/code&gt;命令，它就是&lt;code&gt;bat&lt;/code&gt;命令。（不是windows中的那个脚本哟）&lt;/p&gt;
&lt;h3 id=&quot;bat介绍&quot;&gt;&lt;a href=&quot;#bat介绍&quot; class=&quot;headerlink&quot; title=&quot;bat介绍&quot;&gt;&lt;/a&gt;bat介绍&lt;/h3&gt;&lt;p&gt;&lt;code&gt;bat&lt;/code&gt; 是一个语法高亮显示和&lt;code&gt;Git&lt;/code&gt;集成的&lt;code&gt;cat&lt;/code&gt;高级版本，也就是说，&lt;code&gt;bat&lt;/code&gt; 有 &lt;code&gt;cat&lt;/code&gt;的所有功能，且已经集成了代码高亮，和&lt;code&gt;git&lt;/code&gt;版本管理的工具，并且会对过长的文件进行自动分页，不会像 &lt;code&gt;cat&lt;/code&gt; 一样全部一次打印,先来看张效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/9d3d89364f2cc83ace8f29646a6236bc15ea1da0/68747470733a2f2f696d6775722e636f6d2f724773646e44652e706e67&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>【工具】github 插件源码浏览利器 Insight</title>
    <link href="http://www.wxtlife.com/2018/04/02/chrome-insight/"/>
    <id>http://www.wxtlife.com/2018/04/02/chrome-insight/</id>
    <published>2018-04-02T14:23:38.000Z</published>
    <updated>2018-05-20T13:56:19.798Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在之前的一篇文章中<a href="http://www.wxtlife.com/2017/09/27/developers-need-tools/">《开发人员必备的开发利器》</a>有介绍过一款Chrome插件，名为 Octotree ，它可以以树形结构的样式将源代码源文件展示出来，方便我们查看跳转等。但是有时候在github上看源码时，可能需要进行方法的跳转，查看具体实现，更或者找到某个方法或者类的调用方，那么有没有既有 Octotree 功能又能实现上面的功能呢，那当然是有的，它就是今天要介绍的主角 <code>insight.io</code> </p><h3 id="insight-io-使用"><a href="#insight-io-使用" class="headerlink" title="insight.io 使用"></a>insight.io 使用</h3><p>insight.io 也是一个Chrome 插件， 安装也就直接在Chrome插件中心搜索安装就行了，这里就不多描述。<br>安装好后，在首次安装上后需要使用github账号进行授权登录，之后会进行一些操作相关的提示。<br>整体的界面如下所示</p><p><img src="../img/insight/insight_view.png" alt="insight"></p><p>整体的风格还是很简约，清新的，很是喜欢。</p><p>这样上面树形结构的源代码已经展示出来了。</p><p>但在使用的时候有几点需要注意，此插件不是所有的github 项目都支持，你可以查看页面中间有个提示信息，如果为<code>ready</code> 则可以直接使用，如果提示<code>not indexed</code> 则说明未包含此项目，需要你手动提交，点击即可，之后会进行索引，成功后会邮件通知你，时间大约在半个小时以内，大的项目可能会比较久（本人尝试的时间不到5分钟就OK了），但是不能直接提交fork出来的仓库，fork的仓库可以通过邮件联系对方，可能需要pro付费版本支持。</p><a id="more"></a><h3 id="重点功能"><a href="#重点功能" class="headerlink" title="重点功能"></a>重点功能</h3><h4 id="文件类结构，"><a href="#文件类结构，" class="headerlink" title="文件类结构，"></a>文件类结构，</h4><p>客户以像ide一样展示出当前类的方法名及变量名，并且点击跳到相应行，很是方便，完全就像个ide一样。<br>如下图所示：</p><p><img src="http://www.imgeek.org/uploads/article/20170214/a2a38c0d8fc80e7fd2b0ba8fe8bc8f18.gif" alt></p><h4 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h4><p>基于对源代码的语意分析，在搜索时开发者可以直接按照类名，方法名，变量名等搜索，并且Codatlas提供自动补全功能。</p><p><img src="http://www.imgeek.org/uploads/article/20170214/634f52fba750388bc8a82a3419cc1ff6.gif" alt></p><h4 id="跳转到定义"><a href="#跳转到定义" class="headerlink" title="跳转到定义"></a>跳转到定义</h4><p>在源码中的方法，类，变量等，都会在下方有下划线表示可直接跳转，有些甚至包含系统的方法，鼠标直接点击即可，想快速看到代码中的类，变量或者方法是如何定义的？没问题，点击类，变量或者方法被使用的地方就会跳转到相应定义的地方。不仅可以在项目内部跳转，跨项目也同样可以实现跳转。如下图所示：</p><p><img src="http://www.imgeek.org/uploads/article/20170214/a3b95f46f04269ba4215ee47df14e7b1.gif" alt></p><h4 id="查找引用"><a href="#查找引用" class="headerlink" title="查找引用"></a>查找引用</h4><p>可以对方法或者类查找引用的地方，并安类文件罗列出来，直接点击即可查看引用的具体地方。<br>如果想知道代码中的类，变量或者方法在代码库中哪些地方被使用了，可以点击类，变量或者方法的定义处来显示所有被引用的地方。引用会被进一步分成Referenced At Inherit Override等子类型方便开发者进一步缩小查找范围，如下图所示：</p><p><img src="http://www.imgeek.org/uploads/article/20170214/e8f8041cb427fc620c7c89e9ec8cd20c.gif" alt></p><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>在设置中还有很多的快捷键可以设置，协助我们快速的浏览源代码，如下：<br><img src="../img/insight/insight-setting.png" alt="setting"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>此插件的功能很全，页面也很美观，很是喜欢，目前有了它在 github 上看源码方便很多，甚至就不用clone到本地再导入这些复杂的操作流程。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在之前的一篇文章中&lt;a href=&quot;http://www.wxtlife.com/2017/09/27/developers-need-tools/&quot;&gt;《开发人员必备的开发利器》&lt;/a&gt;有介绍过一款Chrome插件，名为 Octotree ，它可以以树形结构的样式将源代码源文件展示出来，方便我们查看跳转等。但是有时候在github上看源码时，可能需要进行方法的跳转，查看具体实现，更或者找到某个方法或者类的调用方，那么有没有既有 Octotree 功能又能实现上面的功能呢，那当然是有的，它就是今天要介绍的主角 &lt;code&gt;insight.io&lt;/code&gt; &lt;/p&gt;
&lt;h3 id=&quot;insight-io-使用&quot;&gt;&lt;a href=&quot;#insight-io-使用&quot; class=&quot;headerlink&quot; title=&quot;insight.io 使用&quot;&gt;&lt;/a&gt;insight.io 使用&lt;/h3&gt;&lt;p&gt;insight.io 也是一个Chrome 插件， 安装也就直接在Chrome插件中心搜索安装就行了，这里就不多描述。&lt;br&gt;安装好后，在首次安装上后需要使用github账号进行授权登录，之后会进行一些操作相关的提示。&lt;br&gt;整体的界面如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/insight/insight_view.png&quot; alt=&quot;insight&quot;&gt;&lt;/p&gt;
&lt;p&gt;整体的风格还是很简约，清新的，很是喜欢。&lt;/p&gt;
&lt;p&gt;这样上面树形结构的源代码已经展示出来了。&lt;/p&gt;
&lt;p&gt;但在使用的时候有几点需要注意，此插件不是所有的github 项目都支持，你可以查看页面中间有个提示信息，如果为&lt;code&gt;ready&lt;/code&gt; 则可以直接使用，如果提示&lt;code&gt;not indexed&lt;/code&gt; 则说明未包含此项目，需要你手动提交，点击即可，之后会进行索引，成功后会邮件通知你，时间大约在半个小时以内，大的项目可能会比较久（本人尝试的时间不到5分钟就OK了），但是不能直接提交fork出来的仓库，fork的仓库可以通过邮件联系对方，可能需要pro付费版本支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="【github,Tools]" scheme="http://www.wxtlife.com/tags/%E3%80%90github-Tools/"/>
    
  </entry>
  
  <entry>
    <title>强大的终端工具ohMyZsh</title>
    <link href="http://www.wxtlife.com/2018/03/21/oh-my-zsh/"/>
    <id>http://www.wxtlife.com/2018/03/21/oh-my-zsh/</id>
    <published>2018-03-21T15:43:14.000Z</published>
    <updated>2018-05-20T14:31:57.714Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天给大家介绍一款强大的终端工具，一般系统默认的终端一般都很鸡肋，要么功能不够智能，要么就是不够美观，这怎么能够体现程序员高大上的逼格呢，所以今天就给大家介绍一款强大的终端工具 <code>oh-my-zsh</code>.</p><p>先来看张我的终端<br><img src="../img/ohmyzsh/ohmyzsh.png" alt="image"></p><p>那么有什么强大的功能呢？</p><ol><li>智能提示</li><li>自动跳转</li><li>智能纠错</li><li>与git 等工具高度集成</li><li>历史记录功能</li><li>目录跳转等</li></ol><p>上面只是我觉得很好用的一些功能，这只是冰山一角，还有其他很多的插件功能，反正一句话就是用了之后你就忘不掉的一个终端。</p><h3 id="什么是-ohMyZsh-介绍"><a href="#什么是-ohMyZsh-介绍" class="headerlink" title="什么是 ohMyZsh 介绍"></a>什么是 ohMyZsh 介绍</h3><p>首先的介绍下 <code>Zsh</code> ，<code>Zsh</code> 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。且其兼容Bash，能够为其补充很多强大的功能。那么 <code>Oh My Zsh</code> 是一款社区驱动的命令行工具，正如它的主页上说的，<code>Oh My Zsh</code> 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。<br><code>ohMyZsh</code> 拥有 200+ 的插件，及140+ 的主题样式，供你任意搭配定制。</p><a id="more"></a><h3 id="安装ohMyZsh"><a href="#安装ohMyZsh" class="headerlink" title="安装ohMyZsh"></a>安装ohMyZsh</h3><ol><li><p>通过 curl 方式安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>通过wget 方式安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure></li></ol><p>如果提示有文件没权限，可使用 sudo 命令进行安装。</p><p>安装完成后，验证是否安装成功。</p><p>如果输入 <code>zsh --version</code> 输出版本号则为安装成功。</p><p>使用 <code>chsh -s $(which zsh)</code> 讲默认的shell切换为zsh，然后通过 <code>$SHELL</code> 检查是否设置成功，如果输出为 <code>/bin/zsh</code>， 则切换默认为zsh 成功。</p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p><code>ohMyZsh</code>拥有很多的主题及插件，可以按照自己的需求来定制，那么怎么配置呢？<br>ohMyZsh 所有的配置都在用户根目录下面的 <code>~/.zshrc</code> 文件中进行配置。</p><p>主题文件的种类及样式可以到网页上查看 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a><br>默认安装就会有很多的主题样式可供配置了，本地主题的文件路径为 <code>~/.oh-my-zsh/themes</code> 可以进行查看。</p><p>喜欢某个主题只需要在 zshrc 文件中的 <code>ZSH_THEME=&quot;XXX&quot;</code>(XXX 为主题名) 例如我的主题为 <code>ZSH_THEME=&quot;agnoster&quot;</code> (<strong>安装这个主题需要安装字体库，因为其中用到了特殊字符</strong>)，具体安装教程可参考官方 <a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">https://github.com/agnoster/agnoster-zsh-theme</a> ,下面也有一些我遇到的问题汇总，如果还有问题可在公众号上留言与我交流。</p><p>样式如下：<br><img src="https://gist.githubusercontent.com/agnoster/3712874/raw/screenshot.png" alt="agnoster"></p><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>插件的种类实在是太多了，以至于有些插件的功能都不清楚，只能说是有需求的时候再去插件库找找是否有满足自己需求的插件。<br>插件库地址如下： <a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins</a><br>本地安装的插件库地址为 <code>~/.oh-my-zsh/plugins</code>。</p><p>添加插件的方法为在<code>~/.zshrc</code> 中，按照下面的格式将插件名称填入即可，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  git</span><br><span class="line">  brew</span><br><span class="line">  adb</span><br><span class="line">  npm</span><br><span class="line">  gradle</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>之后则可以体检到这些插件给你带来的便捷。</p><h3 id="异常问题汇总"><a href="#异常问题汇总" class="headerlink" title="异常问题汇总"></a>异常问题汇总</h3><h4 id="1-终端显示异常"><a href="#1-终端显示异常" class="headerlink" title="1. 终端显示异常"></a>1. 终端显示异常</h4><p>使用 agnoster 主题时， 显示的当前路径及分支信息出现部分乱码，显示很乱。</p><p><strong>解决办法：</strong><br>首先按照<a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">https://github.com/agnoster/agnoster-zsh-theme</a>进行安装，记得一定要安装字体。<br>推荐使用iterm2 然后在 <code>iTerm -&gt; Preferences -&gt; Profiles -&gt; Text</code><br>在下方将 <code>use a different font for non-ASCll text</code> 去掉勾选即可。</p><h4 id="2-默认终端显示名字过长"><a href="#2-默认终端显示名字过长" class="headerlink" title="2. 默认终端显示名字过长"></a>2. 默认终端显示名字过长</h4><p>默认显示了 <a href="mailto:username@host.machine" target="_blank" rel="noopener">username@host.machine</a> 显得很长， 不美观。</p><p><strong>解决办法：</strong></p><ul><li>方法1. 在 .zshrc 中添加  <code>DEFAULT_USER=&quot;$USER&quot;</code></li><li>方法2. 在.zshrc 最末尾，添加下面脚本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$USER&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-使用-ohmyzsh-后，-bash-profile-及-bashrc-不起作用"><a href="#3-使用-ohmyzsh-后，-bash-profile-及-bashrc-不起作用" class="headerlink" title="3. 使用 ohmyzsh 后，~/.bash_profile 及 ~/.bashrc 不起作用"></a>3. 使用 ohmyzsh 后，~/.bash_profile 及 ~/.bashrc 不起作用</h4><p><strong>解决办法：</strong><br>这是由于默认使用是zsh， 所以不会按照<code>/etc/profile --&gt;  /etc/paths  ---&gt;  ~/.bash_profile ---&gt; ~/.bash_login ---&gt;  ~/.profile ---&gt; ~/.bashrc</code><br>所以需要在~/.zshrc 的末尾加上加载文件的脚本，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ -f ~/.bash_profile ]; then</span><br><span class="line">   source ~/.bash_profile</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">   source ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>退出终端，然后重新加载即可。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天给大家介绍一款强大的终端工具，一般系统默认的终端一般都很鸡肋，要么功能不够智能，要么就是不够美观，这怎么能够体现程序员高大上的逼格呢，所以今天就给大家介绍一款强大的终端工具 &lt;code&gt;oh-my-zsh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;先来看张我的终端&lt;br&gt;&lt;img src=&quot;../img/ohmyzsh/ohmyzsh.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么有什么强大的功能呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;智能提示&lt;/li&gt;
&lt;li&gt;自动跳转&lt;/li&gt;
&lt;li&gt;智能纠错&lt;/li&gt;
&lt;li&gt;与git 等工具高度集成&lt;/li&gt;
&lt;li&gt;历史记录功能&lt;/li&gt;
&lt;li&gt;目录跳转等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面只是我觉得很好用的一些功能，这只是冰山一角，还有其他很多的插件功能，反正一句话就是用了之后你就忘不掉的一个终端。&lt;/p&gt;
&lt;h3 id=&quot;什么是-ohMyZsh-介绍&quot;&gt;&lt;a href=&quot;#什么是-ohMyZsh-介绍&quot; class=&quot;headerlink&quot; title=&quot;什么是 ohMyZsh 介绍&quot;&gt;&lt;/a&gt;什么是 ohMyZsh 介绍&lt;/h3&gt;&lt;p&gt;首先的介绍下 &lt;code&gt;Zsh&lt;/code&gt; ，&lt;code&gt;Zsh&lt;/code&gt; 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。且其兼容Bash，能够为其补充很多强大的功能。那么 &lt;code&gt;Oh My Zsh&lt;/code&gt; 是一款社区驱动的命令行工具，正如它的主页上说的，&lt;code&gt;Oh My Zsh&lt;/code&gt; 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。&lt;br&gt;&lt;code&gt;ohMyZsh&lt;/code&gt; 拥有 200+ 的插件，及140+ 的主题样式，供你任意搭配定制。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://www.wxtlife.com/tags/Tools/"/>
    
      <category term="ohmyzsh" scheme="http://www.wxtlife.com/tags/ohmyzsh/"/>
    
  </entry>
  
  <entry>
    <title>【推荐】日志分析查看神器</title>
    <link href="http://www.wxtlife.com/2018/02/27/log-tools/"/>
    <id>http://www.wxtlife.com/2018/02/27/log-tools/</id>
    <published>2018-02-27T14:34:16.000Z</published>
    <updated>2018-03-16T15:49:44.454Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发中定位问题或者调试常常需要分析日志文件，但是对于日志文件一不小心就几百行甚至上千行的相信大家都有些惧怕，尤其在定位问题查看日志时，而且还有不同的tag需要过滤时，看了这个 tag，又要看另外一个 tag，到最后自己都凌乱了，不知道看到哪里了，看了哪些忘了那些，等等很多问题影响效率。</p><p>今天要给大家推荐一个查看日志的神器，至少我现在查看文本日志文件时，不会那么心累了，这款神器软件名字为：<strong>BBEditor</strong> ,遗憾的是目前只有 Mac 版，且也是收费的，不过作为福利，文末会给大家下载地址及注册码，让大家也来感受下查看日志的便捷。</p><a id="more"></a><h3 id="BBEditor-使用"><a href="#BBEditor-使用" class="headerlink" title="BBEditor 使用"></a>BBEditor 使用</h3><ol><li>打开此软件与普通文本软件没什么区别，直接打开或者将文件拖拽到软件中，直接看到整个文件的内容</li><li>过滤 tag，使用快捷键，<code>commond + f</code> 调出查找，然后输入要过滤的<br>tag，或者在文本中选中 tag，直接进行 <code>commond + f</code> 会自动填充查找内容，然后点击 <code>find all</code> 之后会启动一个新的界面，此界面分为两部分，上半部分和下半部分，上半部分的日志则为按照 tag 过滤后的日志结果，当点击选中上半部分的任何一行，下半部分则会显示出该行日志在整个文件中的的位置，且会自动显示出改行日志前后的相关日志。便于查看某些相关信息。</li><li>如果需要过滤过个日志，则在文件上使用 <code>commond + f</code> 命令进行查找，每次都会新开一个界面，便于多 tag 的文件定位。</li></ol><blockquote><p>当然还有很多的可配置参数，在设置中，这里只说基本的使用，高阶使用请自行研究。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了上面的工具，你是否觉得对查看日志不再那么畏惧了，因为这款工具确确实实解决了查看日志上的一些不便的地方。如果你有更好的工具欢迎留言交流。</p><h3 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h3><p>由于此软件只有 mac 版，且是收费的，故这里共享一版最新软件，且共享一个注册码，当然如有你有经济能力，建议进行购买正版。</p><blockquote><p><strong>领取方法：</strong> 在公众号对话框中，发送”日志” 两个字，则可以拿到最新版百度云下载地址及注册码。</p></blockquote><p><strong>如果你觉得文章有用，就帮忙分享出去或者帮忙点个赞吧~感激不尽~</strong></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在开发中定位问题或者调试常常需要分析日志文件，但是对于日志文件一不小心就几百行甚至上千行的相信大家都有些惧怕，尤其在定位问题查看日志时，而且还有不同的tag需要过滤时，看了这个 tag，又要看另外一个 tag，到最后自己都凌乱了，不知道看到哪里了，看了哪些忘了那些，等等很多问题影响效率。&lt;/p&gt;
&lt;p&gt;今天要给大家推荐一个查看日志的神器，至少我现在查看文本日志文件时，不会那么心累了，这款神器软件名字为：&lt;strong&gt;BBEditor&lt;/strong&gt; ,遗憾的是目前只有 Mac 版，且也是收费的，不过作为福利，文末会给大家下载地址及注册码，让大家也来感受下查看日志的便捷。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="log" scheme="http://www.wxtlife.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin开发基础（三）</title>
    <link href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/"/>
    <id>http://www.wxtlife.com/2017/12/17/kotlin-share-3/</id>
    <published>2017-12-17T12:17:45.000Z</published>
    <updated>2018-03-16T15:49:44.453Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><ul><li><strong><a href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/">Kotlin开发基础（一）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/">Kotlin开发基础（二）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/">Kotlin开发基础（三）</a></strong></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>本篇文章主要介绍类的继承，接口，复写，单例，以及object属性的介绍。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>Kotlin中的继承方式与Java类似，Java中所有对象都继承自<code>Object</code>，而Kotlin中所有对象均继承自<code>Any</code>。两者均不能多继承，只是表现形式不同，Kotlin继承使用冒号<code>：</code>表示。想要复写某个方法，则也需要将方法标记为<code>open</code>的才可以被复写。<br><strong>切记一个类想要被继承，必须用 <code>open</code> 或 <code>abstract</code> 关键字 声明。</strong><br>示例如下；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class person(name: String) // 必须申请为open才可以继承，</span><br><span class="line"></span><br><span class="line">class  male(name: String)： Person(name)</span><br></pre></td></tr></table></figure></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类与这里与Java是一致的，通过<code>abstract</code>关键字标记为抽象类，抽象类中抽象方法也用 <code>abstract</code>标记。有了<code>abstract</code> 则不再需要使用<code>open</code>进行标注了。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open class person() &#123; </span><br><span class="line">    open fun eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class oldPerson(): person() &#123; </span><br><span class="line">    override abstract fun sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>抽象类和抽象方法是默认<code>open</code>关键字修饰的</li><li>复写抽象类中实现的方法，也必须要加<code>open</code>关键字才可复写</li><li>抽象类有抽象方法和方法的实现，可以有成员属性</li></ul><a id="more"></a><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>Kotlin中的接口需要使用关键字<code>interface</code>进行声明，Kotlin 的接口既包含抽象方法的声明，也可以包含实现，且接口中也可以申明属性，默认属性要求是抽象的，或者是提供访问器,其接口中的属性不能有<code>field</code>属性关键字。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface MyInterface &#123; </span><br><span class="line">    val prop: Int // 抽象的</span><br><span class="line">    val propertyWithImplementation: String get() = &quot;foo&quot;</span><br><span class="line">    fun foo() &#123; //方法实现</span><br><span class="line">        print(prop)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">class Child : MyInterface &#123; </span><br><span class="line">    override val prop: Int = 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中已经实现的方法，在子类中进行复写不需要在加<code>open</code>关键字。<br>在接口中</p><h4 id="复写"><a href="#复写" class="headerlink" title="复写"></a>复写</h4><p>复写关键字为 <code>override</code>，与Java的区别是没有了@符号了。复写这里需要注意两点</p><ol><li><code>var</code>可以复写<code>val</code>类型的，但是反之不行。</li><li>想要复写父类的方法，父类方法必须加<code>open</code>关键字标识。</li></ol><p>复写的规则中，如果继承和实现了同样的方法名，则必须在子类对该方法进行复写,以为编译器不知道该调用那个父类的方法。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;</span><br><span class="line">    open fun f() &#123; print(&quot;A&quot;) &#125; </span><br><span class="line">    fun a() &#123; print(&quot;a&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface B &#123;</span><br><span class="line">    fun f() &#123; print(&quot;B&quot;) &#125; // 接口成员默认就是“open”的 </span><br><span class="line">    fun b() &#123; print(&quot;b&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">class C() : A(), B &#123;</span><br><span class="line">    // 编译器要求覆盖 f()，因为不知道该调用哪个父类的方法</span><br><span class="line">    override fun f() &#123;</span><br><span class="line">        super&lt;A&gt;.f() // 调用 A.f()</span><br><span class="line">        super&lt;B&gt;.f() // 调用 B.f() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="data数据类"><a href="#data数据类" class="headerlink" title="data数据类"></a>data数据类</h4><p>在与服务器交互中经常有数据类，在Kotlin中直接使用data标记为数据类，它会根据构造函数的属性生成<code>equals</code> ， <code>hashcode</code> ， <code>toString</code> 方法，当然这块我们也是可以重写的。<br>需要注意的是：</p><ol><li>数据类主构造函数至少有一个参数</li><li>主构造函数的所有参数需要标记为 <code>val</code> 或 <code>var</code>；</li></ol><h4 id="单例声明"><a href="#单例声明" class="headerlink" title="单例声明"></a>单例声明</h4><p>在Java中写一个单例是很麻烦的事情，也有很多种不通过的写法，需要考虑多线程问题，但在Kotlin中单例就变得简单的多，使用 <code>object</code>关键字就可以实现单例,我们看下示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object Person &#123;</span><br><span class="line">    fun eat()&#123;</span><br><span class="line">        print(&quot;eat&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>翻译成为Java代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class Person &#123;</span><br><span class="line">   public static final Person INSTANCE;</span><br><span class="line"></span><br><span class="line">   public final void eat() &#123;</span><br><span class="line">      String var1 = &quot;eat&quot;;</span><br><span class="line">      System.out.print(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      Person var0 = new Person();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到上面代码实际为一个单例默认的饿汉模式实现。</p><h4 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h4><p>当需要修改一个类的部分功能，可以不通过显式实现一个该类的子类方式来实现。在Java中，通过匿名内部类来实现；在Kotlin中，概括为对象表达式和对象声明。最常见的就是我们代码中设置Listener。示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val test = object : View.OnClickListener() &#123;</span><br><span class="line">    override fun onClick(p0: View?) &#123;</span><br><span class="line">        Log.v(&quot;TAG&quot;,&quot;click listener&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有这种用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val adHoc = object &#123;  </span><br><span class="line">  var x: Int = 0  </span><br><span class="line">  var y: Int = 0  </span><br><span class="line">&#125;  </span><br><span class="line">print(adHoc.x + adHoc.y)</span><br></pre></td></tr></table></figure></p><h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><p>Kotlin中没有静态的属性和方法的概念， Kotlin官网建议我们使用包级别的函数，来替代静态方法。当然也可以在类内使用<code>companion object</code>关键字声明一个伴生对象。 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val  TAG = &quot;TEST&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    fun test()&#123;</span><br><span class="line">        Log.v(Test.TAG,&quot;test method&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>object</code>的使用有很多种，可参考这篇文章。 <a href="http://liuqingwen.me/blog/2017/06/20/object-vs-companion-object-in-kotlin/" target="_blank" rel="noopener">http://liuqingwen.me/blog/2017/06/20/object-vs-companion-object-in-kotlin/</a></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Kotlin 中的继承和接口大体上与 Java 一致，尤其是在 Java 8 后面的语法， 接口中可以包含实现了，和抽象类的概念更近了点，但是两个还是有些许的差别，这点需要自己多体会。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/09/08/kotlin-share-1/&quot;&gt;Kotlin开发基础（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/12/kotlin-share-2/&quot;&gt;Kotlin开发基础（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/17/kotlin-share-3/&quot;&gt;Kotlin开发基础（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;p&gt;本篇文章主要介绍类的继承，接口，复写，单例，以及object属性的介绍。&lt;/p&gt;
&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h4&gt;&lt;p&gt;Kotlin中的继承方式与Java类似，Java中所有对象都继承自&lt;code&gt;Object&lt;/code&gt;，而Kotlin中所有对象均继承自&lt;code&gt;Any&lt;/code&gt;。两者均不能多继承，只是表现形式不同，Kotlin继承使用冒号&lt;code&gt;：&lt;/code&gt;表示。想要复写某个方法，则也需要将方法标记为&lt;code&gt;open&lt;/code&gt;的才可以被复写。&lt;br&gt;&lt;strong&gt;切记一个类想要被继承，必须用 &lt;code&gt;open&lt;/code&gt; 或 &lt;code&gt;abstract&lt;/code&gt; 关键字 声明。&lt;/strong&gt;&lt;br&gt;示例如下；&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;open class person(name: String) // 必须申请为open才可以继承，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class  male(name: String)： Person(name)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h4&gt;&lt;p&gt;抽象类与这里与Java是一致的，通过&lt;code&gt;abstract&lt;/code&gt;关键字标记为抽象类，抽象类中抽象方法也用 &lt;code&gt;abstract&lt;/code&gt;标记。有了&lt;code&gt;abstract&lt;/code&gt; 则不再需要使用&lt;code&gt;open&lt;/code&gt;进行标注了。&lt;br&gt;示例如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;open class person() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    open fun eat() &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;abstract class oldPerson(): person() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override abstract fun sleep()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类和抽象方法是默认&lt;code&gt;open&lt;/code&gt;关键字修饰的&lt;/li&gt;
&lt;li&gt;复写抽象类中实现的方法，也必须要加&lt;code&gt;open&lt;/code&gt;关键字才可复写&lt;/li&gt;
&lt;li&gt;抽象类有抽象方法和方法的实现，可以有成员属性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.wxtlife.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin开发基础（二）</title>
    <link href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/"/>
    <id>http://www.wxtlife.com/2017/12/12/kotlin-share-2/</id>
    <published>2017-12-12T13:29:09.000Z</published>
    <updated>2018-03-16T15:49:44.453Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><ul><li><strong><a href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/">Kotlin开发基础（一）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/">Kotlin开发基础（二）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/">Kotlin开发基础（三）</a></strong></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>本篇文章主要介绍类的属性定义及getter和setter，构造器，主次构造函数相关知识。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>类使用 <code>class</code> 关键字来标识，这个与Java中一样的。但是在kotlin中默认类都是不可继承的，也就是所说的 <code>final</code> 的类型，如果需要别继承，则必须将其标记为 <code>open</code> 或者 <code>abstract</code> 类型。</p><h4 id="可见性声明"><a href="#可见性声明" class="headerlink" title="可见性声明"></a>可见性声明</h4><p>Kotlin 一共有四种可见性修饰符：<code>private、protected、internal、public</code>。<br>可见性修饰可用于函数、属性、类、对象和接口，但不能用于局部变量。<br>如果没有显式指定修饰符的话，默认可⻅性是 <code>public</code> 。与Java中默认类型不同。</p><h4 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h4><h5 id="getter-setter及filed关键字"><a href="#getter-setter及filed关键字" class="headerlink" title="getter/setter及filed关键字"></a>getter/setter及filed关键字</h5><p>在Kotlin中对于 <code>var</code> 的变量都会默认有 <code>setter</code> 和 <code>getter</code> 方法，对 <code>val</code> 的仅有 <code>getter</code> 方法，当然也可以复写 <code>getter</code> 和 <code>setter</code> 方法，一般写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>值得注意的是，在复写getter和setter时，新手很容易犯的一个错，请看如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">        get() = age</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            age = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码编译期间是没有任何问题，但是运行起来呢？发现发生了<code>StackOverflowError</code>。。。怎么会是这么个鬼错误。这么简单的代码还能写错？这里教大家一个展示转为Java的方法。通过 <code>Tools</code> —&gt; <code>Kotlin</code> —-&gt; <code>Show kotlin ByteCode</code> ,这里转出来是字节码，很难看，然后在对话框上面在点击 DeCompile 这样就出现Java代码了，看看上面的代码生成了什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class Person &#123;</span><br><span class="line">   public final int getAge() &#123;</span><br><span class="line">      return this.getAge();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final void setAge(int value) &#123;</span><br><span class="line">      this.setAge(value);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的 <code>getter</code> 和 <code>setter</code> 方法都调用的是自己的方法。所以就发生 <code>StackOverflowError</code> 的错误了。这怎么办？Kotlin官方也意识到这个问题啦，便有了<code>field</code> 关键字啦。<br>正确写法如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">get</span>() = field</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的写法请自行转换为java代码看看是什么代码。</p><ul><li><code>field</code>标识符只能用在属性的访问器内。</li></ul><h5 id="lateinit关键字"><a href="#lateinit关键字" class="headerlink" title="lateinit关键字"></a><code>lateinit</code>关键字</h5><p>由于Kotlin默认是不允许为空的，所以在声明变量时，必须对其进行赋值，但是有些时候，我们确时无法在一开始定义的时候就赋值，这时候就需要延迟赋值。这时就用 <code>lateinit</code> 关键字进行标记。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lateinit var ageStr: String</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>  </p><ol><li><code>lateinit</code> 只能对 <code>var</code> 类型的变量</li><li><code>lateinit</code> 不能用于基础类型，因为基础类型没有null的情况</li></ol><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>Kotlin中的类需要构造函数时，可以有一个主构造函数和多个次构造函数，当然也可以没有构造函数。</p><h5 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h5><p>主构造函数在类名后。<br>写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String) &#123;</span><br><span class="line">    /// some code ****</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果类中没有任何的代码时，则可以省略最后面的括号写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String)</span><br></pre></td></tr></table></figure></p><p>当构造函数有注解或者可见性修饰符时，构造函数需要加<code>constructor</code>关键字，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person private constructor(name: String)</span><br></pre></td></tr></table></figure></p><p><code>private</code> 指的是构造方法为<code>private</code> 类型。</p><p>由于主构造函数中是不能有代码块的，如果想要在构造函数中有代码块，则必须使用<code>init{}</code>语句块，将初始话语句写在init代码块中，代码块中可以访问到构造函数的属性，并执行一些语句块，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String) &#123;</span><br><span class="line">    private var mName: String</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;init&quot;)</span><br><span class="line">        mName = name.toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当在构造函数中的参数名前加上 <code>var</code> ，<code>val</code> 则表示此参数为类的一个成员变量。并且会自动会在构造函数中对其进行赋值，默认也会为其生成<code>get</code> 和 <code>set</code> 方法。不想对外访问则添加<code>private</code>修饰符即可。<br>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//会自动生成private name:String的类属性，且生成get方法（没有set因为是val的类型）</span><br><span class="line">class TestClass(val name:String) &#123;</span><br><span class="line">    fun test() &#123;</span><br><span class="line">        Log.v(&quot;TestClass&quot;,&quot;name = $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//下面是外部不可以访问name属性的</span><br><span class="line">class TestClass(private var name:String) &#123;</span><br><span class="line">    fun test() &#123;</span><br><span class="line">        Log.v(&quot;TestClass&quot;,&quot;name = $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二级构造"><a href="#二级构造" class="headerlink" title="二级构造"></a>二级构造</h4><p>二级构造函数，也称为次级构造函数。关于二级构造函数，主要有以下几点：</p><ul><li>次级构造函数不能省略 <code>constructor</code> 关键字；</li><li>当类拥有主构造函数时，任何一个二级构造函数都需要直接或间接通过另一个二级构造函数代理主构造函数；</li><li>类中的一个构造函数代理另一个构造函数，需要使用关键字this；</li></ul><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor(id: Int) &#123;//（构造函数No.0）主构造函数</span><br><span class="line">    var id = id//主构造函数初始化id</span><br><span class="line">    var name = &quot;&quot;</span><br><span class="line">    var age = 0</span><br><span class="line">    //（构造函数No.1）直接代理主构造函数</span><br><span class="line">    constructor(name: String, id: Int) : this(id) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    //（构造函数No.2）代理了构造函数No.1，间接代理主构造函数</span><br><span class="line">    constructor(name: String, age: Int, id: Int) : this(name, id) &#123;</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这类补充子类的次构造函数是无法直接代理到父类的方法。必须指向本类的主或次构造函数，但最终都必须指向主构造函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Kotlin 中的对一个类的声明比 Java 简单了很多，代码量也少了很多，尤其是对于数据类来说， 从这来看 Kotlin 的语法是比 Java 简洁了很多，节省码代码的时间。 </p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/09/08/kotlin-share-1/&quot;&gt;Kotlin开发基础（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/12/kotlin-share-2/&quot;&gt;Kotlin开发基础（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/17/kotlin-share-3/&quot;&gt;Kotlin开发基础（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;p&gt;本篇文章主要介绍类的属性定义及getter和setter，构造器，主次构造函数相关知识。&lt;/p&gt;
&lt;h4 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h4&gt;&lt;p&gt;类使用 &lt;code&gt;class&lt;/code&gt; 关键字来标识，这个与Java中一样的。但是在kotlin中默认类都是不可继承的，也就是所说的 &lt;code&gt;final&lt;/code&gt; 的类型，如果需要别继承，则必须将其标记为 &lt;code&gt;open&lt;/code&gt; 或者 &lt;code&gt;abstract&lt;/code&gt; 类型。&lt;/p&gt;
&lt;h4 id=&quot;可见性声明&quot;&gt;&lt;a href=&quot;#可见性声明&quot; class=&quot;headerlink&quot; title=&quot;可见性声明&quot;&gt;&lt;/a&gt;可见性声明&lt;/h4&gt;&lt;p&gt;Kotlin 一共有四种可见性修饰符：&lt;code&gt;private、protected、internal、public&lt;/code&gt;。&lt;br&gt;可见性修饰可用于函数、属性、类、对象和接口，但不能用于局部变量。&lt;br&gt;如果没有显式指定修饰符的话，默认可⻅性是 &lt;code&gt;public&lt;/code&gt; 。与Java中默认类型不同。&lt;/p&gt;
&lt;h4 id=&quot;类属性&quot;&gt;&lt;a href=&quot;#类属性&quot; class=&quot;headerlink&quot; title=&quot;类属性&quot;&gt;&lt;/a&gt;类属性&lt;/h4&gt;&lt;h5 id=&quot;getter-setter及filed关键字&quot;&gt;&lt;a href=&quot;#getter-setter及filed关键字&quot; class=&quot;headerlink&quot; title=&quot;getter/setter及filed关键字&quot;&gt;&lt;/a&gt;getter/setter及filed关键字&lt;/h5&gt;&lt;p&gt;在Kotlin中对于 &lt;code&gt;var&lt;/code&gt; 的变量都会默认有 &lt;code&gt;setter&lt;/code&gt; 和 &lt;code&gt;getter&lt;/code&gt; 方法，对 &lt;code&gt;val&lt;/code&gt; 的仅有 &lt;code&gt;getter&lt;/code&gt; 方法，当然也可以复写 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法，一般写法如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var &amp;lt;propertyName&amp;gt;[: &amp;lt;PropertyType&amp;gt;] [= &amp;lt;property_initializer&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&amp;lt;getter&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&amp;lt;setter&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.wxtlife.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android首次启动卡顿问题分析</title>
    <link href="http://www.wxtlife.com/2017/11/14/Android-first-launcher-problem/"/>
    <id>http://www.wxtlife.com/2017/11/14/Android-first-launcher-problem/</id>
    <published>2017-11-14T12:56:09.000Z</published>
    <updated>2018-03-16T15:49:44.448Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>在有些 Android 机器上首次启动时会出现很明显的卡顿问题，且比较明显的是只会在安装后的首次出现，很是奇怪，那么要分析这个问题则需要了解启动的不同类型的区别以及不同版本间的区别了。</p><h3 id="启动的分类"><a href="#启动的分类" class="headerlink" title="启动的分类"></a>启动的分类</h3><p>启动分三种，首次安装后的冷启动，冷启动，热启动</p><h4 id="首次安装完的冷启动"><a href="#首次安装完的冷启动" class="headerlink" title="首次安装完的冷启动"></a>首次安装完的冷启动</h4><p>这个指的是用户对APK进行安装后，首次进行打开的过程。</p><h4 id="app的冷启动"><a href="#app的冷启动" class="headerlink" title="app的冷启动"></a>app的冷启动</h4><p>指当启动应用时，后台没有该程序的进程。</p><h4 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h4><p>指程序依然在，启动时通过已有进程启动应用。</p><a id="more"></a><h3 id="虚拟机区别"><a href="#虚拟机区别" class="headerlink" title="虚拟机区别"></a>虚拟机区别</h3><h4 id="Dalvik（Android5-0-以下系统）"><a href="#Dalvik（Android5-0-以下系统）" class="headerlink" title="Dalvik（Android5.0 以下系统）"></a>Dalvik（Android5.0 以下系统）</h4><p>在5.0以下的版本中，默认的虚拟机为Dalvik，Dalvik虚拟机与Java虚拟机有差不多的特性，都是解释执行的。Dalvik采用的是JIT（及时编译）技术。 <code>.dex</code>格式是专为Dalvik设计的一种压缩格式,在每次执行应用的时候Dalvik虚拟机都会将程序的语言由高级语言编译为机器语言。</p><p>在应用启动时 JIT通过进行连续的性能分析来优化程序代码的执行，在程序运行的过程中，Dalvik虚拟机在不断的进行将字节码编译成机器码的工作，这样当前的程序才能运行。启动程序优化代码并存储在Dalvik缓存中。Dalvik第一次加载后会生成Cache文件，以提供下次快速加载，所以第一次会很慢。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><ul><li>1、 占用空间较小</li><li>2、 安装速度快</li></ul><p><strong>缺点：</strong></p><ul><li>1、 启动速度慢<h4 id="ART-Android-RunTime-Android-5-0-以上系统"><a href="#ART-Android-RunTime-Android-5-0-以上系统" class="headerlink" title="ART-Android RunTime (Android 5.0 以上系统)"></a>ART-Android RunTime (Android 5.0 以上系统)</h4></li></ul><p>在5.0以上的系统默认采用了<code>ART（Android RunTime）</code>模式，它正式的取代了以往的Dalvik虚拟机，ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机，ART采用Ahead-of-time（AOT）技术，此种模式对Dalvik进行了很多的优化，包括性能，以及垃圾回收器等。</p><p>在ART模式下系统在安装应用的时候会进行一次预编译，在安装应用程序时会先将代码转换为机器语言存储在本地，这样在运行程序时就不会每次都进行一次编译了，执行效率也大大提升。</p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点：</strong></p><ul><li>1、系统性能的显著提升。</li><li>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。</li><li>3、更长的电池续航能力。</li><li>4、支持更低的硬件。</li></ul><p><strong>缺点：</strong></p><ul><li>1、占用更多空间</li><li>2、安装时间变长</li></ul><p>对上面两个有个很好的比喻：</p><blockquote><p>Dalvik 是已经折叠起来的自行车，每次骑都要先组装自行车才能骑<br>ART 是已经组装好的自行车，每次骑直接上车就能走人</p></blockquote><h3 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h3><p>Dalvik是执行的时候编译+运行的模式。而ART是编译好的直接进行运行。<br>如果我们的应用比较大，比如有多个dex文件，那么这时候在不同虚拟机平台上启动速度是很不一样的，在Dalvik的虚拟机上，需要将每一个dex文件转化为机器码，dex越多越大则耗时越高，所以对于首次安装的冷启动是很慢很慢的，有时可能还会造成 ANR ，当然第一次之后会将相应的缓存保存在<code>data/dalvik-cache</code>下面，后续的冷启动读取缓存进行加载运行。相对会比首次安装后启动快很多。<br>然而在ART的模式下，由于其是在安装的过程中进行这部分处理的，所以应用的启动速度不受这些的影响。 </p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>对于在Dalvi虚拟机上的目前是没有很好的办法去解决首次安装后的冷启动，因为这个是系统虚拟机的限制导致此问题，此过程是必经之路。</p><p><strong>瞎方法（不推荐）</strong><br>对于系统定制开发来说，可以在自己代码中起一个很普通的service，什么都不做，启动起来只有就自己结束。然后另外一个系统常驻的service，监听系统新增的应用包，监听到后启动这个应用的空白service，这个过程就相当于让程序能够自运行一下。让虚拟机首次启动执行的过程跑一遍，加快后续在启动的一个启动速度。当然这样就会导致系统与应用有些耦合。当然这只是一个瞎推荐的方法。</p><h3 id="相关的参考资料"><a href="#相关的参考资料" class="headerlink" title="相关的参考资料"></a>相关的参考资料</h3><p>Activity 启动 Display 延迟问题源码分析代码如下：<a href="http://blog.csdn.net/kc58236582/article/details/60134836" target="_blank" rel="noopener">http://blog.csdn.net/kc58236582/article/details/60134836</a></p><p>Google 官方对于启动时间一些说明: <a href="https://developer.android.com/topic/performance/launch-time.html" target="_blank" rel="noopener">https://developer.android.com/topic/performance/launch-time.html </a>  </p><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队-1"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队-1" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;在有些 Android 机器上首次启动时会出现很明显的卡顿问题，且比较明显的是只会在安装后的首次出现，很是奇怪，那么要分析这个问题则需要了解启动的不同类型的区别以及不同版本间的区别了。&lt;/p&gt;
&lt;h3 id=&quot;启动的分类&quot;&gt;&lt;a href=&quot;#启动的分类&quot; class=&quot;headerlink&quot; title=&quot;启动的分类&quot;&gt;&lt;/a&gt;启动的分类&lt;/h3&gt;&lt;p&gt;启动分三种，首次安装后的冷启动，冷启动，热启动&lt;/p&gt;
&lt;h4 id=&quot;首次安装完的冷启动&quot;&gt;&lt;a href=&quot;#首次安装完的冷启动&quot; class=&quot;headerlink&quot; title=&quot;首次安装完的冷启动&quot;&gt;&lt;/a&gt;首次安装完的冷启动&lt;/h4&gt;&lt;p&gt;这个指的是用户对APK进行安装后，首次进行打开的过程。&lt;/p&gt;
&lt;h4 id=&quot;app的冷启动&quot;&gt;&lt;a href=&quot;#app的冷启动&quot; class=&quot;headerlink&quot; title=&quot;app的冷启动&quot;&gt;&lt;/a&gt;app的冷启动&lt;/h4&gt;&lt;p&gt;指当启动应用时，后台没有该程序的进程。&lt;/p&gt;
&lt;h4 id=&quot;热启动&quot;&gt;&lt;a href=&quot;#热启动&quot; class=&quot;headerlink&quot; title=&quot;热启动&quot;&gt;&lt;/a&gt;热启动&lt;/h4&gt;&lt;p&gt;指程序依然在，启动时通过已有进程启动应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【工具】gitignore全自动生成</title>
    <link href="http://www.wxtlife.com/2017/11/10/gitignore-auto-create/"/>
    <id>http://www.wxtlife.com/2017/11/10/gitignore-auto-create/</id>
    <published>2017-11-10T09:23:09.000Z</published>
    <updated>2018-03-16T15:49:44.451Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>今天给大家安利一款 gitignore 自动生成的在线软件，那么它有什么特别的功能呢？且慢看下面内容。</p><p>gitignore 文件大家应该比较熟悉，你必须把某些文件放到Git工作目录中，但又不能提交它们，或者在使用 git status 时看到很多不需要关心的 Untracked files … 文件 ，那么这时候就需要 .gitignore 文件了。</p><p>那么在新建项目时，由于使用不同的编译器，不同的语言以及不同的操作系统再或者使用不同的工具，都会或多或少在项目中生成一些不需要提交到仓库的文件，如果要想我们自己去一个个的添加 gitignore 配置那么就需要一个个查找哪些是不需要的而且还可能会遗漏，比较麻烦，那么今天介绍的工具就是解决这个问题的。</p><p>首先来看下网页的主界面：<br><img src="/img/ignore/ignore1.jpg" alt="ignore1"></p><a id="more"></a><p>可以在输入框中输入我们的操作系统，使用的语言，工具等，如下图：<br><img src="/img/ignore/ignore2.jpg" alt="ignore1"></p><p>然后点击 Create 看下结果。<br><img src="/img/ignore/ignore3.jpg" alt="ignore1"></p><p>当然还有很多的内容，这里就不贴出来了。虽然有些文件我们是没有遇到的，反正就是一个 gitignore 文件，不需要经常修改，所以全部贴到我们项目文件中就可以 。</p><p>工具的网址如下： <a href="https://www.gitignore.io/" target="_blank" rel="noopener">https://www.gitignore.io/</a></p><p>当然也可以点击阅读原文跳转到工具网址，如果你喜欢这个工具就点个赞吧，或者转发给你的同事吧。</p><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队-1"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队-1" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "16175-1571201710743-904",        "name": "技术特工队",        "qrcode": "http://www.wxtlife.com/uploads/wechat-qcode.jpg",        "keyword": "more"    });}</script><div id="gitalk-container"></div><script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script>var gitalkConfig = {"clientID":"0bc3516ae6bba18ef48b","clientSecret":"e3a7c4304959703a34746452cd8b418ba328ba7e","accessToken":"33f5ebc17380e72f317ff10786a167afcf8f38d6","repo":"HexoGitTalk","owner":"wx962464","admin":["wx962464"],"distractionFreeMode":false};    gitalkConfig.id = md5(location.pathname);var gitalk = new Gitalk(gitalkConfig);    gitalk.render("gitalk-container");    </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;今天给大家安利一款 gitignore 自动生成的在线软件，那么它有什么特别的功能呢？且慢看下面内容。&lt;/p&gt;
&lt;p&gt;gitignore 文件大家应该比较熟悉，你必须把某些文件放到Git工作目录中，但又不能提交它们，或者在使用 git status 时看到很多不需要关心的 Untracked files … 文件 ，那么这时候就需要 .gitignore 文件了。&lt;/p&gt;
&lt;p&gt;那么在新建项目时，由于使用不同的编译器，不同的语言以及不同的操作系统再或者使用不同的工具，都会或多或少在项目中生成一些不需要提交到仓库的文件，如果要想我们自己去一个个的添加 gitignore 配置那么就需要一个个查找哪些是不需要的而且还可能会遗漏，比较麻烦，那么今天介绍的工具就是解决这个问题的。&lt;/p&gt;
&lt;p&gt;首先来看下网页的主界面：&lt;br&gt;&lt;img src=&quot;/img/ignore/ignore1.jpg&quot; alt=&quot;ignore1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.wxtlife.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
