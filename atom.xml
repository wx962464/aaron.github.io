<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术特工队</title>
  
  <subtitle>人因梦想而伟大，因坚持而可贵</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wxtlife.com/"/>
  <updated>2018-05-20T14:36:10.773Z</updated>
  <id>http://www.wxtlife.com/</id>
  
  <author>
    <name>WangXin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文章首发公众号【技术特工队】</title>
    <link href="http://www.wxtlife.com/2020/01/01/my-blog-step-wxtlife-com/"/>
    <id>http://www.wxtlife.com/2020/01/01/my-blog-step-wxtlife-com/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2018-05-20T14:36:10.773Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h3 id="【技术特工队】"><a href="#【技术特工队】" class="headerlink" title="【技术特工队】"></a><a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">【技术特工队】</a></h3><p><img src="http://www.wxtlife.com/img/qrcode/qrcode.jpg" alt="技术特工队"> </p><h5 id="分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。"><a href="#分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。" class="headerlink" title="分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。"></a>分享工作中的技术点滴，包含应用层，涉猎系统层，以及新技术的探索、实践，也会涵盖职场分享，生活感悟，趣闻趣事等。但愿我们一起学习，一起成长，一起进步。</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队
      
    
    </summary>
    
      <category term="Blog" scheme="http://www.wxtlife.com/categories/Blog/"/>
    
    
      <category term="Blog" scheme="http://www.wxtlife.com/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（三）</title>
    <link href="http://www.wxtlife.com/2018/08/12/osx-dev-summary-3/"/>
    <id>http://www.wxtlife.com/2018/08/12/osx-dev-summary-3/</id>
    <published>2018-08-12T15:51:41.000Z</published>
    <updated>2018-08-12T16:03:40.982Z</updated>
    
    <content type="html"><![CDATA[<h3 id="NSStackView"><a href="#NSStackView" class="headerlink" title="NSStackView"></a>NSStackView</h3><p>OSX 中 NSStackView  使用自动布局（系统的自动布局特性）来根据你的要求管理和对齐一组视图。可以设置为 水平方向，或者垂直方向。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.orientation = .horizontal //水平方向</span><br><span class="line">stackView.orientation = .vertical  //垂直方向</span><br></pre></td></tr></table></figure></p><h4 id="添加子view"><a href="#添加子view" class="headerlink" title="添加子view"></a>添加子view</h4><p>为stackView 中添加 子view的方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stackView.addArrangedSubview(view)</span><br></pre></td></tr></table></figure></p><p><strong>注意： 由于stackView 是继承自 NSView， 所有也会有 <code>addSubview(view)</code> 的方法，但是调用此方法，不会自动扩大 stackView 的宽高，而导致新加的view 显示不出来。</strong></p><h4 id="移除子view"><a href="#移除子view" class="headerlink" title="移除子view"></a>移除子view</h4><p>移除子 View 采用如下方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stackView.removeArrangedSubview(view) </span><br><span class="line">view.removeFromSuperview()</span><br></pre></td></tr></table></figure></p><p><strong>注意：子view从stackView移除后，还必须将子view从父view中移除</strong></p><a id="more"></a><h4 id="指定添加的每个View的间距"><a href="#指定添加的每个View的间距" class="headerlink" title="指定添加的每个View的间距"></a>指定添加的每个View的间距</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//指定每个添加的每个View间的间距</span><br><span class="line">stackView.spacing = 5</span><br><span class="line"></span><br><span class="line">// 在customerView 后设置space为10</span><br><span class="line">stackView.setCustomSpacing(10, customerView）</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：<br><a href="https://swift.gg/2016/03/31/ios9-uistackview-guide-swift/" target="_blank" rel="noopener">https://swift.gg/2016/03/31/ios9-uistackview-guide-swift/</a>  </p></blockquote><h3 id="OSX坐标系翻转"><a href="#OSX坐标系翻转" class="headerlink" title="OSX坐标系翻转"></a>OSX坐标系翻转</h3><p>这里为什么要说坐标系呢？ 因为在 iOS等其他移动设备上远点都左上角，而在OSX中坐标原点在左下角，这导致在有些 iOS 库想兼容到 OSX就要做很多的适配的问题。然而系统提供了坐标翻转的函数，可以很方便的将 OSX 坐标原点转化为 左上角，保持与iOS一致，在使用的NSView中复写如下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)isFlipped &#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="http://www.macdev.io/ebook/nsview.html" target="_blank" rel="noopener">http://www.macdev.io/ebook/nsview.html</a></p><h3 id="Swift-倒序循环"><a href="#Swift-倒序循环" class="headerlink" title="Swift 倒序循环"></a>Swift 倒序循环</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in (0..&lt;3).reversed()</span><br><span class="line">//表示：2，1，0</span><br><span class="line"></span><br><span class="line">for i in stride(from:3, through:0, by:-1)  </span><br><span class="line">//表示3，2，1，0</span><br></pre></td></tr></table></figure><h3 id="NSWindow"><a href="#NSWindow" class="headerlink" title="NSWindow"></a>NSWindow</h3><h4 id="NSApp-keyWindow"><a href="#NSApp-keyWindow" class="headerlink" title="NSApp.keyWindow"></a>NSApp.keyWindow</h4><p>表示当前正在接受键盘事件的窗口，比如一个应用有多个窗口，当前窗口正在接受键盘事件或状态栏未灰掉的当前的窗口为 keyWindow, 官方文档对返回值解释如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The value of this property is nil when there is no window receiving keyboard events. </span><br><span class="line">The property might be nil because the app’s storyboard file has not yet finished loading or when the receiver is not active.</span><br></pre></td></tr></table></figure></p><p>也就是说如果如果没有窗口接收键盘事件或者storyboard文件还未加载完，或窗口未激活，将返回的都是 nil。</p><h4 id="NSApp-mainWindow"><a href="#NSApp-mainWindow" class="headerlink" title="NSApp.mainWindow"></a>NSApp.mainWindow</h4><p>表示一个应用程序的主Window，官方的返回值说明如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The value in this property is nil when the app’s storyboard or nib file has not yet finished loading. It might also be nil when the app is inactive or hidden.</span><br></pre></td></tr></table></figure></p><p>当app的 storyboard 或者 xib文件未加载完成，或者当前窗口为未激活状态或者是隐藏状态时，将返回nil。</p><p><strong>注意： 所以项目中需要使用mainWindow 或者keyWinodw 时需要注意为空的情况。</strong></p><p><a href="https://zonble.net/archives/2010_08/1352.php" target="_blank" rel="noopener">https://zonble.net/archives/2010_08/1352.php</a></p><h4 id="window-窗口最小化"><a href="#window-窗口最小化" class="headerlink" title="window 窗口最小化"></a>window 窗口最小化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使当前的窗口最小化</span><br><span class="line">window.miniaturize(self)</span><br><span class="line">// 使当前的窗口恢复原来状态取消最小化</span><br><span class="line">window.deminiaturize(self)</span><br><span class="line">// 如果当前为最小化则最大化，如果当前为最大化则最小化，取反。</span><br><span class="line">window.toggleFullScreen(nil)</span><br><span class="line">// 判断是否为全屏的状态</span><br><span class="line">let isFullScreen = window.styleMask.contains(.fullScreen)</span><br></pre></td></tr></table></figure><h4 id="window-storyboard-代码加载"><a href="#window-storyboard-代码加载" class="headerlink" title="window storyboard 代码加载"></a>window storyboard 代码加载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let mainStoryboard = NSStoryboard(name: NSStoryboard.Name(rawValue: &quot;main&quot;), bundle: nil)</span><br><span class="line">// 使用mainStoryboard自动连线控制的NSWindowController，</span><br><span class="line">let mainWindowController = mainStoryboard.instantiateInitialController() as! MainWindowController</span><br><span class="line">mainWindowController.showWindow(nil) // 显示出来。</span><br></pre></td></tr></table></figure><p>如果storyboard 不是我们默认启动，需要代码启动的化，上面需要我们自行定义一个NSWindow的子类<code>MainWindowController</code>，在初始化完成后强制转化为 <code>MainWindowController</code></p><p>如果已经有一个window启动，需要加载storyboard中的某个viewControl进行替换。可以使用下面的语句进行初始化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let mainStoryboard = NSStoryboard(name: NSStoryboard.Name(rawValue: &quot;main&quot;), bundle: nil)</span><br><span class="line">//得到指定的storyboard中指定的ViewController。</span><br><span class="line">let mainViewController = mainStoryboard.instantiateController(withIdentifier: NSStoryboard.SceneIdentifier(rawValue: &quot;InMeetingViewController&quot;)) as? NSViewController</span><br><span class="line">// 将新创建的viewController 赋值给已经存在的Window中的contentViewController。</span><br><span class="line">otherWindowController.contentViewController = mainViewController</span><br></pre></td></tr></table></figure></p><h3 id="objc-setAssociatedObject-objc-getAssociatedObject"><a href="#objc-setAssociatedObject-objc-getAssociatedObject" class="headerlink" title="objc_setAssociatedObject/objc_getAssociatedObject"></a>objc_setAssociatedObject/objc_getAssociatedObject</h3><p>这两个方式是oc中方法，主要功能是什么呢？。在 oc 中可以使用 <code>Category</code>可以对一些系统类进行添加方法，相当于 Swift 中的 <code>extension</code>的概念，但是我们常用有需求希望能够对一个类中添加一个属性，经常是很难弄，但是 oc 就很好的提供了一个方法 <code>objc_setAssociatedObject</code> 来对一个类进行属性的添加扩展。这是一个运行时修改的库，<br>所以必须要先引入 <code>objc/runtime.h</code> </p><h4 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h4><p>具体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// object 为需要添加属性的类</span><br><span class="line">// key 为保证对象级别唯一的常量</span><br><span class="line">// value 为object 对所添加对象的值</span><br><span class="line">// policy 为关联的策略。</span><br><span class="line">public func objc_setAssociatedObject(_ object: Any, _ key: UnsafeRawPointer, _ value: Any?, _ policy: objc_AssociationPolicy)</span><br></pre></td></tr></table></figure></p><p>关联的策略就像是在 oc 中自定义 property 的引用类型一样。具体对应的类型如下：</p><table><thead><tr><th>策略</th><th>等价属性</th><th>说明</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>@property (assign) or @property (unsafe_unretained)</td><td>弱引用关联对象 </td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>@property (strong, nonatomic)</td><td>强引用关联对象，且为非原子操作 </td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>@property (copy, nonatomic)</td><td>复制关联对象，且为非原子操作 </td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>@property (strong, atomic)</td><td>强引用关联对象，且为原子操作 </td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>@property (copy, atomic)</td><td>复制关联对象，且为原子操作 </td></tr></tbody></table><p>实例如下对 NSApp 添加一个属性值为test:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 执行一个对象变量，后面使用该对象的地址。</span><br><span class="line"> var keyMainString:UInt8 = 0</span><br><span class="line"> objc_setAssociatedObject(NSApplication.shared, &amp;keyMainString, &quot;test&quot;, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)</span><br></pre></td></tr></table></figure></p><h4 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h4><p>上面添加了相应的属性，下面则要获取添加的属性 <code>objc_getAssociatedObject</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let value = objc_getAssociatedObject(NSApplication.shared, &amp;keyMainString)</span><br><span class="line">// 如果上面进行了设置，那么这里将获得的值为“test”</span><br></pre></td></tr></table></figure></p><p>通过上面两个方法就可以对系统类添加一个任意的属性值，和获取系统类的添加的属性值，对了，<strong>如果要移除关联的对象，可以对上面设置的值重新设置为 nil 即可。</strong><br>当然还有一个 <code>objc_removeAssociatedObjects</code>,这样可以把某个对象所设置的所有关联属性全部移除掉，一般都不会这样做，避免引起其他异常。</p><blockquote><p>参考资料：<br><a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="noopener">http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/</a><br><a href="https://www.jianshu.com/p/7f7255d4e76d" target="_blank" rel="noopener">https://www.jianshu.com/p/7f7255d4e76d</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;NSStackView&quot;&gt;&lt;a href=&quot;#NSStackView&quot; class=&quot;headerlink&quot; title=&quot;NSStackView&quot;&gt;&lt;/a&gt;NSStackView&lt;/h3&gt;&lt;p&gt;OSX 中 NSStackView  使用自动布局（系统的自动布局特性）来根据你的要求管理和对齐一组视图。可以设置为 水平方向，或者垂直方向。如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stackView.orientation = .horizontal //水平方向&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;stackView.orientation = .vertical  //垂直方向&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;添加子view&quot;&gt;&lt;a href=&quot;#添加子view&quot; class=&quot;headerlink&quot; title=&quot;添加子view&quot;&gt;&lt;/a&gt;添加子view&lt;/h4&gt;&lt;p&gt;为stackView 中添加 子view的方式如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stackView.addArrangedSubview(view)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意： 由于stackView 是继承自 NSView， 所有也会有 &lt;code&gt;addSubview(view)&lt;/code&gt; 的方法，但是调用此方法，不会自动扩大 stackView 的宽高，而导致新加的view 显示不出来。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;移除子view&quot;&gt;&lt;a href=&quot;#移除子view&quot; class=&quot;headerlink&quot; title=&quot;移除子view&quot;&gt;&lt;/a&gt;移除子view&lt;/h4&gt;&lt;p&gt;移除子 View 采用如下方式：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;stackView.removeArrangedSubview(view) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;view.removeFromSuperview()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：子view从stackView移除后，还必须将子view从父view中移除&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>iOS UIWindow 覆盖 StatusBar</title>
    <link href="http://www.wxtlife.com/2018/08/05/iOS-UIWindow-overlay-StatusBar/"/>
    <id>http://www.wxtlife.com/2018/08/05/iOS-UIWindow-overlay-StatusBar/</id>
    <published>2018-08-05T14:38:07.000Z</published>
    <updated>2018-08-05T14:45:00.591Z</updated>
    
    <content type="html"><![CDATA[<p>最近产品要做一个消息的通知，而且通知是覆盖在 StatusBar 上面的。如果是普通的 UIView 则肯定是不行的，因为 StatusBar 为系统全局性的视图，所以要想覆盖它，则必须为 Statusbar 类型的，那么也就是 UIWindow 了。</p><h3 id="UIWindow-的基础介绍"><a href="#UIWindow-的基础介绍" class="headerlink" title="UIWindow 的基础介绍"></a>UIWindow 的基础介绍</h3><ul><li>UIWindow是一种特殊的UIView,通常在一个app中至少会有一个UIWindow。</li><li>iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的View,最后将控制器的View添加到UIWindow上，于是控制器的View就显示在屏幕上了。</li><li>一个iOS程序之所以能显示在屏幕上，完全是因为它有UIWindow，也就是说，没有UIWindow就看不到任何UI界面。</li><li>状态栏和键盘都是特殊的UIWindow。</li></ul><blockquote><p>这里有三个重要的对象UIScreen，UIWindow，UIView。</p><ol><li>UIScreen对象识别物理屏幕连接到设备</li><li>UIWindow对象提供绘画支持给屏幕</li><li>UIView执行绘画，当窗口要显示内容的时候，UIView绘画出他们的内容并附加到窗口上。</li></ol></blockquote><a id="more"></a><h3 id="UIWindow-等级"><a href="#UIWindow-等级" class="headerlink" title="UIWindow 等级"></a>UIWindow 等级</h3><p>window等级，即window在z轴上的层级关系,默认是0。UIWindowLevel 本身是一个 CGFloat 类型,可以随意设置或进行加减，高等级会显示在低等级上面。系统给出了三种常用等级:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelNormal;      0</span><br><span class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelAlert;       2000</span><br><span class="line">UIKIT_EXTERN const UIWindowLevel UIWindowLevelStatusBar;   4000</span><br></pre></td></tr></table></figure></p><h3 id="初始化-UIWindow-覆盖-StatusBar"><a href="#初始化-UIWindow-覆盖-StatusBar" class="headerlink" title="初始化 UIWindow 覆盖 StatusBar"></a>初始化 UIWindow 覆盖 StatusBar</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-(void)initWindow &#123;</span><br><span class="line">  //初始化statusView,可在其上添加控件</span><br><span class="line">  CGRect statusBarFrame = [UIApplication sharedApplication].statusBarFrame;</span><br><span class="line">  stateWindow = [[UIWindow alloc] initWithFrame:statusBarFrame];</span><br><span class="line">  // 设置windowLevel为statusbar + 1 保证可以显示在statusbar上面</span><br><span class="line">  stateWindow.windowLevel = UIWindowLevelStatusBar + 1;</span><br><span class="line">  stateWindow.backgroundColor = [UIColor orangeColor];</span><br><span class="line">  stateWindow.userInteractionEnabled = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样创建的与 statusbar 大小一样的UIWindow 已经好了，默认创建好 这个UIWindow 则已经添加上去了，只是默认不显示，可以使用下面来控制显示和隐藏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.hidden = YES; </span><br><span class="line">window.hidden = NO;</span><br></pre></td></tr></table></figure></p><p>当然 UIwindow 还有个 <code>makeKeyAndVisible</code> 方法，这个方法会将新建的 UIWindow 设置为主窗口并显示，之后如果消失后，需要将原来的主窗口设置回来，不然会出现很多异常的问题，这里切记。</p><p><strong>注意：控制新添加的 UIWindow 使用 hidden 来控制。尽量不要使用 makeKeyAndVisible</strong></p><p>这里的 stateWindow 必须是私有变量或者全局变量，生命周期随所在控制器的生命周期。</p><h3 id="添加Label"><a href="#添加Label" class="headerlink" title="添加Label"></a>添加Label</h3><p>上面的 UIWindow 创建好了，那么要显示相关的提示文字，还需要添加 label，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">label = [[UILabel alloc] initWithFrame:stateWindow.frame];</span><br><span class="line">label.backgroundColor = [UIColor blackColor];</span><br><span class="line">label.textColor = [UIColor whiteColor];</span><br><span class="line">label.font=[UIFont systemFontOfSize:12];</span><br><span class="line">label.textAlignment = NSTextAlignmentCenter;</span><br><span class="line">[stateWindow addSubview:label];</span><br></pre></td></tr></table></figure></p><p>之后设置 label的文字即可进行对其内容控制。</p><h3 id="旋转问题处理"><a href="#旋转问题处理" class="headerlink" title="旋转问题处理"></a>旋转问题处理</h3><p>上面弄完基本上都完成，但是在旋转屏幕后，发现显示还是在原来的位置上，无法跟随系统的状态栏一起旋转。需要对 Window 设置空的UIViewController后才会跟着状态栏旋转。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 需要设置一个空的ViewController 不然旋转屏幕后，不会跟着旋转坐标系</span><br><span class="line">stateWindow.rootViewController = [UIViewController new];</span><br></pre></td></tr></table></figure></p><p>旋转后，又发现了新的问题，在新建的 UIWindow 根据的是一开始时的状态长宽，但是旋转为横屏时，尺寸会发生变化，所以在每次显示 statusWindow 时重新设置下frame的大小，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CGRect newFrame = CGRectMake(0, 0, [[UIScreen mainScreen] bounds].size.width, STATUSBAR_HEIGHT);</span><br><span class="line">stateWindow.frame = newFrame;</span><br><span class="line">label.frame = newFrame;</span><br></pre></td></tr></table></figure></p><p>这里不直接取 statusbar 的frame，因为在statusbar 隐藏时获取的长宽为0，所以上面设置时取值为宽度和statusbar的高度，高度在一开始进行获取保存进常量中。</p><blockquote><p>综上：对于显示覆盖 statusbar 的 UIWindow 已经完成啦，</p></blockquote><h3 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h3><p>当我们显示了之后一般需要在延迟几秒后进行隐藏，在 Android 中一般实用Handler进行，或者实用timer进行执行操作。那么 ios 中怎么实用呢? 请看如下方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//延迟 3s 后执行 hideStateMsg 方法。</span><br><span class="line"> [self performSelector:@selector(hideStateMsg) withObject:nil afterDelay:3.0];</span><br><span class="line"> </span><br><span class="line"> -(void)hideStateMsg &#123;</span><br><span class="line">  stateWindow.hidden = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然在执行之前可能还需要把之前的延时任务取消了，则有如下两种方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 取消 self 对象中所有的延迟任务。</span><br><span class="line">[NSObject cancelPreviousPerformRequestsWithTarget:self];</span><br><span class="line"></span><br><span class="line">// 取消指定的函数的延迟执行操作。</span><br><span class="line">[NSObject cancelPreviousPerformRequestsWithTarget:self selector:@selector(hideStateMsg) object:nil];</span><br></pre></td></tr></table></figure></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>通过上面的一些问题处理解决，最终能够实现一个覆盖 Statusbar 的View，并且能够在指定时间后消失，达到消息提醒的功能。</p><blockquote><p>参考地址：<br><a href="https://www.cnblogs.com/CoderAlex/p/4762210.html" target="_blank" rel="noopener">https://www.cnblogs.com/CoderAlex/p/4762210.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近产品要做一个消息的通知，而且通知是覆盖在 StatusBar 上面的。如果是普通的 UIView 则肯定是不行的，因为 StatusBar 为系统全局性的视图，所以要想覆盖它，则必须为 Statusbar 类型的，那么也就是 UIWindow 了。&lt;/p&gt;
&lt;h3 id=&quot;UIWindow-的基础介绍&quot;&gt;&lt;a href=&quot;#UIWindow-的基础介绍&quot; class=&quot;headerlink&quot; title=&quot;UIWindow 的基础介绍&quot;&gt;&lt;/a&gt;UIWindow 的基础介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;UIWindow是一种特殊的UIView,通常在一个app中至少会有一个UIWindow。&lt;/li&gt;
&lt;li&gt;iOS程序启动完毕后，创建的第一个视图控件就是UIWindow，接着创建控制器的View,最后将控制器的View添加到UIWindow上，于是控制器的View就显示在屏幕上了。&lt;/li&gt;
&lt;li&gt;一个iOS程序之所以能显示在屏幕上，完全是因为它有UIWindow，也就是说，没有UIWindow就看不到任何UI界面。&lt;/li&gt;
&lt;li&gt;状态栏和键盘都是特殊的UIWindow。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这里有三个重要的对象UIScreen，UIWindow，UIView。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UIScreen对象识别物理屏幕连接到设备&lt;/li&gt;
&lt;li&gt;UIWindow对象提供绘画支持给屏幕&lt;/li&gt;
&lt;li&gt;UIView执行绘画，当窗口要显示内容的时候，UIView绘画出他们的内容并附加到窗口上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://www.wxtlife.com/categories/iOS/"/>
    
    
      <category term="object-c" scheme="http://www.wxtlife.com/tags/object-c/"/>
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="iOS" scheme="http://www.wxtlife.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>OSX webview 与 native 通信简单介绍</title>
    <link href="http://www.wxtlife.com/2018/07/29/osx-webview-native-bridge/"/>
    <id>http://www.wxtlife.com/2018/07/29/osx-webview-native-bridge/</id>
    <published>2018-07-29T15:36:55.000Z</published>
    <updated>2018-07-29T15:44:26.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>在开发混合应用中，经常需要 js 与 webview 进行通信，那么官方也提供了一些方法进行消息处理，今天这里介绍一款开源库来更好的解决的 native 与 js 通信的问题，也就是 <a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge</a></p><h3 id="基本配置使用"><a href="#基本配置使用" class="headerlink" title="基本配置使用"></a>基本配置使用</h3><ol><li>在 Podfile 文件中添加库稳健配置<code>pod &#39;WebViewJavascriptBridge&#39;, &#39;~&gt; 6.0&#39;</code>,然后执行<code>pod install</code></li><li><p>使 WebViewJavascriptBridge 初始化与 Webview 进行绑定 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let bridge: WebViewJavascriptBridge = WebViewJavascriptBridge.init(forWebView: webview)</span><br></pre></td></tr></table></figure></li><li><p>在js层中进行注册处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 将该方法写入 javascript 中</span><br><span class="line">function setupWebViewJavascriptBridge(callback) &#123;</span><br><span class="line">    if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125;</span><br><span class="line">    if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125;</span><br><span class="line">    window.WVJBCallbacks = [callback];</span><br><span class="line">    var WVJBIframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">    WVJBIframe.style.display = &apos;none&apos;;</span><br><span class="line">    WVJBIframe.src = &apos;https://__bridge_loaded__&apos;;</span><br><span class="line">    document.documentElement.appendChild(WVJBIframe);</span><br><span class="line">    setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>经过上面的步骤，基本的搭建就完成了，下面就是要相互注册调用的函数，以及互相调用的方法。</p></li><li>native 层注册方法供 js 调用，以及 native 层调用的js方法。</li></ol><a id="more"></a><h3 id="注册及调用方法"><a href="#注册及调用方法" class="headerlink" title="注册及调用方法"></a>注册及调用方法</h3><ul><li>native 注册方法供 js 调用 （registerHandler）</li></ul><p>native拿到bridge对象后，即可对native的方法进行注册，以便供 js 调用。注册方也比较简单。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bridge.registerHandler(&quot;methodName&quot;) &#123; (jsCallData, responseCallback) in</span><br><span class="line">    // 通过jsCallData 来获取js层调用的方法。</span><br><span class="line">    print(&quot;jsCallData = &quot;, jsCallData)</span><br><span class="line">    let result = &quot;ok&quot;</span><br><span class="line">    // resonpseCallback 用来将处理的结果在返回给到 js 层</span><br><span class="line">    responseCallback(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>js 层注册方法供 native 调用 （registerHandler）</li></ul><p>调用 js 层前面注册的函数进行注册，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line">    bridge.registerHandler(&apos;methodName&apos;, function(data, responseCallback) &#123;</span><br><span class="line">            // data 为 native 调用的方法参数</span><br><span class="line">            log(&apos;ObjC called testJavascriptHandler with&apos;, data)</span><br><span class="line">            var responseData = &#123; &apos;Javascript Says&apos;:&apos;Right back atcha!&apos; &#125;</span><br><span class="line">            log(&apos;JS responding with&apos;, responseData)</span><br><span class="line">            // resonpsecallback 为js处理完告诉native 的结果</span><br><span class="line">            responseCallback(responseData)</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的 native 注册供 js 调用的模式，与 js 注册供 native 调用的方法基本上是一样的，方法，参数，回调等都基本上一致。</p><ul><li><p>native 调用 js  层注册的方法 （callhandler）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// bridge 为native 绑定后的 WebViewJavascriptBridge 对象</span><br><span class="line">// methodName 为js 注册的方法</span><br><span class="line">// data 为调用js的方法参数</span><br><span class="line">// callback 为 js 方法执行后的回调方法。</span><br><span class="line">bridge.callHandler(methodName, data: data, responseCallback: callback)</span><br></pre></td></tr></table></figure></li><li><p>js 调用 native 层注册的方法 （callHanlder）</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</span><br><span class="line">    // data 构造调用native的参数</span><br><span class="line">    var data = &#123;&quot;action&quot;:&quot;connectstate&quot;,&quot;payload&quot;:&#123;&quot;isConnect&quot;: true&#125;&#125;</span><br><span class="line">    // methodName 为native 注册的方法。</span><br><span class="line">    bridge.callHandler(&apos;methodName&apos;, data, function(response) &#123;</span><br><span class="line">        // response 为native 回调的值</span><br><span class="line">        log(&apos;JS got response&apos;, response)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过上面的4个方法，已经把native 与 js 两端的互相注册及调用的讲完。整体上比较简单，两端的方法注册及调用都是互等性的，方法名、参数、回调都一样。理解起来也比较容易。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>主要的原理的通过 <code>function setupWebViewJavascriptBridge(callback) {}</code>方法里添加一个不显示的iframe view， 然后在native 层通过对注定的请求 url 进行拦截，解析出相应的参数。然后利用此特性进行 js 与 native 的互相通信。详细的可以参考文章：</p><blockquote><p>参数文章：<br><a href="https://www.jianshu.com/p/8bd6aeb719ff" target="_blank" rel="noopener">https://www.jianshu.com/p/8bd6aeb719ff</a><br><a href="https://www.jianshu.com/p/d45ce14278c7" target="_blank" rel="noopener">https://www.jianshu.com/p/d45ce14278c7</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;在开发混合应用中，经常需要 js 与 webview 进行通信，那么官方也提供了一些方法进行消息处理，今天这里介绍一款开源库来更好的解决的 native 与 js 通信的问题，也就是 &lt;a href=&quot;https://github.com/marcuswestin/WebViewJavascriptBridge&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebViewJavascriptBridge&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;基本配置使用&quot;&gt;&lt;a href=&quot;#基本配置使用&quot; class=&quot;headerlink&quot; title=&quot;基本配置使用&quot;&gt;&lt;/a&gt;基本配置使用&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在 Podfile 文件中添加库稳健配置&lt;code&gt;pod &amp;#39;WebViewJavascriptBridge&amp;#39;, &amp;#39;~&amp;gt; 6.0&amp;#39;&lt;/code&gt;,然后执行&lt;code&gt;pod install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使 WebViewJavascriptBridge 初始化与 Webview 进行绑定 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;let bridge: WebViewJavascriptBridge = WebViewJavascriptBridge.init(forWebView: webview)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在js层中进行注册处理&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 将该方法写入 javascript 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function setupWebViewJavascriptBridge(callback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (window.WebViewJavascriptBridge) &amp;#123; return callback(WebViewJavascriptBridge); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (window.WVJBCallbacks) &amp;#123; return window.WVJBCallbacks.push(callback); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    window.WVJBCallbacks = [callback];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var WVJBIframe = document.createElement(&amp;apos;iframe&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WVJBIframe.style.display = &amp;apos;none&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    WVJBIframe.src = &amp;apos;https://__bridge_loaded__&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    document.documentElement.appendChild(WVJBIframe);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setTimeout(function() &amp;#123; document.documentElement.removeChild(WVJBIframe) &amp;#125;, 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;经过上面的步骤，基本的搭建就完成了，下面就是要相互注册调用的函数，以及互相调用的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;native 层注册方法供 js 调用，以及 native 层调用的js方法。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（二）</title>
    <link href="http://www.wxtlife.com/2018/07/29/osx-dev-summary-2/"/>
    <id>http://www.wxtlife.com/2018/07/29/osx-dev-summary-2/</id>
    <published>2018-07-29T15:34:48.000Z</published>
    <updated>2018-07-29T15:40:43.472Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><h3 id="在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，"><a href="#在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，" class="headerlink" title="在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，"></a>在OSX使用网络请求时，如果使用的为http请求，需要进行两步操作，</h3><ul><li>1.启动沙盒<br>需要在APP需要启动沙盒具体为：<br>target -&gt; Capabilities -&gt; App Sandbox 将Outgoing Connenctions 沟选上。</li><li>2.在项目Info.Plist 中添加设置<br>添加<code>App Transport Security Settings</code> 设置<code>Allow Arbitrary Loads</code> 为 true</li></ul><h3 id="为OSX项目添加Podfile"><a href="#为OSX项目添加Podfile" class="headerlink" title="为OSX项目添加Podfile"></a>为OSX项目添加Podfile</h3><p>新建一个工程时，需要引用第三方库时，一般实用OPodfile 进行引用，初始化podfile，在项目根目录下执行 <code>pod init</code>， 之后产生 Podfile，然后在产生的文件中添加依赖，再在根目录下执行如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br><span class="line">pod install</span><br></pre></td></tr></table></figure></p><p>然后项目根目录下会产生<code>.xcworkspace</code> 的文件，这时需要将新建的工程关闭，然后使用双击<code>xcworkspace</code>来打开项目。后续添加新的库，只需执行 <code>pod install</code>即可。</p><h3 id="swift-引用-oc-库桥接"><a href="#swift-引用-oc-库桥接" class="headerlink" title="swift 引用 oc 库桥接"></a>swift 引用 oc 库桥接</h3><p>如果开发中使用swift 语言，而库还是用oc语言开发的，如要使用oc库则需要添加一个配置bridge文件并配置在xcode中。</p><ol><li>首先在项目文件名下面新建一个 .h 的文件，文件名一般为<code>项目名+bridge.h</code>,例如<code>TestDemo-Bridging-Header.h</code></li><li>在该 .h 的文件中添加引入 oc 库的头文件，例如<code>#import &lt;DevMateKit/DevMateKit.h&gt;</code></li><li>选中项目根目录，进入项目设置，选中 target 选项，找到<code>swift Compiler -General</code>,下面有项为：<code>Object-C Bridging Header</code>, 双击进入编辑状态，然后将前面新建的.h文件拖到编辑框内，路径会自动填充上（绝对路径），然后重新编译项目即可。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队
      
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>OSX 开发知识点汇总（一）</title>
    <link href="http://www.wxtlife.com/2018/07/22/osx-dev-summary-1/"/>
    <id>http://www.wxtlife.com/2018/07/22/osx-dev-summary-1/</id>
    <published>2018-07-22T09:33:41.000Z</published>
    <updated>2018-07-29T15:35:52.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>下面为最近使用swift 进行 OSX 开发中，对于一些知识点的总结与汇总，主要是跨行过来，很多内容都不太熟悉，所以这里进行一部分的记录与总结，方便日后的回顾与思考，后续有新的也会继续进行补充。</p><h3 id="swift-代码同步块"><a href="#swift-代码同步块" class="headerlink" title="swift 代码同步块"></a>swift 代码同步块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_sync_enter(Obj)</span><br><span class="line"> //code </span><br><span class="line">objc_sync_exit(Obj)</span><br></pre></td></tr></table></figure><p>在上面两句话中间的语句则为同步代码块，Obj 为锁的对象。类似Java中的 synchronized(Obj)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//代码块</span><br><span class="line">synchronized(Obj) &#123;</span><br><span class="line">    //cide </span><br><span class="line">&#125;</span><br><span class="line">// synchronized 用到方法上</span><br><span class="line">public void synchronized method() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考：<a href="http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/" target="_blank" rel="noopener">http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/</a></p><h3 id="swift-布局约束"><a href="#swift-布局约束" class="headerlink" title="swift 布局约束"></a>swift 布局约束</h3><p>1、在Xib或者StoryBoard中的view间的依赖，都正常但是无法按照我们预期的显示，这时需要检查 约束之间的优先级，通常这部分很容易导致View依赖出现错误，而很难排查。</p><p>2、在定义布局时，有图片控件ImageView的时候，默认指定了图片，这时相当于控件的大小是固定的，如果我们想让其铺满父view，设置了相应的约束，但是实际运行中不起作用</p><p>原因： ImageView已经有图片，所以默认其图片是固定大小了，也就意味着ImageView是固定的了，所以这时view不会跟随父view铺满全屏，想要以 ImageView 的大小铺满父View，则 ImageView 的优先级则应该要低一些。 在xib中选中相应的ImageView，在约束那找到 Content compression resistance priority,将其优先级进行降低，也就是视图越容易被压缩。</p><p>如果在其他需求中ImageView不想被压缩，想要拉伸，而是设置Content Hugging Priority</p><p>约束优先级: 在Autolayout中每个约束都有一个优先级, 优先级的范围是1 ~ 1000。创建一个约束，默认的优先级是最高的1000</p><p>下面是关于两种属性的解释说明：</p><a id="more"></a><p><strong>Content Hugging Priority:</strong> 该优先级表示一个控件抗被拉伸的优先级。优先级越高，越不容易被拉伸，默认是250。</p><p><strong>Content Compression Resistance Priority:</strong> 该优先级和上面那个优先级相对应，表示一个控件抗压缩的优先级。优先级越高，越不容易被压缩，默认是750</p><p>下面是第二种解释说法：</p><p><strong>Content Hugging Priority：</strong> 直译成中文就是“内容拥抱优先级”，从字面意思上来看就是两个视图，谁的“内容拥抱优先级”高，谁就优先环绕其内容。稍后我们会根据一些示例进行介绍。</p><p><strong>Content Compression Resistance Priority：</strong> 该优先级直译成中文就是“内容压缩阻力优先级”。也就是视图的“内容压缩阻力优先级”越大，那么该视图中的内容越难被压缩。而该优先级小的视图，则内容优先被压缩。稍后我们也会通过相应的实例来看一下这个优先级的具体表现。</p><blockquote><p>参考链接:<br><a href="https://www.cnblogs.com/ludashi/p/7373051.html" target="_blank" rel="noopener">https://www.cnblogs.com/ludashi/p/7373051.html</a><br><a href="https://juejin.im/entry/58b3d97c8d6d810057f5b647" target="_blank" rel="noopener">https://juejin.im/entry/58b3d97c8d6d810057f5b647</a></p></blockquote><h3 id="osx中监听窗口大小及状态的变化"><a href="#osx中监听窗口大小及状态的变化" class="headerlink" title="osx中监听窗口大小及状态的变化"></a>osx中监听窗口大小及状态的变化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(self.enterFullScreen), name: NSWindow.willEnterFullScreenNotification, object: nil)</span><br><span class="line"></span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(self.exitFullScreen), name: NSWindow.willExitFullScreenNotification, object: nil)</span><br><span class="line"></span><br><span class="line">NotificationCenter.default.addObserver(self, selector: #selector(self.didResizeChanged), name: NSWindow.didResizeNotification, object: nil)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@objc dynamic func enterFullScreen() &#123;</span><br><span class="line">    print(&quot;窗口将进入全屏&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@objc dynamic func exitFullScreen() &#123;</span><br><span class="line">    print(&quot;窗口将退出全屏&quot;)   </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">@objc dynamic func didResizeChanged() &#123;</span><br><span class="line">    print(&quot;窗口大小变化&quot;)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 取消监听：</span><br><span class="line">NotificationCenter.default.removeObserver(self)</span><br></pre></td></tr></table></figure><p>当然在还有其他的 NSWindow.***Notification 类型的通知，按需监听，并进行处理。</p><h3 id="使用-Masonry-如何删掉约束"><a href="#使用-Masonry-如何删掉约束" class="headerlink" title="使用 Masonry 如何删掉约束"></a>使用 Masonry 如何删掉约束</h3><p>Masonry 是在ios与osx开发中 autolayout 进行动态布局约束不可或缺的一个好帮手，可以描述为可视化的语言去描述约束的情况。对于开发非常的方便。</p><p>对于删除动态约束可使用 MASConstraint 的 uninstall 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var constraint: MASConstraint? </span><br><span class="line"></span><br><span class="line">// 设置约束，并赋值</span><br><span class="line">view.remakeConstraints&#123; maker in </span><br><span class="line">  constraint = maker?.width.equal()(self)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除约束</span><br><span class="line">constraint?.uninstall()</span><br><span class="line"></span><br><span class="line">//当然也可以使用 install添加约束</span><br><span class="line">constraint?.install()</span><br></pre></td></tr></table></figure></p><h3 id="RxSwift-中debounce-与-throttle-的区别"><a href="#RxSwift-中debounce-与-throttle-的区别" class="headerlink" title="RxSwift 中debounce 与 throttle 的区别"></a>RxSwift 中debounce 与 throttle 的区别</h3><p>下面是官方的意思</p><ul><li>Throttle: the original function be called at most once per specified period.</li><li>Debounce: the original function be called after the caller stops calling the decorated function after a specified period.</li></ul><p>下面为我个人的理解，及使用场景</p><ul><li>throttle  :  一般会指定一个时间值，在这个时间里，最多只执行一次，比如常见开发中避免狂点 button，需要对点击时间进行控制的， 就可以使用来指定</li><li>debounce： 指定的一个时间值内，没有新消息触发，则返回最后一个值，如果指定事件内有新消息触发，则取消旧消息，直到没有新消息来在执行后面的操作，这种应用场景在，数据不断变化时，可以对中间的数据变化不做处理，直到指定时间不再变化时在进行以最后一次的数据进行刷新。</li></ul><p>参考链接: <a href="https://medium.com/@dkhuong291/throttle-vs-debounce-in-rxswift-86f8b303d5d4" target="_blank" rel="noopener">https://medium.com/@dkhuong291/throttle-vs-debounce-in-rxswift-86f8b303d5d4</a></p><h3 id="OSX-上NSTextField-支持复制粘贴"><a href="#OSX-上NSTextField-支持复制粘贴" class="headerlink" title="OSX 上NSTextField 支持复制粘贴"></a>OSX 上NSTextField 支持复制粘贴</h3><p>在mac os 上开发，去掉了应用的edit menu后导致后续的 NSTextField 无法直接使用 command + c或者 command + v 进行复制粘贴。所以想要支持的化，需要复写 performKeyEquivalent 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private let commandKey = NSEvent.ModifierFlags.command.rawValue</span><br><span class="line">private let commandShiftKey = NSEvent.ModifierFlags.command.rawValue | NSEvent.ModifierFlags.shift.rawValue</span><br><span class="line">// 在 NSTextField 子类中进行复写 performKeyEquivalent 方法。    </span><br><span class="line">override func performKeyEquivalent(with event: NSEvent) -&gt; Bool &#123;</span><br><span class="line">        if event.type == NSEvent.EventType.keyDown &#123;</span><br><span class="line">            if (event.modifierFlags.rawValue &amp; NSEvent.ModifierFlags.deviceIndependentFlagsMask.rawValue) == commandKey &#123;</span><br><span class="line">                switch event.charactersIgnoringModifiers! &#123;</span><br><span class="line">                case &quot;x&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSText.cut(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;c&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSText.copy(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;v&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSText.paste(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;z&quot;:</span><br><span class="line">                    if NSApp.sendAction(Selector((&quot;undo:&quot;)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                case &quot;a&quot;:</span><br><span class="line">                    if NSApp.sendAction(#selector(NSResponder.selectAll(_:)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                default:</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (event.modifierFlags.rawValue &amp; NSEvent.ModifierFlags.deviceIndependentFlagsMask.rawValue) == commandShiftKey &#123;</span><br><span class="line">                if event.charactersIgnoringModifiers == &quot;Z&quot; &#123;</span><br><span class="line">                    if NSApp.sendAction(Selector((&quot;redo:&quot;)), to:nil, from:self) &#123; return true &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.performKeyEquivalent(with: event)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>添加上上面的复写方法后，即可对NSTextField的控件支持复制粘贴快捷键操作。</p><blockquote><p>参考：<a href="https://stackoverflow.com/questions/970707/cocoa-keyboard-shortcuts-in-dialog-without-an-edit-menu/3746058" target="_blank" rel="noopener">https://stackoverflow.com/questions/970707/cocoa-keyboard-shortcuts-in-dialog-without-an-edit-menu/3746058</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;下面为最近使用swift 进行 OSX 开发中，对于一些知识点的总结与汇总，主要是跨行过来，很多内容都不太熟悉，所以这里进行一部分的记录与总结，方便日后的回顾与思考，后续有新的也会继续进行补充。&lt;/p&gt;
&lt;h3 id=&quot;swift-代码同步块&quot;&gt;&lt;a href=&quot;#swift-代码同步块&quot; class=&quot;headerlink&quot; title=&quot;swift 代码同步块&quot;&gt;&lt;/a&gt;swift 代码同步块&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;objc_sync_enter(Obj)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; //code &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_sync_exit(Obj)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在上面两句话中间的语句则为同步代码块，Obj 为锁的对象。类似Java中的 synchronized(Obj)&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//代码块&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;synchronized(Obj) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //cide &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// synchronized 用到方法上&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void synchronized method() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://swift.gg/2017/09/04/all-about-concurrency-in-swift-1-the-present/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;swift-布局约束&quot;&gt;&lt;a href=&quot;#swift-布局约束&quot; class=&quot;headerlink&quot; title=&quot;swift 布局约束&quot;&gt;&lt;/a&gt;swift 布局约束&lt;/h3&gt;&lt;p&gt;1、在Xib或者StoryBoard中的view间的依赖，都正常但是无法按照我们预期的显示，这时需要检查 约束之间的优先级，通常这部分很容易导致View依赖出现错误，而很难排查。&lt;/p&gt;
&lt;p&gt;2、在定义布局时，有图片控件ImageView的时候，默认指定了图片，这时相当于控件的大小是固定的，如果我们想让其铺满父view，设置了相应的约束，但是实际运行中不起作用&lt;/p&gt;
&lt;p&gt;原因： ImageView已经有图片，所以默认其图片是固定大小了，也就意味着ImageView是固定的了，所以这时view不会跟随父view铺满全屏，想要以 ImageView 的大小铺满父View，则 ImageView 的优先级则应该要低一些。 在xib中选中相应的ImageView，在约束那找到 Content compression resistance priority,将其优先级进行降低，也就是视图越容易被压缩。&lt;/p&gt;
&lt;p&gt;如果在其他需求中ImageView不想被压缩，想要拉伸，而是设置Content Hugging Priority&lt;/p&gt;
&lt;p&gt;约束优先级: 在Autolayout中每个约束都有一个优先级, 优先级的范围是1 ~ 1000。创建一个约束，默认的优先级是最高的1000&lt;/p&gt;
&lt;p&gt;下面是关于两种属性的解释说明：&lt;/p&gt;
    
    </summary>
    
      <category term="OSX" scheme="http://www.wxtlife.com/categories/OSX/"/>
    
    
      <category term="swift" scheme="http://www.wxtlife.com/tags/swift/"/>
    
      <category term="Mac" scheme="http://www.wxtlife.com/tags/Mac/"/>
    
      <category term="OSX" scheme="http://www.wxtlife.com/tags/OSX/"/>
    
  </entry>
  
  <entry>
    <title>比 cat 更好用的命令了解一下？</title>
    <link href="http://www.wxtlife.com/2018/05/20/bat-tool/"/>
    <id>http://www.wxtlife.com/2018/05/20/bat-tool/</id>
    <published>2018-05-20T13:50:58.000Z</published>
    <updated>2018-05-20T14:32:08.629Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>作为程序员经常使用命令行来进行一些文件的处理，比如常见的：<code>git</code>， <code>vim</code> ，以及不同语言下的一些命令等。那么这么多的命令中，相信你肯定有用过<code>cat</code>命令用来查看文件的内容，但是这个命令仅仅只能将文本展示出来，并不会很好的辅助我们阅读和理解里面的内容，尤其是文件中内容为 代码时，看起来就特别的痛苦了。那么这篇文章就要介绍更好命令来替代 <code>cat</code>命令，它就是<code>bat</code>命令。（不是windows中的那个脚本哟）</p><h3 id="bat介绍"><a href="#bat介绍" class="headerlink" title="bat介绍"></a>bat介绍</h3><p><code>bat</code> 是一个语法高亮显示和<code>Git</code>集成的<code>cat</code>高级版本，也就是说，<code>bat</code> 有 <code>cat</code>的所有功能，且已经集成了代码高亮，和<code>git</code>版本管理的工具，并且会对过长的文件进行自动分页，不会像 <code>cat</code> 一样全部一次打印,先来看张效果图：</p><p><img src="https://camo.githubusercontent.com/9d3d89364f2cc83ace8f29646a6236bc15ea1da0/68747470733a2f2f696d6775722e636f6d2f724773646e44652e706e67" alt=""></p><a id="more"></a><h3 id="bat安装"><a href="#bat安装" class="headerlink" title="bat安装"></a>bat安装</h3><p>安装的方法也是超级的简单，具体安装如下：</p><ul><li>Linux 上</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://aur.archlinux.org/bat.git</span><br><span class="line">cd bat</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure><ul><li>MACOS 上<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install bat</span><br></pre></td></tr></table></figure></li></ul><p>安装完成后，输入<code>bat -help</code> 看下是否会出现相关的提示信息，来确认是否安装成功。</p><h3 id="bat使用"><a href="#bat使用" class="headerlink" title="bat使用"></a>bat使用</h3><p>使用与 <code>cat</code> 类似，在 <code>bat</code> 后面紧跟文件 就行了， 也可以同时打开过个，但结果是以一个接一个展示出来。</p><p>如打开一个有 <code>git</code> 管理的文件，会展示出文件中添加与删除的部分，如下图所示：<br><img src="https://camo.githubusercontent.com/67e44f4a68150325f74b3a46820b7473ff7b91a6/68747470733a2f2f692e696d6775722e636f6d2f326c53573452452e706e67" alt=""></p><p>如果需要制定文件中高亮的语言，可以使用 <code>-l</code> 参数来制定语言，例如：<br><code>bat  ./test.json -l json</code> 则指定文件中高亮为 json 模式，当然不指定也没有问题，默认会自动识别。<br>总之使用还是比较简单，一点都不复杂。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>如果有了这个命令，我想一般都不会再用 <code>cat</code>命令了，但每次敲命令都习惯使用 <code>cat</code> 了， 那么建议将 cat 命令使用 <code>alias cat= &#39;bat&#39;</code> 将其指定为 <code>bat</code> 这样就可以使用<code>cat</code> 命令，而达到 <code>bat</code> 的使用效果。</p><p>希望大家能够喜欢这篇文章，喜欢就分享出去吧。 如果你有更好的命令，欢迎留言交流。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;作为程序员经常使用命令行来进行一些文件的处理，比如常见的：&lt;code&gt;git&lt;/code&gt;， &lt;code&gt;vim&lt;/code&gt; ，以及不同语言下的一些命令等。那么这么多的命令中，相信你肯定有用过&lt;code&gt;cat&lt;/code&gt;命令用来查看文件的内容，但是这个命令仅仅只能将文本展示出来，并不会很好的辅助我们阅读和理解里面的内容，尤其是文件中内容为 代码时，看起来就特别的痛苦了。那么这篇文章就要介绍更好命令来替代 &lt;code&gt;cat&lt;/code&gt;命令，它就是&lt;code&gt;bat&lt;/code&gt;命令。（不是windows中的那个脚本哟）&lt;/p&gt;
&lt;h3 id=&quot;bat介绍&quot;&gt;&lt;a href=&quot;#bat介绍&quot; class=&quot;headerlink&quot; title=&quot;bat介绍&quot;&gt;&lt;/a&gt;bat介绍&lt;/h3&gt;&lt;p&gt;&lt;code&gt;bat&lt;/code&gt; 是一个语法高亮显示和&lt;code&gt;Git&lt;/code&gt;集成的&lt;code&gt;cat&lt;/code&gt;高级版本，也就是说，&lt;code&gt;bat&lt;/code&gt; 有 &lt;code&gt;cat&lt;/code&gt;的所有功能，且已经集成了代码高亮，和&lt;code&gt;git&lt;/code&gt;版本管理的工具，并且会对过长的文件进行自动分页，不会像 &lt;code&gt;cat&lt;/code&gt; 一样全部一次打印,先来看张效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/9d3d89364f2cc83ace8f29646a6236bc15ea1da0/68747470733a2f2f696d6775722e636f6d2f724773646e44652e706e67&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>【工具】github 插件源码浏览利器 Insight</title>
    <link href="http://www.wxtlife.com/2018/04/02/chrome-insight/"/>
    <id>http://www.wxtlife.com/2018/04/02/chrome-insight/</id>
    <published>2018-04-02T14:23:38.000Z</published>
    <updated>2018-05-20T13:56:19.798Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在之前的一篇文章中<a href="http://www.wxtlife.com/2017/09/27/developers-need-tools/">《开发人员必备的开发利器》</a>有介绍过一款Chrome插件，名为 Octotree ，它可以以树形结构的样式将源代码源文件展示出来，方便我们查看跳转等。但是有时候在github上看源码时，可能需要进行方法的跳转，查看具体实现，更或者找到某个方法或者类的调用方，那么有没有既有 Octotree 功能又能实现上面的功能呢，那当然是有的，它就是今天要介绍的主角 <code>insight.io</code> </p><h3 id="insight-io-使用"><a href="#insight-io-使用" class="headerlink" title="insight.io 使用"></a>insight.io 使用</h3><p>insight.io 也是一个Chrome 插件， 安装也就直接在Chrome插件中心搜索安装就行了，这里就不多描述。<br>安装好后，在首次安装上后需要使用github账号进行授权登录，之后会进行一些操作相关的提示。<br>整体的界面如下所示</p><p><img src="../img/insight/insight_view.png" alt="insight"></p><p>整体的风格还是很简约，清新的，很是喜欢。</p><p>这样上面树形结构的源代码已经展示出来了。</p><p>但在使用的时候有几点需要注意，此插件不是所有的github 项目都支持，你可以查看页面中间有个提示信息，如果为<code>ready</code> 则可以直接使用，如果提示<code>not indexed</code> 则说明未包含此项目，需要你手动提交，点击即可，之后会进行索引，成功后会邮件通知你，时间大约在半个小时以内，大的项目可能会比较久（本人尝试的时间不到5分钟就OK了），但是不能直接提交fork出来的仓库，fork的仓库可以通过邮件联系对方，可能需要pro付费版本支持。</p><a id="more"></a><h3 id="重点功能"><a href="#重点功能" class="headerlink" title="重点功能"></a>重点功能</h3><h4 id="文件类结构，"><a href="#文件类结构，" class="headerlink" title="文件类结构，"></a>文件类结构，</h4><p>客户以像ide一样展示出当前类的方法名及变量名，并且点击跳到相应行，很是方便，完全就像个ide一样。<br>如下图所示：</p><p><img src="http://www.imgeek.org/uploads/article/20170214/a2a38c0d8fc80e7fd2b0ba8fe8bc8f18.gif" alt=""></p><h4 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h4><p>基于对源代码的语意分析，在搜索时开发者可以直接按照类名，方法名，变量名等搜索，并且Codatlas提供自动补全功能。</p><p><img src="http://www.imgeek.org/uploads/article/20170214/634f52fba750388bc8a82a3419cc1ff6.gif" alt=""></p><h4 id="跳转到定义"><a href="#跳转到定义" class="headerlink" title="跳转到定义"></a>跳转到定义</h4><p>在源码中的方法，类，变量等，都会在下方有下划线表示可直接跳转，有些甚至包含系统的方法，鼠标直接点击即可，想快速看到代码中的类，变量或者方法是如何定义的？没问题，点击类，变量或者方法被使用的地方就会跳转到相应定义的地方。不仅可以在项目内部跳转，跨项目也同样可以实现跳转。如下图所示：</p><p><img src="http://www.imgeek.org/uploads/article/20170214/a3b95f46f04269ba4215ee47df14e7b1.gif" alt=""></p><h4 id="查找引用"><a href="#查找引用" class="headerlink" title="查找引用"></a>查找引用</h4><p>可以对方法或者类查找引用的地方，并安类文件罗列出来，直接点击即可查看引用的具体地方。<br>如果想知道代码中的类，变量或者方法在代码库中哪些地方被使用了，可以点击类，变量或者方法的定义处来显示所有被引用的地方。引用会被进一步分成Referenced At Inherit Override等子类型方便开发者进一步缩小查找范围，如下图所示：</p><p><img src="http://www.imgeek.org/uploads/article/20170214/e8f8041cb427fc620c7c89e9ec8cd20c.gif" alt=""></p><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>在设置中还有很多的快捷键可以设置，协助我们快速的浏览源代码，如下：<br><img src="../img/insight/insight-setting.png" alt="setting"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>此插件的功能很全，页面也很美观，很是喜欢，目前有了它在 github 上看源码方便很多，甚至就不用clone到本地再导入这些复杂的操作流程。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在之前的一篇文章中&lt;a href=&quot;http://www.wxtlife.com/2017/09/27/developers-need-tools/&quot;&gt;《开发人员必备的开发利器》&lt;/a&gt;有介绍过一款Chrome插件，名为 Octotree ，它可以以树形结构的样式将源代码源文件展示出来，方便我们查看跳转等。但是有时候在github上看源码时，可能需要进行方法的跳转，查看具体实现，更或者找到某个方法或者类的调用方，那么有没有既有 Octotree 功能又能实现上面的功能呢，那当然是有的，它就是今天要介绍的主角 &lt;code&gt;insight.io&lt;/code&gt; &lt;/p&gt;
&lt;h3 id=&quot;insight-io-使用&quot;&gt;&lt;a href=&quot;#insight-io-使用&quot; class=&quot;headerlink&quot; title=&quot;insight.io 使用&quot;&gt;&lt;/a&gt;insight.io 使用&lt;/h3&gt;&lt;p&gt;insight.io 也是一个Chrome 插件， 安装也就直接在Chrome插件中心搜索安装就行了，这里就不多描述。&lt;br&gt;安装好后，在首次安装上后需要使用github账号进行授权登录，之后会进行一些操作相关的提示。&lt;br&gt;整体的界面如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../img/insight/insight_view.png&quot; alt=&quot;insight&quot;&gt;&lt;/p&gt;
&lt;p&gt;整体的风格还是很简约，清新的，很是喜欢。&lt;/p&gt;
&lt;p&gt;这样上面树形结构的源代码已经展示出来了。&lt;/p&gt;
&lt;p&gt;但在使用的时候有几点需要注意，此插件不是所有的github 项目都支持，你可以查看页面中间有个提示信息，如果为&lt;code&gt;ready&lt;/code&gt; 则可以直接使用，如果提示&lt;code&gt;not indexed&lt;/code&gt; 则说明未包含此项目，需要你手动提交，点击即可，之后会进行索引，成功后会邮件通知你，时间大约在半个小时以内，大的项目可能会比较久（本人尝试的时间不到5分钟就OK了），但是不能直接提交fork出来的仓库，fork的仓库可以通过邮件联系对方，可能需要pro付费版本支持。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="【github,Tools]" scheme="http://www.wxtlife.com/tags/%E3%80%90github-Tools/"/>
    
  </entry>
  
  <entry>
    <title>强大的终端工具ohMyZsh</title>
    <link href="http://www.wxtlife.com/2018/03/21/oh-my-zsh/"/>
    <id>http://www.wxtlife.com/2018/03/21/oh-my-zsh/</id>
    <published>2018-03-21T15:43:14.000Z</published>
    <updated>2018-05-20T14:31:57.714Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天给大家介绍一款强大的终端工具，一般系统默认的终端一般都很鸡肋，要么功能不够智能，要么就是不够美观，这怎么能够体现程序员高大上的逼格呢，所以今天就给大家介绍一款强大的终端工具 <code>oh-my-zsh</code>.</p><p>先来看张我的终端<br><img src="../img/ohmyzsh/ohmyzsh.png" alt="image"></p><p>那么有什么强大的功能呢？</p><ol><li>智能提示</li><li>自动跳转</li><li>智能纠错</li><li>与git 等工具高度集成</li><li>历史记录功能</li><li>目录跳转等</li></ol><p>上面只是我觉得很好用的一些功能，这只是冰山一角，还有其他很多的插件功能，反正一句话就是用了之后你就忘不掉的一个终端。</p><h3 id="什么是-ohMyZsh-介绍"><a href="#什么是-ohMyZsh-介绍" class="headerlink" title="什么是 ohMyZsh 介绍"></a>什么是 ohMyZsh 介绍</h3><p>首先的介绍下 <code>Zsh</code> ，<code>Zsh</code> 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。且其兼容Bash，能够为其补充很多强大的功能。那么 <code>Oh My Zsh</code> 是一款社区驱动的命令行工具，正如它的主页上说的，<code>Oh My Zsh</code> 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。<br><code>ohMyZsh</code> 拥有 200+ 的插件，及140+ 的主题样式，供你任意搭配定制。</p><a id="more"></a><h3 id="安装ohMyZsh"><a href="#安装ohMyZsh" class="headerlink" title="安装ohMyZsh"></a>安装ohMyZsh</h3><ol><li><p>通过 curl 方式安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></li><li><p>通过wget 方式安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</span><br></pre></td></tr></table></figure></li></ol><p>如果提示有文件没权限，可使用 sudo 命令进行安装。</p><p>安装完成后，验证是否安装成功。</p><p>如果输入 <code>zsh --version</code> 输出版本号则为安装成功。</p><p>使用 <code>chsh -s $(which zsh)</code> 讲默认的shell切换为zsh，然后通过 <code>$SHELL</code> 检查是否设置成功，如果输出为 <code>/bin/zsh</code>， 则切换默认为zsh 成功。</p><h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p><code>ohMyZsh</code>拥有很多的主题及插件，可以按照自己的需求来定制，那么怎么配置呢？<br>ohMyZsh 所有的配置都在用户根目录下面的 <code>~/.zshrc</code> 文件中进行配置。</p><p>主题文件的种类及样式可以到网页上查看 <a href="https://github.com/robbyrussell/oh-my-zsh/wiki/Themes" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/wiki/Themes</a><br>默认安装就会有很多的主题样式可供配置了，本地主题的文件路径为 <code>~/.oh-my-zsh/themes</code> 可以进行查看。</p><p>喜欢某个主题只需要在 zshrc 文件中的 <code>ZSH_THEME=&quot;XXX&quot;</code>(XXX 为主题名) 例如我的主题为 <code>ZSH_THEME=&quot;agnoster&quot;</code> (<strong>安装这个主题需要安装字体库，因为其中用到了特殊字符</strong>)，具体安装教程可参考官方 <a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">https://github.com/agnoster/agnoster-zsh-theme</a> ,下面也有一些我遇到的问题汇总，如果还有问题可在公众号上留言与我交流。</p><p>样式如下：<br><img src="https://gist.githubusercontent.com/agnoster/3712874/raw/screenshot.png" alt="agnoster"></p><h3 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h3><p>插件的种类实在是太多了，以至于有些插件的功能都不清楚，只能说是有需求的时候再去插件库找找是否有满足自己需求的插件。<br>插件库地址如下： <a href="https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/tree/master/plugins</a><br>本地安装的插件库地址为 <code>~/.oh-my-zsh/plugins</code>。</p><p>添加插件的方法为在<code>~/.zshrc</code> 中，按照下面的格式将插件名称填入即可，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  git</span><br><span class="line">  brew</span><br><span class="line">  adb</span><br><span class="line">  npm</span><br><span class="line">  gradle</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>之后则可以体检到这些插件给你带来的便捷。</p><h3 id="异常问题汇总"><a href="#异常问题汇总" class="headerlink" title="异常问题汇总"></a>异常问题汇总</h3><h4 id="1-终端显示异常"><a href="#1-终端显示异常" class="headerlink" title="1. 终端显示异常"></a>1. 终端显示异常</h4><p>使用 agnoster 主题时， 显示的当前路径及分支信息出现部分乱码，显示很乱。</p><p><strong>解决办法：</strong><br>首先按照<a href="https://github.com/agnoster/agnoster-zsh-theme" target="_blank" rel="noopener">https://github.com/agnoster/agnoster-zsh-theme</a>进行安装，记得一定要安装字体。<br>推荐使用iterm2 然后在 <code>iTerm -&gt; Preferences -&gt; Profiles -&gt; Text</code><br>在下方将 <code>use a different font for non-ASCll text</code> 去掉勾选即可。</p><h4 id="2-默认终端显示名字过长"><a href="#2-默认终端显示名字过长" class="headerlink" title="2. 默认终端显示名字过长"></a>2. 默认终端显示名字过长</h4><p>默认显示了 <a href="mailto:username@host.machine" target="_blank" rel="noopener">username@host.machine</a> 显得很长， 不美观。</p><p><strong>解决办法：</strong></p><ul><li>方法1. 在 .zshrc 中添加  <code>DEFAULT_USER=&quot;$USER&quot;</code></li><li>方法2. 在.zshrc 最末尾，添加下面脚本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt_context() &#123;</span><br><span class="line">  if [[ &quot;$USER&quot; != &quot;$DEFAULT_USER&quot; || -n &quot;$SSH_CLIENT&quot; ]]; then</span><br><span class="line">    prompt_segment black default &quot;%(!.%&#123;%F&#123;yellow&#125;%&#125;.)$USER&quot;</span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-使用-ohmyzsh-后，-bash-profile-及-bashrc-不起作用"><a href="#3-使用-ohmyzsh-后，-bash-profile-及-bashrc-不起作用" class="headerlink" title="3. 使用 ohmyzsh 后，~/.bash_profile 及 ~/.bashrc 不起作用"></a>3. 使用 ohmyzsh 后，~/.bash_profile 及 ~/.bashrc 不起作用</h4><p><strong>解决办法：</strong><br>这是由于默认使用是zsh， 所以不会按照<code>/etc/profile --&gt;  /etc/paths  ---&gt;  ~/.bash_profile ---&gt; ~/.bash_login ---&gt;  ~/.profile ---&gt; ~/.bashrc</code><br>所以需要在~/.zshrc 的末尾加上加载文件的脚本，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if [ -f ~/.bash_profile ]; then</span><br><span class="line">   source ~/.bash_profile</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f ~/.bashrc ]; then</span><br><span class="line">   source ~/.bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p>退出终端，然后重新加载即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;今天给大家介绍一款强大的终端工具，一般系统默认的终端一般都很鸡肋，要么功能不够智能，要么就是不够美观，这怎么能够体现程序员高大上的逼格呢，所以今天就给大家介绍一款强大的终端工具 &lt;code&gt;oh-my-zsh&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;先来看张我的终端&lt;br&gt;&lt;img src=&quot;../img/ohmyzsh/ohmyzsh.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么有什么强大的功能呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;智能提示&lt;/li&gt;
&lt;li&gt;自动跳转&lt;/li&gt;
&lt;li&gt;智能纠错&lt;/li&gt;
&lt;li&gt;与git 等工具高度集成&lt;/li&gt;
&lt;li&gt;历史记录功能&lt;/li&gt;
&lt;li&gt;目录跳转等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面只是我觉得很好用的一些功能，这只是冰山一角，还有其他很多的插件功能，反正一句话就是用了之后你就忘不掉的一个终端。&lt;/p&gt;
&lt;h3 id=&quot;什么是-ohMyZsh-介绍&quot;&gt;&lt;a href=&quot;#什么是-ohMyZsh-介绍&quot; class=&quot;headerlink&quot; title=&quot;什么是 ohMyZsh 介绍&quot;&gt;&lt;/a&gt;什么是 ohMyZsh 介绍&lt;/h3&gt;&lt;p&gt;首先的介绍下 &lt;code&gt;Zsh&lt;/code&gt; ，&lt;code&gt;Zsh&lt;/code&gt; 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。且其兼容Bash，能够为其补充很多强大的功能。那么 &lt;code&gt;Oh My Zsh&lt;/code&gt; 是一款社区驱动的命令行工具，正如它的主页上说的，&lt;code&gt;Oh My Zsh&lt;/code&gt; 是一种生活方式。它基于zsh命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。&lt;br&gt;&lt;code&gt;ohMyZsh&lt;/code&gt; 拥有 200+ 的插件，及140+ 的主题样式，供你任意搭配定制。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://www.wxtlife.com/tags/Tools/"/>
    
      <category term="ohmyzsh" scheme="http://www.wxtlife.com/tags/ohmyzsh/"/>
    
  </entry>
  
  <entry>
    <title>【推荐】日志分析查看神器</title>
    <link href="http://www.wxtlife.com/2018/02/27/log-tools/"/>
    <id>http://www.wxtlife.com/2018/02/27/log-tools/</id>
    <published>2018-02-27T14:34:16.000Z</published>
    <updated>2018-03-16T15:49:44.454Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在开发中定位问题或者调试常常需要分析日志文件，但是对于日志文件一不小心就几百行甚至上千行的相信大家都有些惧怕，尤其在定位问题查看日志时，而且还有不同的tag需要过滤时，看了这个 tag，又要看另外一个 tag，到最后自己都凌乱了，不知道看到哪里了，看了哪些忘了那些，等等很多问题影响效率。</p><p>今天要给大家推荐一个查看日志的神器，至少我现在查看文本日志文件时，不会那么心累了，这款神器软件名字为：<strong>BBEditor</strong> ,遗憾的是目前只有 Mac 版，且也是收费的，不过作为福利，文末会给大家下载地址及注册码，让大家也来感受下查看日志的便捷。</p><a id="more"></a><h3 id="BBEditor-使用"><a href="#BBEditor-使用" class="headerlink" title="BBEditor 使用"></a>BBEditor 使用</h3><ol><li>打开此软件与普通文本软件没什么区别，直接打开或者将文件拖拽到软件中，直接看到整个文件的内容</li><li>过滤 tag，使用快捷键，<code>commond + f</code> 调出查找，然后输入要过滤的<br>tag，或者在文本中选中 tag，直接进行 <code>commond + f</code> 会自动填充查找内容，然后点击 <code>find all</code> 之后会启动一个新的界面，此界面分为两部分，上半部分和下半部分，上半部分的日志则为按照 tag 过滤后的日志结果，当点击选中上半部分的任何一行，下半部分则会显示出该行日志在整个文件中的的位置，且会自动显示出改行日志前后的相关日志。便于查看某些相关信息。</li><li>如果需要过滤过个日志，则在文件上使用 <code>commond + f</code> 命令进行查找，每次都会新开一个界面，便于多 tag 的文件定位。</li></ol><blockquote><p>当然还有很多的可配置参数，在设置中，这里只说基本的使用，高阶使用请自行研究。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有了上面的工具，你是否觉得对查看日志不再那么畏惧了，因为这款工具确确实实解决了查看日志上的一些不便的地方。如果你有更好的工具欢迎留言交流。</p><h3 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h3><p>由于此软件只有 mac 版，且是收费的，故这里共享一版最新软件，且共享一个注册码，当然如有你有经济能力，建议进行购买正版。</p><blockquote><p><strong>领取方法：</strong> 在公众号对话框中，发送”日志” 两个字，则可以拿到最新版百度云下载地址及注册码。</p></blockquote><p><strong>如果你觉得文章有用，就帮忙分享出去或者帮忙点个赞吧~感激不尽~</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在开发中定位问题或者调试常常需要分析日志文件，但是对于日志文件一不小心就几百行甚至上千行的相信大家都有些惧怕，尤其在定位问题查看日志时，而且还有不同的tag需要过滤时，看了这个 tag，又要看另外一个 tag，到最后自己都凌乱了，不知道看到哪里了，看了哪些忘了那些，等等很多问题影响效率。&lt;/p&gt;
&lt;p&gt;今天要给大家推荐一个查看日志的神器，至少我现在查看文本日志文件时，不会那么心累了，这款神器软件名字为：&lt;strong&gt;BBEditor&lt;/strong&gt; ,遗憾的是目前只有 Mac 版，且也是收费的，不过作为福利，文末会给大家下载地址及注册码，让大家也来感受下查看日志的便捷。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://www.wxtlife.com/categories/Tools/"/>
    
    
      <category term="log" scheme="http://www.wxtlife.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin开发基础（三）</title>
    <link href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/"/>
    <id>http://www.wxtlife.com/2017/12/17/kotlin-share-3/</id>
    <published>2017-12-17T12:17:45.000Z</published>
    <updated>2018-03-16T15:49:44.453Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><ul><li><strong><a href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/">Kotlin开发基础（一）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/">Kotlin开发基础（二）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/">Kotlin开发基础（三）</a></strong></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>本篇文章主要介绍类的继承，接口，复写，单例，以及object属性的介绍。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>Kotlin中的继承方式与Java类似，Java中所有对象都继承自<code>Object</code>，而Kotlin中所有对象均继承自<code>Any</code>。两者均不能多继承，只是表现形式不同，Kotlin继承使用冒号<code>：</code>表示。想要复写某个方法，则也需要将方法标记为<code>open</code>的才可以被复写。<br><strong>切记一个类想要被继承，必须用 <code>open</code> 或 <code>abstract</code> 关键字 声明。</strong><br>示例如下；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open class person(name: String) // 必须申请为open才可以继承，</span><br><span class="line"></span><br><span class="line">class  male(name: String)： Person(name)</span><br></pre></td></tr></table></figure></p><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类与这里与Java是一致的，通过<code>abstract</code>关键字标记为抽象类，抽象类中抽象方法也用 <code>abstract</code>标记。有了<code>abstract</code> 则不再需要使用<code>open</code>进行标注了。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">open class person() &#123; </span><br><span class="line">    open fun eat() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">abstract class oldPerson(): person() &#123; </span><br><span class="line">    override abstract fun sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>抽象类和抽象方法是默认<code>open</code>关键字修饰的</li><li>复写抽象类中实现的方法，也必须要加<code>open</code>关键字才可复写</li><li>抽象类有抽象方法和方法的实现，可以有成员属性</li></ul><a id="more"></a><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>Kotlin中的接口需要使用关键字<code>interface</code>进行声明，Kotlin 的接口既包含抽象方法的声明，也可以包含实现，且接口中也可以申明属性，默认属性要求是抽象的，或者是提供访问器,其接口中的属性不能有<code>field</code>属性关键字。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface MyInterface &#123; </span><br><span class="line">    val prop: Int // 抽象的</span><br><span class="line">    val propertyWithImplementation: String get() = &quot;foo&quot;</span><br><span class="line">    fun foo() &#123; //方法实现</span><br><span class="line">        print(prop)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">class Child : MyInterface &#123; </span><br><span class="line">    override val prop: Int = 29</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接口中已经实现的方法，在子类中进行复写不需要在加<code>open</code>关键字。<br>在接口中</p><h4 id="复写"><a href="#复写" class="headerlink" title="复写"></a>复写</h4><p>复写关键字为 <code>override</code>，与Java的区别是没有了@符号了。复写这里需要注意两点</p><ol><li><code>var</code>可以复写<code>val</code>类型的，但是反之不行。</li><li>想要复写父类的方法，父类方法必须加<code>open</code>关键字标识。</li></ol><p>复写的规则中，如果继承和实现了同样的方法名，则必须在子类对该方法进行复写,以为编译器不知道该调用那个父类的方法。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">open class A &#123;</span><br><span class="line">    open fun f() &#123; print(&quot;A&quot;) &#125; </span><br><span class="line">    fun a() &#123; print(&quot;a&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface B &#123;</span><br><span class="line">    fun f() &#123; print(&quot;B&quot;) &#125; // 接口成员默认就是“open”的 </span><br><span class="line">    fun b() &#123; print(&quot;b&quot;) &#125;</span><br><span class="line">&#125;</span><br><span class="line">class C() : A(), B &#123;</span><br><span class="line">    // 编译器要求覆盖 f()，因为不知道该调用哪个父类的方法</span><br><span class="line">    override fun f() &#123;</span><br><span class="line">        super&lt;A&gt;.f() // 调用 A.f()</span><br><span class="line">        super&lt;B&gt;.f() // 调用 B.f() </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="data数据类"><a href="#data数据类" class="headerlink" title="data数据类"></a>data数据类</h4><p>在与服务器交互中经常有数据类，在Kotlin中直接使用data标记为数据类，它会根据构造函数的属性生成<code>equals</code> ， <code>hashcode</code> ， <code>toString</code> 方法，当然这块我们也是可以重写的。<br>需要注意的是：</p><ol><li>数据类主构造函数至少有一个参数</li><li>主构造函数的所有参数需要标记为 <code>val</code> 或 <code>var</code>；</li></ol><h4 id="单例声明"><a href="#单例声明" class="headerlink" title="单例声明"></a>单例声明</h4><p>在Java中写一个单例是很麻烦的事情，也有很多种不通过的写法，需要考虑多线程问题，但在Kotlin中单例就变得简单的多，使用 <code>object</code>关键字就可以实现单例,我们看下示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object Person &#123;</span><br><span class="line">    fun eat()&#123;</span><br><span class="line">        print(&quot;eat&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>翻译成为Java代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class Person &#123;</span><br><span class="line">   public static final Person INSTANCE;</span><br><span class="line"></span><br><span class="line">   public final void eat() &#123;</span><br><span class="line">      String var1 = &quot;eat&quot;;</span><br><span class="line">      System.out.print(var1);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      Person var0 = new Person();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到上面代码实际为一个单例默认的饿汉模式实现。</p><h4 id="对象表达式"><a href="#对象表达式" class="headerlink" title="对象表达式"></a>对象表达式</h4><p>当需要修改一个类的部分功能，可以不通过显式实现一个该类的子类方式来实现。在Java中，通过匿名内部类来实现；在Kotlin中，概括为对象表达式和对象声明。最常见的就是我们代码中设置Listener。示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val test = object : View.OnClickListener() &#123;</span><br><span class="line">    override fun onClick(p0: View?) &#123;</span><br><span class="line">        Log.v(&quot;TAG&quot;,&quot;click listener&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有这种用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val adHoc = object &#123;  </span><br><span class="line">  var x: Int = 0  </span><br><span class="line">  var y: Int = 0  </span><br><span class="line">&#125;  </span><br><span class="line">print(adHoc.x + adHoc.y)</span><br></pre></td></tr></table></figure></p><h4 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h4><p>Kotlin中没有静态的属性和方法的概念， Kotlin官网建议我们使用包级别的函数，来替代静态方法。当然也可以在类内使用<code>companion object</code>关键字声明一个伴生对象。 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">    companion object &#123;</span><br><span class="line">        val  TAG = &quot;TEST&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    fun test()&#123;</span><br><span class="line">        Log.v(Test.TAG,&quot;test method&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>object</code>的使用有很多种，可参考这篇文章。 <a href="http://liuqingwen.me/blog/2017/06/20/object-vs-companion-object-in-kotlin/" target="_blank" rel="noopener">http://liuqingwen.me/blog/2017/06/20/object-vs-companion-object-in-kotlin/</a></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Kotlin 中的继承和接口大体上与 Java 一致，尤其是在 Java 8 后面的语法， 接口中可以包含实现了，和抽象类的概念更近了点，但是两个还是有些许的差别，这点需要自己多体会。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/09/08/kotlin-share-1/&quot;&gt;Kotlin开发基础（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/12/kotlin-share-2/&quot;&gt;Kotlin开发基础（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/17/kotlin-share-3/&quot;&gt;Kotlin开发基础（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;p&gt;本篇文章主要介绍类的继承，接口，复写，单例，以及object属性的介绍。&lt;/p&gt;
&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h4&gt;&lt;p&gt;Kotlin中的继承方式与Java类似，Java中所有对象都继承自&lt;code&gt;Object&lt;/code&gt;，而Kotlin中所有对象均继承自&lt;code&gt;Any&lt;/code&gt;。两者均不能多继承，只是表现形式不同，Kotlin继承使用冒号&lt;code&gt;：&lt;/code&gt;表示。想要复写某个方法，则也需要将方法标记为&lt;code&gt;open&lt;/code&gt;的才可以被复写。&lt;br&gt;&lt;strong&gt;切记一个类想要被继承，必须用 &lt;code&gt;open&lt;/code&gt; 或 &lt;code&gt;abstract&lt;/code&gt; 关键字 声明。&lt;/strong&gt;&lt;br&gt;示例如下；&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;open class person(name: String) // 必须申请为open才可以继承，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class  male(name: String)： Person(name)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h4&gt;&lt;p&gt;抽象类与这里与Java是一致的，通过&lt;code&gt;abstract&lt;/code&gt;关键字标记为抽象类，抽象类中抽象方法也用 &lt;code&gt;abstract&lt;/code&gt;标记。有了&lt;code&gt;abstract&lt;/code&gt; 则不再需要使用&lt;code&gt;open&lt;/code&gt;进行标注了。&lt;br&gt;示例如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;open class person() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    open fun eat() &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;abstract class oldPerson(): person() &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    override abstract fun sleep()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象类和抽象方法是默认&lt;code&gt;open&lt;/code&gt;关键字修饰的&lt;/li&gt;
&lt;li&gt;复写抽象类中实现的方法，也必须要加&lt;code&gt;open&lt;/code&gt;关键字才可复写&lt;/li&gt;
&lt;li&gt;抽象类有抽象方法和方法的实现，可以有成员属性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.wxtlife.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin开发基础（二）</title>
    <link href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/"/>
    <id>http://www.wxtlife.com/2017/12/12/kotlin-share-2/</id>
    <published>2017-12-12T13:29:09.000Z</published>
    <updated>2018-03-16T15:49:44.453Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><ul><li><strong><a href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/">Kotlin开发基础（一）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/">Kotlin开发基础（二）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/">Kotlin开发基础（三）</a></strong></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>本篇文章主要介绍类的属性定义及getter和setter，构造器，主次构造函数相关知识。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>类使用 <code>class</code> 关键字来标识，这个与Java中一样的。但是在kotlin中默认类都是不可继承的，也就是所说的 <code>final</code> 的类型，如果需要别继承，则必须将其标记为 <code>open</code> 或者 <code>abstract</code> 类型。</p><h4 id="可见性声明"><a href="#可见性声明" class="headerlink" title="可见性声明"></a>可见性声明</h4><p>Kotlin 一共有四种可见性修饰符：<code>private、protected、internal、public</code>。<br>可见性修饰可用于函数、属性、类、对象和接口，但不能用于局部变量。<br>如果没有显式指定修饰符的话，默认可⻅性是 <code>public</code> 。与Java中默认类型不同。</p><h4 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h4><h5 id="getter-setter及filed关键字"><a href="#getter-setter及filed关键字" class="headerlink" title="getter/setter及filed关键字"></a>getter/setter及filed关键字</h5><p>在Kotlin中对于 <code>var</code> 的变量都会默认有 <code>setter</code> 和 <code>getter</code> 方法，对 <code>val</code> 的仅有 <code>getter</code> 方法，当然也可以复写 <code>getter</code> 和 <code>setter</code> 方法，一般写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &lt;propertyName&gt;[: &lt;PropertyType&gt;] [= &lt;property_initializer&gt;]</span><br><span class="line">    [&lt;getter&gt;]</span><br><span class="line">    [&lt;setter&gt;]</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>值得注意的是，在复写getter和setter时，新手很容易犯的一个错，请看如下代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    var age: Int</span><br><span class="line">        get() = age</span><br><span class="line">        set(value) &#123;</span><br><span class="line">            age = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码编译期间是没有任何问题，但是运行起来呢？发现发生了<code>StackOverflowError</code>。。。怎么会是这么个鬼错误。这么简单的代码还能写错？这里教大家一个展示转为Java的方法。通过 <code>Tools</code> —&gt; <code>Kotlin</code> —-&gt; <code>Show kotlin ByteCode</code> ,这里转出来是字节码，很难看，然后在对话框上面在点击 DeCompile 这样就出现Java代码了，看看上面的代码生成了什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public final class Person &#123;</span><br><span class="line">   public final int getAge() &#123;</span><br><span class="line">      return this.getAge();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public final void setAge(int value) &#123;</span><br><span class="line">      this.setAge(value);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的 <code>getter</code> 和 <code>setter</code> 方法都调用的是自己的方法。所以就发生 <code>StackOverflowError</code> 的错误了。这怎么办？Kotlin官方也意识到这个问题啦，便有了<code>field</code> 关键字啦。<br>正确写法如下：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">get</span>() = field</span><br><span class="line">        <span class="keyword">set</span>(value) &#123;</span><br><span class="line">            field = value</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的写法请自行转换为java代码看看是什么代码。</p><ul><li><code>field</code>标识符只能用在属性的访问器内。</li></ul><h5 id="lateinit关键字"><a href="#lateinit关键字" class="headerlink" title="lateinit关键字"></a><code>lateinit</code>关键字</h5><p>由于Kotlin默认是不允许为空的，所以在声明变量时，必须对其进行赋值，但是有些时候，我们确时无法在一开始定义的时候就赋值，这时候就需要延迟赋值。这时就用 <code>lateinit</code> 关键字进行标记。<br>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lateinit var ageStr: String</span><br></pre></td></tr></table></figure></p><p><strong>注意：</strong>  </p><ol><li><code>lateinit</code> 只能对 <code>var</code> 类型的变量</li><li><code>lateinit</code> 不能用于基础类型，因为基础类型没有null的情况</li></ol><h4 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h4><p>Kotlin中的类需要构造函数时，可以有一个主构造函数和多个次构造函数，当然也可以没有构造函数。</p><h5 id="主构造函数"><a href="#主构造函数" class="headerlink" title="主构造函数"></a>主构造函数</h5><p>主构造函数在类名后。<br>写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String) &#123;</span><br><span class="line">    /// some code ****</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果类中没有任何的代码时，则可以省略最后面的括号写法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String)</span><br></pre></td></tr></table></figure></p><p>当构造函数有注解或者可见性修饰符时，构造函数需要加<code>constructor</code>关键字，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Person private constructor(name: String)</span><br></pre></td></tr></table></figure></p><p><code>private</code> 指的是构造方法为<code>private</code> 类型。</p><p>由于主构造函数中是不能有代码块的，如果想要在构造函数中有代码块，则必须使用<code>init{}</code>语句块，将初始话语句写在init代码块中，代码块中可以访问到构造函数的属性，并执行一些语句块，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person(name: String) &#123;</span><br><span class="line">    private var mName: String</span><br><span class="line">    init &#123;</span><br><span class="line">        println(&quot;init&quot;)</span><br><span class="line">        mName = name.toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当在构造函数中的参数名前加上 <code>var</code> ，<code>val</code> 则表示此参数为类的一个成员变量。并且会自动会在构造函数中对其进行赋值，默认也会为其生成<code>get</code> 和 <code>set</code> 方法。不想对外访问则添加<code>private</code>修饰符即可。<br>示例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//会自动生成private name:String的类属性，且生成get方法（没有set因为是val的类型）</span><br><span class="line">class TestClass(val name:String) &#123;</span><br><span class="line">    fun test() &#123;</span><br><span class="line">        Log.v(&quot;TestClass&quot;,&quot;name = $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//下面是外部不可以访问name属性的</span><br><span class="line">class TestClass(private var name:String) &#123;</span><br><span class="line">    fun test() &#123;</span><br><span class="line">        Log.v(&quot;TestClass&quot;,&quot;name = $name&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二级构造"><a href="#二级构造" class="headerlink" title="二级构造"></a>二级构造</h4><p>二级构造函数，也称为次级构造函数。关于二级构造函数，主要有以下几点：</p><ul><li>次级构造函数不能省略 <code>constructor</code> 关键字；</li><li>当类拥有主构造函数时，任何一个二级构造函数都需要直接或间接通过另一个二级构造函数代理主构造函数；</li><li>类中的一个构造函数代理另一个构造函数，需要使用关键字this；</li></ul><p>示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person constructor(id: Int) &#123;//（构造函数No.0）主构造函数</span><br><span class="line">    var id = id//主构造函数初始化id</span><br><span class="line">    var name = &quot;&quot;</span><br><span class="line">    var age = 0</span><br><span class="line">    //（构造函数No.1）直接代理主构造函数</span><br><span class="line">    constructor(name: String, id: Int) : this(id) &#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    //（构造函数No.2）代理了构造函数No.1，间接代理主构造函数</span><br><span class="line">    constructor(name: String, age: Int, id: Int) : this(name, id) &#123;</span><br><span class="line">        this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这类补充子类的次构造函数是无法直接代理到父类的方法。必须指向本类的主或次构造函数，但最终都必须指向主构造函数。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Kotlin 中的对一个类的声明比 Java 简单了很多，代码量也少了很多，尤其是对于数据类来说， 从这来看 Kotlin 的语法是比 Java 简洁了很多，节省码代码的时间。 </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/09/08/kotlin-share-1/&quot;&gt;Kotlin开发基础（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/12/kotlin-share-2/&quot;&gt;Kotlin开发基础（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/17/kotlin-share-3/&quot;&gt;Kotlin开发基础（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h3&gt;&lt;p&gt;本篇文章主要介绍类的属性定义及getter和setter，构造器，主次构造函数相关知识。&lt;/p&gt;
&lt;h4 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h4&gt;&lt;p&gt;类使用 &lt;code&gt;class&lt;/code&gt; 关键字来标识，这个与Java中一样的。但是在kotlin中默认类都是不可继承的，也就是所说的 &lt;code&gt;final&lt;/code&gt; 的类型，如果需要别继承，则必须将其标记为 &lt;code&gt;open&lt;/code&gt; 或者 &lt;code&gt;abstract&lt;/code&gt; 类型。&lt;/p&gt;
&lt;h4 id=&quot;可见性声明&quot;&gt;&lt;a href=&quot;#可见性声明&quot; class=&quot;headerlink&quot; title=&quot;可见性声明&quot;&gt;&lt;/a&gt;可见性声明&lt;/h4&gt;&lt;p&gt;Kotlin 一共有四种可见性修饰符：&lt;code&gt;private、protected、internal、public&lt;/code&gt;。&lt;br&gt;可见性修饰可用于函数、属性、类、对象和接口，但不能用于局部变量。&lt;br&gt;如果没有显式指定修饰符的话，默认可⻅性是 &lt;code&gt;public&lt;/code&gt; 。与Java中默认类型不同。&lt;/p&gt;
&lt;h4 id=&quot;类属性&quot;&gt;&lt;a href=&quot;#类属性&quot; class=&quot;headerlink&quot; title=&quot;类属性&quot;&gt;&lt;/a&gt;类属性&lt;/h4&gt;&lt;h5 id=&quot;getter-setter及filed关键字&quot;&gt;&lt;a href=&quot;#getter-setter及filed关键字&quot; class=&quot;headerlink&quot; title=&quot;getter/setter及filed关键字&quot;&gt;&lt;/a&gt;getter/setter及filed关键字&lt;/h5&gt;&lt;p&gt;在Kotlin中对于 &lt;code&gt;var&lt;/code&gt; 的变量都会默认有 &lt;code&gt;setter&lt;/code&gt; 和 &lt;code&gt;getter&lt;/code&gt; 方法，对 &lt;code&gt;val&lt;/code&gt; 的仅有 &lt;code&gt;getter&lt;/code&gt; 方法，当然也可以复写 &lt;code&gt;getter&lt;/code&gt; 和 &lt;code&gt;setter&lt;/code&gt; 方法，一般写法如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var &amp;lt;propertyName&amp;gt;[: &amp;lt;PropertyType&amp;gt;] [= &amp;lt;property_initializer&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&amp;lt;getter&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [&amp;lt;setter&amp;gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.wxtlife.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Android首次启动卡顿问题分析</title>
    <link href="http://www.wxtlife.com/2017/11/14/Android-first-launcher-problem/"/>
    <id>http://www.wxtlife.com/2017/11/14/Android-first-launcher-problem/</id>
    <published>2017-11-14T12:56:09.000Z</published>
    <updated>2018-03-16T15:49:44.448Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>在有些 Android 机器上首次启动时会出现很明显的卡顿问题，且比较明显的是只会在安装后的首次出现，很是奇怪，那么要分析这个问题则需要了解启动的不同类型的区别以及不同版本间的区别了。</p><h3 id="启动的分类"><a href="#启动的分类" class="headerlink" title="启动的分类"></a>启动的分类</h3><p>启动分三种，首次安装后的冷启动，冷启动，热启动</p><h4 id="首次安装完的冷启动"><a href="#首次安装完的冷启动" class="headerlink" title="首次安装完的冷启动"></a>首次安装完的冷启动</h4><p>这个指的是用户对APK进行安装后，首次进行打开的过程。</p><h4 id="app的冷启动"><a href="#app的冷启动" class="headerlink" title="app的冷启动"></a>app的冷启动</h4><p>指当启动应用时，后台没有该程序的进程。</p><h4 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h4><p>指程序依然在，启动时通过已有进程启动应用。</p><a id="more"></a><h3 id="虚拟机区别"><a href="#虚拟机区别" class="headerlink" title="虚拟机区别"></a>虚拟机区别</h3><h4 id="Dalvik（Android5-0-以下系统）"><a href="#Dalvik（Android5-0-以下系统）" class="headerlink" title="Dalvik（Android5.0 以下系统）"></a>Dalvik（Android5.0 以下系统）</h4><p>在5.0以下的版本中，默认的虚拟机为Dalvik，Dalvik虚拟机与Java虚拟机有差不多的特性，都是解释执行的。Dalvik采用的是JIT（及时编译）技术。 <code>.dex</code>格式是专为Dalvik设计的一种压缩格式,在每次执行应用的时候Dalvik虚拟机都会将程序的语言由高级语言编译为机器语言。</p><p>在应用启动时 JIT通过进行连续的性能分析来优化程序代码的执行，在程序运行的过程中，Dalvik虚拟机在不断的进行将字节码编译成机器码的工作，这样当前的程序才能运行。启动程序优化代码并存储在Dalvik缓存中。Dalvik第一次加载后会生成Cache文件，以提供下次快速加载，所以第一次会很慢。</p><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点：</strong></p><ul><li>1、 占用空间较小</li><li>2、 安装速度快</li></ul><p><strong>缺点：</strong></p><ul><li>1、 启动速度慢<h4 id="ART-Android-RunTime-Android-5-0-以上系统"><a href="#ART-Android-RunTime-Android-5-0-以上系统" class="headerlink" title="ART-Android RunTime (Android 5.0 以上系统)"></a>ART-Android RunTime (Android 5.0 以上系统)</h4></li></ul><p>在5.0以上的系统默认采用了<code>ART（Android RunTime）</code>模式，它正式的取代了以往的Dalvik虚拟机，ART能够把应用程序的字节码转换为机器码，是Android所使用的一种新的虚拟机，ART采用Ahead-of-time（AOT）技术，此种模式对Dalvik进行了很多的优化，包括性能，以及垃圾回收器等。</p><p>在ART模式下系统在安装应用的时候会进行一次预编译，在安装应用程序时会先将代码转换为机器语言存储在本地，这样在运行程序时就不会每次都进行一次编译了，执行效率也大大提升。</p><h5 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>优点：</strong></p><ul><li>1、系统性能的显著提升。</li><li>2、应用启动更快、运行更快、体验更流畅、触感反馈更及时。</li><li>3、更长的电池续航能力。</li><li>4、支持更低的硬件。</li></ul><p><strong>缺点：</strong></p><ul><li>1、占用更多空间</li><li>2、安装时间变长</li></ul><p>对上面两个有个很好的比喻：</p><blockquote><p>Dalvik 是已经折叠起来的自行车，每次骑都要先组装自行车才能骑<br>ART 是已经组装好的自行车，每次骑直接上车就能走人</p></blockquote><h3 id="综合分析"><a href="#综合分析" class="headerlink" title="综合分析"></a>综合分析</h3><p>Dalvik是执行的时候编译+运行的模式。而ART是编译好的直接进行运行。<br>如果我们的应用比较大，比如有多个dex文件，那么这时候在不同虚拟机平台上启动速度是很不一样的，在Dalvik的虚拟机上，需要将每一个dex文件转化为机器码，dex越多越大则耗时越高，所以对于首次安装的冷启动是很慢很慢的，有时可能还会造成 ANR ，当然第一次之后会将相应的缓存保存在<code>data/dalvik-cache</code>下面，后续的冷启动读取缓存进行加载运行。相对会比首次安装后启动快很多。<br>然而在ART的模式下，由于其是在安装的过程中进行这部分处理的，所以应用的启动速度不受这些的影响。 </p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>对于在Dalvi虚拟机上的目前是没有很好的办法去解决首次安装后的冷启动，因为这个是系统虚拟机的限制导致此问题，此过程是必经之路。</p><p><strong>瞎方法（不推荐）</strong><br>对于系统定制开发来说，可以在自己代码中起一个很普通的service，什么都不做，启动起来只有就自己结束。然后另外一个系统常驻的service，监听系统新增的应用包，监听到后启动这个应用的空白service，这个过程就相当于让程序能够自运行一下。让虚拟机首次启动执行的过程跑一遍，加快后续在启动的一个启动速度。当然这样就会导致系统与应用有些耦合。当然这只是一个瞎推荐的方法。</p><h3 id="相关的参考资料"><a href="#相关的参考资料" class="headerlink" title="相关的参考资料"></a>相关的参考资料</h3><p>Activity 启动 Display 延迟问题源码分析代码如下：<a href="http://blog.csdn.net/kc58236582/article/details/60134836" target="_blank" rel="noopener">http://blog.csdn.net/kc58236582/article/details/60134836</a></p><p>Google 官方对于启动时间一些说明: <a href="https://developer.android.com/topic/performance/launch-time.html" target="_blank" rel="noopener">https://developer.android.com/topic/performance/launch-time.html </a>  </p><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队-1"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队-1" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;在有些 Android 机器上首次启动时会出现很明显的卡顿问题，且比较明显的是只会在安装后的首次出现，很是奇怪，那么要分析这个问题则需要了解启动的不同类型的区别以及不同版本间的区别了。&lt;/p&gt;
&lt;h3 id=&quot;启动的分类&quot;&gt;&lt;a href=&quot;#启动的分类&quot; class=&quot;headerlink&quot; title=&quot;启动的分类&quot;&gt;&lt;/a&gt;启动的分类&lt;/h3&gt;&lt;p&gt;启动分三种，首次安装后的冷启动，冷启动，热启动&lt;/p&gt;
&lt;h4 id=&quot;首次安装完的冷启动&quot;&gt;&lt;a href=&quot;#首次安装完的冷启动&quot; class=&quot;headerlink&quot; title=&quot;首次安装完的冷启动&quot;&gt;&lt;/a&gt;首次安装完的冷启动&lt;/h4&gt;&lt;p&gt;这个指的是用户对APK进行安装后，首次进行打开的过程。&lt;/p&gt;
&lt;h4 id=&quot;app的冷启动&quot;&gt;&lt;a href=&quot;#app的冷启动&quot; class=&quot;headerlink&quot; title=&quot;app的冷启动&quot;&gt;&lt;/a&gt;app的冷启动&lt;/h4&gt;&lt;p&gt;指当启动应用时，后台没有该程序的进程。&lt;/p&gt;
&lt;h4 id=&quot;热启动&quot;&gt;&lt;a href=&quot;#热启动&quot; class=&quot;headerlink&quot; title=&quot;热启动&quot;&gt;&lt;/a&gt;热启动&lt;/h4&gt;&lt;p&gt;指程序依然在，启动时通过已有进程启动应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【工具】gitignore全自动生成</title>
    <link href="http://www.wxtlife.com/2017/11/10/gitignore-auto-create/"/>
    <id>http://www.wxtlife.com/2017/11/10/gitignore-auto-create/</id>
    <published>2017-11-10T09:23:09.000Z</published>
    <updated>2018-03-16T15:49:44.451Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><p>今天给大家安利一款 gitignore 自动生成的在线软件，那么它有什么特别的功能呢？且慢看下面内容。</p><p>gitignore 文件大家应该比较熟悉，你必须把某些文件放到Git工作目录中，但又不能提交它们，或者在使用 git status 时看到很多不需要关心的 Untracked files … 文件 ，那么这时候就需要 .gitignore 文件了。</p><p>那么在新建项目时，由于使用不同的编译器，不同的语言以及不同的操作系统再或者使用不同的工具，都会或多或少在项目中生成一些不需要提交到仓库的文件，如果要想我们自己去一个个的添加 gitignore 配置那么就需要一个个查找哪些是不需要的而且还可能会遗漏，比较麻烦，那么今天介绍的工具就是解决这个问题的。</p><p>首先来看下网页的主界面：<br><img src="/img/ignore/ignore1.jpg" alt="ignore1"></p><a id="more"></a><p>可以在输入框中输入我们的操作系统，使用的语言，工具等，如下图：<br><img src="/img/ignore/ignore2.jpg" alt="ignore1"></p><p>然后点击 Create 看下结果。<br><img src="/img/ignore/ignore3.jpg" alt="ignore1"></p><p>当然还有很多的内容，这里就不贴出来了。虽然有些文件我们是没有遇到的，反正就是一个 gitignore 文件，不需要经常修改，所以全部贴到我们项目文件中就可以 。</p><p>工具的网址如下： <a href="https://www.gitignore.io/" target="_blank" rel="noopener">https://www.gitignore.io/</a></p><p>当然也可以点击阅读原文跳转到工具网址，如果你喜欢这个工具就点个赞吧，或者转发给你的同事吧。</p><blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队-1"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队-1" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;p&gt;今天给大家安利一款 gitignore 自动生成的在线软件，那么它有什么特别的功能呢？且慢看下面内容。&lt;/p&gt;
&lt;p&gt;gitignore 文件大家应该比较熟悉，你必须把某些文件放到Git工作目录中，但又不能提交它们，或者在使用 git status 时看到很多不需要关心的 Untracked files … 文件 ，那么这时候就需要 .gitignore 文件了。&lt;/p&gt;
&lt;p&gt;那么在新建项目时，由于使用不同的编译器，不同的语言以及不同的操作系统再或者使用不同的工具，都会或多或少在项目中生成一些不需要提交到仓库的文件，如果要想我们自己去一个个的添加 gitignore 配置那么就需要一个个查找哪些是不需要的而且还可能会遗漏，比较麻烦，那么今天介绍的工具就是解决这个问题的。&lt;/p&gt;
&lt;p&gt;首先来看下网页的主界面：&lt;br&gt;&lt;img src=&quot;/img/ignore/ignore1.jpg&quot; alt=&quot;ignore1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.wxtlife.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>还再用compile依赖？那你就落后啦</title>
    <link href="http://www.wxtlife.com/2017/11/05/Android-compile/"/>
    <id>http://www.wxtlife.com/2017/11/05/Android-compile/</id>
    <published>2017-11-05T05:56:45.000Z</published>
    <updated>2018-03-16T15:49:44.447Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>在上上一篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzIwODI3MTc2Ng==&amp;mid=2649647447&amp;idx=1&amp;sn=4bcd221929a2982d231994af4aa0abe5&amp;chksm=8f1f69aeb868e0b8c5cf98c44a9b789a2fcd17497e3cd1df74aead19514c3a3bfeb0957c543c#rd" target="_blank" rel="noopener">《Android Studio 3.0版本正式发布啦》</a> 中说到AS 3.0 正式版已经出来了，讲到新版本支持的一些新特性，那么今天就来说说新版本中 Moudle 中 build.gradle 文件中的变化。</p><p>我们来看看新建一个项目在 Moudle 中的 dependencies 中的变化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])</span><br><span class="line">    implementation &apos;com.android.support:appcompat-v7:26.1.0&apos;</span><br><span class="line">    implementation &apos;com.android.support.constraint:constraint-layout:1.0.2&apos;</span><br><span class="line">    testImplementation &apos;junit:junit:4.12&apos;</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test:runner:1.0.1&apos;</span><br><span class="line">    androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>发现我们经常添加依赖使用的 <code>compile</code>不见了，而现在改变为 <code>implementation</code>了，那么就来看看这个到底是有什么新的意思呢。</p><a id="more"></a><p>其实在新版本 <code>Android Gradle plugin 3.0</code> 中 已经将 <code>compile</code> 标记为过时了，而取而代之的是 <code>implementation</code> 和 <code>api</code> 两个关键字。那么它们有什么区别呢？</p><p><code>api</code> 关键字 其实等同于 <code>compile</code> 。但为什么要换个名字呢，目前还没有查到相关的信息，如有大神知道，请留言告知。</p><p><code>implementation</code> ： 使用了该命令编译的依赖，它仅仅对当前的 Moudle 提供接口。例如我们当前项目结构如下：<br><img src="http://mmbiz.qpic.cn/mmbiz_png/RTYpAoaia4pj3BRjGqTHkWulBLHNYrGxtY0Ao0QSGFLuq5Kl1ro9ribCwCD3z7YH36xibs6dgWYhKcTFkhfxcKkTA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="项目结构"><br>LibraryA 中引用了 LibraryC 的库，如果对 LibraryC 的依赖用的是 implementation 关键字。 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    . . . . </span><br><span class="line">    implementation project（path：&apos;：libraryC&apos;）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么 LibraryC 中的接口，仅仅只能给  LibraryA 使用，而我们的 App Moudle 是无法访问到 LibraryC 提供的接口的，也就是将该依赖隐藏在内部，而不对外部公开。这就是 implementation 关键字的作用。</p><p><strong> 那为什么要这么做呢？ </strong><br>答案是： 1.  加快编译速度。2.   隐藏对外不必要的接口。</p><p><strong> 为什么能加快编译速度呢？ </strong><br>这对于大型项目含有多个 Moudle 模块的， 以上图为例，比如我们改动 LibraryC 接口的相关代码，这时候编译只需要单独编译 LibraryA 模块就行， 如果使用的是 api 或者旧时代的 compile，由于App Moudle 也可以访问到 LibraryC ,所以 App Moudle 部分也需要重新编译。当然这是在全编的情况下。 </p><p>至于编译速度的对比，国外有个小哥已经做了简单的对比，效果还是不错。地址可点击原文跳转过去查看。 </p><p>那么我们现有项目中的依赖如何修改呢? 答案是：将 compile 都修改为 implementation 然后尝试进行项目构建，如果构建成功那么恭喜你，如果构建不成功，则查看相关的依赖项，并将其修改为 api 关键字依赖。</p><p>好了，今天就介绍这一个知识点，如果你有收获就关注我们吧，或者给我点个赞吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;在上上一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwODI3MTc2Ng==&amp;amp;mid=2649647447&amp;amp;idx=1&amp;amp;sn=4bcd221929a2982d231994af4aa0abe5&amp;amp;chksm=8f1f69aeb868e0b8c5cf98c44a9b789a2fcd17497e3cd1df74aead19514c3a3bfeb0957c543c#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Android Studio 3.0版本正式发布啦》&lt;/a&gt; 中说到AS 3.0 正式版已经出来了，讲到新版本支持的一些新特性，那么今天就来说说新版本中 Moudle 中 build.gradle 文件中的变化。&lt;/p&gt;
&lt;p&gt;我们来看看新建一个项目在 Moudle 中的 dependencies 中的变化。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;dependencies &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation fileTree(dir: &amp;apos;libs&amp;apos;, include: [&amp;apos;*.jar&amp;apos;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;apos;com.android.support:appcompat-v7:26.1.0&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    implementation &amp;apos;com.android.support.constraint:constraint-layout:1.0.2&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    testImplementation &amp;apos;junit:junit:4.12&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    androidTestImplementation &amp;apos;com.android.support.test:runner:1.0.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    androidTestImplementation &amp;apos;com.android.support.test.espresso:espresso-core:3.0.1&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;发现我们经常添加依赖使用的 &lt;code&gt;compile&lt;/code&gt;不见了，而现在改变为 &lt;code&gt;implementation&lt;/code&gt;了，那么就来看看这个到底是有什么新的意思呢。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="gradle" scheme="http://www.wxtlife.com/tags/gradle/"/>
    
  </entry>
  
  <entry>
    <title>Android Support 库各版本功能介绍</title>
    <link href="http://www.wxtlife.com/2017/11/05/Android-support/"/>
    <id>http://www.wxtlife.com/2017/11/05/Android-support/</id>
    <published>2017-11-05T04:59:15.000Z</published>
    <updated>2018-03-16T15:49:44.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>Android 支持库软件有多个库，每个库均支持特定范围的 Android 平台版本和功能。像大家比较熟悉的 v4 、v7、 v13、v14 等。下面将分别介绍下各个库版本所兼容或带来的功能有哪些？</p><h3 id="v4-支持库"><a href="#v4-支持库" class="headerlink" title="v4 支持库"></a>v4 支持库</h3><p>v4库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。与其他支持库相比，它们包含的 API 集合最大，包括对应用组件、用户界面功能、辅助功能、数据处理、网络连接以及编程实用工具的支持。</p><blockquote><p>注：在支持库修订版 24.2.0 之前，存在一个 v4 支持库。为了提高效率，此库拆分成多个模块。出于向后兼容的考虑，如果您在 Gradle 脚本中列出了 support-v4，您的 APK 将包含所有的 v4 模块。不过，要减少 APK 大小，我们建议仅列出应用需要的特定模块。</p></blockquote><h4 id="v4-compat-库"><a href="#v4-compat-库" class="headerlink" title="v4 compat 库"></a>v4 compat 库</h4><p>此为众多框架 API 提供兼容性包装器，例如 Context.obtainDrawable() 和 View.performAccessibilityAction()</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-compat:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v4-core-utils-库"><a href="#v4-core-utils-库" class="headerlink" title="v4 core-utils 库"></a>v4 core-utils 库</h4><p>提供大量实用程序类，例如 AsyncTaskLoader 和 PermissionChecker。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-core-utils:24.2.0</span><br></pre></td></tr></table></figure></p><a id="more"></a><h4 id="v4-core-ui-库"><a href="#v4-core-ui-库" class="headerlink" title="v4 core-ui 库"></a>v4 core-ui 库</h4><p>实现各种 UI 相关组件，例如 ViewPager、NestedScrollView 和 ExploreByTouchHelper。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-core-ui:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v4-media-compat-库"><a href="#v4-media-compat-库" class="headerlink" title="v4 media-compat 库"></a>v4 media-compat 库</h4><p>向后移植部分媒体框架，包括 MediaBrowser 和 MediaSession。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-media-compat:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v4-fragment-库"><a href="#v4-fragment-库" class="headerlink" title="v4 fragment 库"></a>v4 fragment 库</h4><p>添加对使用片段封装用户界面和功能的支持，从而使应用能够提供可以在大屏幕设备与小屏幕设备之间进行调节的布局。此模块依赖于 compat、core-utils、core-ui 和 media-compat。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-fragment:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="Dalvik-可执行文件分包支持库"><a href="#Dalvik-可执行文件分包支持库" class="headerlink" title="Dalvik 可执行文件分包支持库"></a>Dalvik 可执行文件分包支持库</h4><p>此库可以为使用多个 Dalvik Executable (DEX) 文件开发应用提供支持。引用超过 65536 个方法的应用须使用 Dalvik 可执行文件分包配置。如需了解有关使用 Dalvik 可执行文件分包的详细信息，请参阅使用超过 6.4 万种方法开发应用。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:multidex:1.0.0</span><br></pre></td></tr></table></figure></p><h3 id="v7-支持库"><a href="#v7-支持库" class="headerlink" title="v7 支持库"></a>v7 支持库</h3><p>一些库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。这些库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。</p><h4 id="v7-appcompat-库"><a href="#v7-appcompat-库" class="headerlink" title="v7 appcompat 库"></a>v7 appcompat 库</h4><p>此库添加了对操作栏用户界面设计模式的支持。此库包含对 Material Design 用户界面实现的支持。</p><blockquote><p>注：此库依赖于 v4 支持库。</p></blockquote><p>下面是 v7 appcompat 库中包含的一些关键类：</p><ul><li>ActionBar - 提供操作栏用户界面模式的实现。如需了解有关使用操作栏的详细信息，请参阅操作栏开发者指南。</li><li>AppCompatActivity - 添加一个应用 Activity 类，此类可作为使用支持库操作栏实现的 Activity 的基础类。</li><li>AppCompatDialog - 添加一个对话框类，此类可作为 AppCompat 主题对话框的基础类。</li><li>ShareActionProvider - 包含对可以添加到操作栏中的标准化分享操作（例如电子邮件或发帖至社交应用）的支持。<br>此库的 Gradle 构建脚本依赖关系标识符如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:appcompat-v7:24.2.0</span><br></pre></td></tr></table></figure></li></ul><h4 id="v7-cardview-库"><a href="#v7-cardview-库" class="headerlink" title="v7 cardview 库"></a>v7 cardview 库</h4><p>此库添加了对 CardView 小部件的支持，让您能够在卡片内显示信息，从而使应用具备一致的外观。这些卡片对 Material Design 实现非常有用，并在电视应用布局中广为使用。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:cardview-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v7-gridlayout-库"><a href="#v7-gridlayout-库" class="headerlink" title="v7 gridlayout 库"></a>v7 gridlayout 库</h4><p>下载 Android 支持库后，此库可以添加对 GridLayout 类的支持，让您能够使用网状方格安排用户界面元素。如需了解有关 v7 gridlayout 库 API 的详细信息，请参阅 API 参考中的 android.support.v7.widget 软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:gridlayout-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v7-mediarouter-库"><a href="#v7-mediarouter-库" class="headerlink" title="v7 mediarouter 库"></a>v7 mediarouter 库</h4><p>此库可以提供 MediaRouter、MediaRouteProvider 和支持 Google Cast 的相关媒体类。</p><p>一般而言，利用 v7 mediarouter 库中的 API，您可以控制当前设备到外部屏幕、扬声器和其他目标设备的媒体渠道和流的路由。此库包含的 API 可以用于发布应用特定的媒体路由提供程序、发现和选择目标设备，以及检查媒体状态，等等。如需了解有关 v7 mediarouter 库 API 的详细信息，请参阅 API 参考中的 android.support.v7.media 软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:mediarouter-v7:24.2.0</span><br></pre></td></tr></table></figure></p><blockquote><p>支持库 r18 中引入的 v7 mediarouter 库 API 在后续版本的支持库中可能会发生更改。目前，我们建议仅使用与 Google Cast 有关的库。</p></blockquote><h4 id="v7-palette-库"><a href="#v7-palette-库" class="headerlink" title="v7 palette 库"></a>v7 palette 库</h4><p>v7 palette 支持库包含 Palette 类，此类让您可以从图像中抽取突出颜色。例如，音乐应用可以使用 Palette 对象从专辑封面抽取主要颜色，然后使用这些颜色创建一个色彩协调的歌曲标题卡。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:palette-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v7-recyclerview-库"><a href="#v7-recyclerview-库" class="headerlink" title="v7 recyclerview 库"></a>v7 recyclerview 库</h4><p>recyclerview 库添加了 RecyclerView 类。此类能够为 RecyclerView 小部件提供支持，RecyclerView 是一种通过提供有限的数据项窗口有效显示大数据集的视图。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:recyclerview-v7:24.2.0</span><br></pre></td></tr></table></figure></p><p>####v7 Preference 支持库<br>首选项软件包提供的 API 支持添加 preference 对象（例如 CheckBoxPreference 和 ListPreference），方便用户修改 UI 设置。</p><p>v7 Preference 库添加了对接口（例如 Preference.OnPreferenceChangeListener 和 Preference.OnPreferenceClickListener）以及类（例如 CheckBoxPreference 和 ListPreference）的支持。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:preference-v7:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="v8-支持库"><a href="#v8-支持库" class="headerlink" title="v8 支持库"></a>v8 支持库</h3><p>此库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。此库提供了特定的功能集，并且可以单独添加到应用中，与其他库互不影响。</p><h4 id="v8-renderscript-库"><a href="#v8-renderscript-库" class="headerlink" title="v8 renderscript 库"></a>v8 renderscript 库</h4><p>此库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。它添加了对 RenderScript 计算框架的支持。android.support.v8.renderscript 软件包中包含这些 API。请注意，在应用中添加这些 API 的步骤与添加其他支持库 API 迥然不同。如需了解有关在应用中使用这些 API 的详细信息，请参阅 RenderScript 开发者指南。</p><blockquote><p>注：Android Studio 和 Gradle 构建支持使用带支持库的 RenderScript。renderscript 库位于 build-tools/$VERSION/renderscript/ 文件夹中。</p></blockquote><p>以下示例显示了此库的 Gradle 构建脚本属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">defaultConfig &#123;</span><br><span class="line">    renderscriptTargetApi 18</span><br><span class="line">    renderscriptSupportModeEnabled true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="v13-支持库"><a href="#v13-支持库" class="headerlink" title="v13 支持库"></a>v13 支持库</h3><p>此库旨在用于 Android 3.2（API 级别 13）及更高版本。它添加了对带有 (FragmentCompat) 类和其他片段支持类的 Fragment 用户界面模式的支持。如需了解有关片段的详细信息，请参阅片段开发者指南。如需了解有关 v13 支持库 API 的详细信息，请参阅 API 参考中的 android.support.v13 软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-v13:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="v14-Preference-支持库"><a href="#v14-Preference-支持库" class="headerlink" title="v14 Preference 支持库"></a>v14 Preference 支持库</h3><p>android.support.v14.preference 软件包提供的 API 添加了对首选项接口（例如 PreferenceFragment.OnPreferenceStartFragmentCallback 和 PreferenceFragment.OnPreferenceStartScreenCallback）以及类（例如 MultiSelectListPreference 和 PreferenceFragment）的支持。如需了解有关 v14 Preference 支持库 API 的详细信息，请参阅 API 参考中的首选项软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:preference-v14:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="适用于电视的-v17-Preference-支持库"><a href="#适用于电视的-v17-Preference-支持库" class="headerlink" title="适用于电视的 v17 Preference 支持库"></a>适用于电视的 v17 Preference 支持库</h3><p>android.support.v17.preference 软件包提供的 API 可以在电视设备上提供首选项接口，包括对 LeanbackListPreferenceDialogFragment.ViewHolder.OnItemClickListener 接口和类的支持，例如 BaseLeanbackPreferenceFragment 和 LeanbackPreferenceFragment。如需了解有关 v17 Preference 支持库 API 的详细信息，请参阅 API 参考中的首选项软件包。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:preference-leanback-v17:24.2.0</span><br></pre></td></tr></table></figure></p><h4 id="v17-Leanback-库"><a href="#v17-Leanback-库" class="headerlink" title="v17 Leanback 库"></a>v17 Leanback 库</h4><p>android.support.v17.leanback 软件包提供的 API 支持在电视设备上构建用户界面。它为电视应用提供了一些重要的小部件。一些值得注意的类包括：</p><ul><li>BrowseFragment - 一种用于创建主要布局的片段，主要布局用于浏览类别和媒体项目。</li><li>DetailsFragment - 用于 Leanback 细节屏幕的包装器片段。</li><li>PlaybackOverlayFragment - 用于显示播放控件及相关内容的 DetailsFragment 子类。</li><li>SearchFragment - 用于处理搜索的片段。片段可以接收用户的搜索请求并将其传递给应用提供的 SearchResultProvider。SearchResultProvider 可以将搜索结果返回给 SearchFragment，后者会将结果渲染到 RowsFragment 中。</li></ul><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:leanback-v17:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="注解支持库"><a href="#注解支持库" class="headerlink" title="注解支持库"></a>注解支持库</h3><p>注解软件包提供的 API 支持向应用中添加注解元数据。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:support-annotations:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="设计支持库"><a href="#设计支持库" class="headerlink" title="设计支持库"></a>设计支持库</h3><p>设计软件包提供的 API 支持向应用中添加 Material Design 组件和模式。</p><p>设计支持库添加了对应用开发者依赖的各种 Material Design 组件和模式的支持，例如抽屉式导航栏、浮动操作按钮 (FAB)、快捷信息栏和标签页。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:design:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="自定义标签页支持库"><a href="#自定义标签页支持库" class="headerlink" title="自定义标签页支持库"></a>自定义标签页支持库</h3><p>自定义标签页软件包提供的 API 支持向应用中添加自定义标签页并对其进行管理。</p><p>自定义标签页支持库添加了对自定义标签页服务和自定义标签页回调等各种类的支持。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:customtabs:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="百分比支持库"><a href="#百分比支持库" class="headerlink" title="百分比支持库"></a>百分比支持库</h3><p>百分比软件包提供的 API 支持向应用中添加基于百分比的尺寸并对其进行管理。</p><p>百分比支持库添加了对 PercentLayoutHelper.PercentLayoutParams 接口和各种类的支持，例如 PercentFrameLayout 和 PercentRelativeLayout。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:percent:24.2.0</span><br></pre></td></tr></table></figure></p><h3 id="适用于电视的应用建议支持库"><a href="#适用于电视的应用建议支持库" class="headerlink" title="适用于电视的应用建议支持库"></a>适用于电视的应用建议支持库</h3><p>应用建议软件包提供的 API 支持向电视设备上运行的应用中添加内容建议。</p><p>应用库添加了对注解（例如 ContentRecommendation.ContentMaturity 和各种类（例如 ContentRecommendation 和 RecommendationExtender）的支持。</p><p>此库的 Gradle 构建脚本依赖关系标识符如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.android.support:recommendation:24.2.0</span><br></pre></td></tr></table></figure></p><p>看完上面的介绍，是不是对 Google 这些 Support 库 有了更全面的了解以及各版本之间的区别。如果希望就分享出去让更多的人知道吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;Android 支持库软件有多个库，每个库均支持特定范围的 Android 平台版本和功能。像大家比较熟悉的 v4 、v7、 v13、v14 等。下面将分别介绍下各个库版本所兼容或带来的功能有哪些？&lt;/p&gt;
&lt;h3 id=&quot;v4-支持库&quot;&gt;&lt;a href=&quot;#v4-支持库&quot; class=&quot;headerlink&quot; title=&quot;v4 支持库&quot;&gt;&lt;/a&gt;v4 支持库&lt;/h3&gt;&lt;p&gt;v4库旨在与 Android 2.3（API 级别 9）及更高版本搭配使用。与其他支持库相比，它们包含的 API 集合最大，包括对应用组件、用户界面功能、辅助功能、数据处理、网络连接以及编程实用工具的支持。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在支持库修订版 24.2.0 之前，存在一个 v4 支持库。为了提高效率，此库拆分成多个模块。出于向后兼容的考虑，如果您在 Gradle 脚本中列出了 support-v4，您的 APK 将包含所有的 v4 模块。不过，要减少 APK 大小，我们建议仅列出应用需要的特定模块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;v4-compat-库&quot;&gt;&lt;a href=&quot;#v4-compat-库&quot; class=&quot;headerlink&quot; title=&quot;v4 compat 库&quot;&gt;&lt;/a&gt;v4 compat 库&lt;/h4&gt;&lt;p&gt;此为众多框架 API 提供兼容性包装器，例如 Context.obtainDrawable() 和 View.performAccessibilityAction()&lt;/p&gt;
&lt;p&gt;此库的 Gradle 构建脚本依赖关系标识符如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;com.android.support:support-compat:24.2.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;v4-core-utils-库&quot;&gt;&lt;a href=&quot;#v4-core-utils-库&quot; class=&quot;headerlink&quot; title=&quot;v4 core-utils 库&quot;&gt;&lt;/a&gt;v4 core-utils 库&lt;/h4&gt;&lt;p&gt;提供大量实用程序类，例如 AsyncTaskLoader 和 PermissionChecker。&lt;/p&gt;
&lt;p&gt;此库的 Gradle 构建脚本依赖关系标识符如下所示：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;com.android.support:support-core-utils:24.2.0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>【推荐】开发人员必备的强兵利器</title>
    <link href="http://www.wxtlife.com/2017/09/27/developers-need-tools/"/>
    <id>http://www.wxtlife.com/2017/09/27/developers-need-tools/</id>
    <published>2017-09-27T11:47:59.000Z</published>
    <updated>2018-03-16T15:49:44.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>熟话说“工欲善其事，必先利其器”，那么今天整理了些目前开发常用的一些软件或者插件，分享给大家，主要都是提高效率，便于开发的工具，希望能够对你的工作，学习有所帮助。</p><p>那么本篇文章将推荐5个插件类工具和5个软件类工具。分别介绍如下：</p><h3 id="插件类"><a href="#插件类" class="headerlink" title="插件类"></a>插件类</h3><h4 id="1-gliffy-Diagrams"><a href="#1-gliffy-Diagrams" class="headerlink" title="1. gliffy Diagrams"></a>1. gliffy Diagrams</h4><p>gliffy Diagrams一个轻量级Chrome 插件，简单易用，可以用它进行各种图形的绘制，比如：流程化，类图等，而且可以直接导入visio的文件进行二次编辑，绘制完成后，可以直接与google 云盘连接，便于保存和同步，当然其也有很多的主题与模板可供选择，绘制这些图，是开发理清思路的第一步。<br>界面如下：<br><img src="/img/tools/gliffy.jpeg" alt="gliffy"></p><h4 id="2-Momentum"><a href="#2-Momentum" class="headerlink" title="2.Momentum"></a>2.Momentum</h4><p>Momentum 可以给Chrome浏览器每天更换新标签页，让你每天可以看到漂亮的美图，除了美图风景，还有很多附加小功能，比如，天气，todolist，时间，今日任务，搜索等，可以给你的浏览器焕然一新。<br>一起来感受下美观的界面：<br><img src="/img/tools/motion.jpeg" alt="motion"></p><a id="more"></a><h4 id="3-Postman"><a href="#3-Postman" class="headerlink" title="3. Postman"></a>3. Postman</h4><p>Postman 是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件。当开发人员需要调试相应后台接口时，可以把各种模拟用户HTTP请求的数据发送到服务器，以便开发人员能够及时地作出正确的响应，或者是对产品发布之前的错误信息提前处理，进而保证产品上线之后的稳定性和安全性。值得推荐的一个插件。<br>界面如下：<br><img src="/img/tools/postman.jpeg" alt="postman"></p><h4 id="4-Octotree"><a href="#4-Octotree" class="headerlink" title="4. Octotree"></a>4. Octotree</h4><p>Octotree 是一款可以在github上浏览代码，可以向本地一样方便便捷，简化各种目录间跳转的复杂，对在github阅读源码体验有很大的提升。<br>界面如下：<br><img src="/img/tools/tree.jpeg" alt="octotree"></p><h4 id="5-OneTab"><a href="#5-OneTab" class="headerlink" title="5. OneTab"></a>5. OneTab</h4><p>OneTab 是一款可以帮助用户一键杀死谷歌浏览器中所有标签页并通过提示恢复部分有用标签页的Chrome插件。当我们有很多的页面暂时不需要浏览了，但后续还需要的话，就可以使用OneTab进行保存，这样不仅可以保存浏览的网页，还可以省很多浏览器内存。<br>界面如下：<br><img src="/img/tools/onetable.jpeg" alt="onetable"></p><h3 id="软件类"><a href="#软件类" class="headerlink" title="软件类"></a>软件类</h3><h4 id="1-Charlas"><a href="#1-Charlas" class="headerlink" title="1. Charlas"></a>1. Charlas</h4><p>Charlas 是一个HTTP代理服务器,HTTP监视器,反转代理服务器，当连接Charles的代理访问互联网时，Charles可以监控浏览器发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括request, response和HTTP headers （包含cookies与caching信息）。<br><img src="/img/tools/charlets.jpeg" alt="charlets"></p><h4 id="2-Markman"><a href="#2-Markman" class="headerlink" title="2. Markman"></a>2. Markman</h4><p>Markman 是一个高效的设计稿标注、测量工具。这个工具主要是设计师使用，但偶尔开发也可以用下看下设计稿的标注等信息。主要功能，长度标记，坐标和矩形标记，颜色值标记，文字的标记说明。<br><img src="/img/tools/markman.jpeg" alt="markman"></p><h4 id="3-SourceTree"><a href="#3-SourceTree" class="headerlink" title="3. SourceTree"></a>3. SourceTree</h4><p>SourceTree 是一个简化了与Git存储库进行交互，从而可以专注于编码。通过Sourcetree的简单Git GUI可视化和管理您的存储库。可以与Github仓库绑定，点击某个提交，可以看到所有相关的修改信息。对开发者来说很是方便。<br><img src="/img/tools/sourcetree.jpeg" alt="sourcetree"></p><h4 id="4-1Password"><a href="#4-1Password" class="headerlink" title="4. 1Password"></a>4. 1Password</h4><p>1Password是管理网站登录和敏感信息的最好应用，它拥有友好的用户界面，可以在任何时刻在任何设备上使用，包括笔记本电脑、手机等。支持浏览器，可以在浏览器上不用输入账号密码实现登录功能，但是需要保存好主密码，不然其他密码都会泄露了。目前手机端的应用是免费的，PC端的需要收费。<br><img src="/img/tools/1password.jpeg" alt="1password"></p><h4 id="5-ohMyStar2-仅有mac端"><a href="#5-ohMyStar2-仅有mac端" class="headerlink" title="5. ohMyStar2  (仅有mac端)"></a>5. ohMyStar2  (仅有mac端)</h4><p>OhMyStar2 可以无缝同步你在Github star的所有repo，在本地浏览、搜索这些stared repo，还能根据语言自动分组（自动侦测你加星的repo所使用的语言，菜单栏-Tool-Group with languages），而且你能手动对所有repo进行group，可以按照日，周，月，发现流行的github仓库。所有数据都能通过iCloud进行备份/还原。<br><img src="/img/tools/ohmystart.jpeg" alt="onmystar2"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>希望上面10款工具可以给你带来工作上的便捷和帮助，如果喜欢，就把他分享出去吧，让更多人知道有这么多好的工具可提高我们的效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;熟话说“工欲善其事，必先利其器”，那么今天整理了些目前开发常用的一些软件或者插件，分享给大家，主要都是提高效率，便于开发的工具，希望能够对你的工作，学习有所帮助。&lt;/p&gt;
&lt;p&gt;那么本篇文章将推荐5个插件类工具和5个软件类工具。分别介绍如下：&lt;/p&gt;
&lt;h3 id=&quot;插件类&quot;&gt;&lt;a href=&quot;#插件类&quot; class=&quot;headerlink&quot; title=&quot;插件类&quot;&gt;&lt;/a&gt;插件类&lt;/h3&gt;&lt;h4 id=&quot;1-gliffy-Diagrams&quot;&gt;&lt;a href=&quot;#1-gliffy-Diagrams&quot; class=&quot;headerlink&quot; title=&quot;1. gliffy Diagrams&quot;&gt;&lt;/a&gt;1. gliffy Diagrams&lt;/h4&gt;&lt;p&gt;gliffy Diagrams一个轻量级Chrome 插件，简单易用，可以用它进行各种图形的绘制，比如：流程化，类图等，而且可以直接导入visio的文件进行二次编辑，绘制完成后，可以直接与google 云盘连接，便于保存和同步，当然其也有很多的主题与模板可供选择，绘制这些图，是开发理清思路的第一步。&lt;br&gt;界面如下：&lt;br&gt;&lt;img src=&quot;/img/tools/gliffy.jpeg&quot; alt=&quot;gliffy&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;2-Momentum&quot;&gt;&lt;a href=&quot;#2-Momentum&quot; class=&quot;headerlink&quot; title=&quot;2.Momentum&quot;&gt;&lt;/a&gt;2.Momentum&lt;/h4&gt;&lt;p&gt;Momentum 可以给Chrome浏览器每天更换新标签页，让你每天可以看到漂亮的美图，除了美图风景，还有很多附加小功能，比如，天气，todolist，时间，今日任务，搜索等，可以给你的浏览器焕然一新。&lt;br&gt;一起来感受下美观的界面：&lt;br&gt;&lt;img src=&quot;/img/tools/motion.jpeg&quot; alt=&quot;motion&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://www.wxtlife.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>十分钟理清常见的开源协议</title>
    <link href="http://www.wxtlife.com/2017/09/18/License-different/"/>
    <id>http://www.wxtlife.com/2017/09/18/License-different/</id>
    <published>2017-09-18T15:45:30.000Z</published>
    <updated>2018-03-16T15:49:44.450Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>从上次和大家聊了下 <a href="http://www.wxtlife.com/2017/09/10/00-ceo-fun-things/">00后CEO的那些趣事</a>，谈到了开源协议相关的内容，那么本篇文章，就主要介绍下大家在工作生活中常用到的开原协议。常见的协议如下：ApacheLicense 2.0 、GPLv3 、LGPL、、MIT License、BSD 和 Mozilla 2.0  。那么我们下面就分别介绍下这些协议的说明、允许项及禁止项。</p><h3 id="Apache-License-2-0"><a href="#Apache-License-2-0" class="headerlink" title="Apache License 2.0"></a>Apache License 2.0</h3><p>这是一个著名的非盈利开源组织Apache采用的协议，它励代码共享和尊重原作者的著作权，同时也允许代码修改，再发布（作为开源或商业软件）。</p><ul><li>要求</li></ul><ol><li>在代码中保留作者提供的协议和版权信息</li><li>如果修改了代码，则必须在被修改的文件中进行说明。</li></ol><ul><li><p>允许的权利<br>商用、分发、修改、专利授权、私用、附加协议</p></li><li><p>禁止项</p></li></ul><ol><li>禁止因使用等造成影响责任承担、也就是说免责申明</li><li>不能使用相应的商标。</li></ol><p><strong>提示：商业软件可以使用，也可以修改使用Apache协议的代码。</strong></p><h3 id="GPLv3"><a href="#GPLv3" class="headerlink" title="GPLv3"></a>GPLv3</h3><p>此协议是应用最为广泛的开源协议，拥有较强的版权自由要求,也赋予和保证了开源项目开发者广泛的权利。基本上，它允许用户合法复制，分发和修改软件，但衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，不同变种的要求略有不同。</p><a id="more"></a><ul><li>要求</li></ul><ol><li>修改后的源码也需要公开</li><li>版权及协议也要于此协议一致</li><li>修改后，需要在相应的文件做说明，</li></ol><ul><li><p>允许<br>商用，分发，修改，专利授权，私用</p></li><li><p>禁止</p></li></ul><ol><li>禁止因使用等造成影响责任承担、也就是说免责申明</li><li>静止在软件分发传播过程中附加上原来没有的协议条款等</li></ol><p><strong>提示：商业软件不能使用GPL协议的代码。</strong></p><h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>其主要用于一些代码库，LGPL比起GPL它授予的权限较少，LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。因此使用LGPL协议的开源代码可以被商业软件作为<strong>类库引用</strong>并发布和销售。注意是以类库的形式使用，也就是说如果修改了源代码的话则也必须使用LGPL协议贡献源码出来。</p><ul><li>要求</li></ul><ol><li>公开使用了LGPL部分的代码，其余部分不需要公开。</li><li>可以库引用的方式用于商业软件。</li><li>在代码中保留作者提供的协议和版权信息</li></ol><ul><li><p>允许<br>商用、分发、修改、专利授权、私用、附加协议</p></li><li><p>禁止<br>禁止承担责任，(免责申明)、</p></li></ul><p><strong>提示：商业软件可以使用，但不能修改LGPL协议的代码。</strong></p><p><strong>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品</strong></p><h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>宽松简单且精要的一个协议。在适当标明来源及免责的情况下，它允许你对代码进行任何形式的使用,也就是原作者只想保留版权,而无任何其他了限制,而你必须在发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的。</p><ul><li><p>要求<br>在代码中保留作者提供的协议和版权信息</p></li><li><p>允许<br>商用、分发、修改、私用、附加协议</p></li><li><p>禁止<br>禁止承担责任，(免责申明)</p></li></ul><p><strong>提示：商业软件可以使用，也可以修改MIT协议的代码，甚至可以出售MIT协议的代码。</strong></p><h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。与MIT协议只存在细微差异。差别为MIT可以使用原名称进行宣传，而BSD不可以。</p><ul><li><p>要求<br>在代码中保留作者提供的协议和版权信息</p></li><li><p>允许<br>商用、分发、修改、私用、附加协议</p></li><li><p>禁止<br>禁止承担责任，(免责申明)</p></li></ul><p><strong>提示：商业软件可以使用，也可以修改使用BSD协议的代码。</strong></p><h3 id="Mozilla-2-0"><a href="#Mozilla-2-0" class="headerlink" title="Mozilla 2.0"></a>Mozilla 2.0</h3><p>是由Mozilla基金创建维护的。此协议旨在较为宽松的BSD协议和更加互惠的GPL协议中寻找一个折衷点，允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者。这种授权维护了商业软件的利益，它要求基于这种软件得修改无偿贡献版权给该软件。</p><ul><li>要求</li></ul><ol><li>公开源代码</li><li>在代码中保留作者提供的协议和版权信息</li></ol><ul><li><p>允许<br>商用、分发、修改、专利授权、私用、附加协议</p></li><li><p>禁止</p></li></ul><ol><li>禁止承担责任，(免责申明)</li><li>禁止使用商标</li></ol><p><strong>提示：商业软件可以使用，也可以修改MPL协议的代码，但修改后的代码版权归软件的发起者。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是我们常见的开源协议的一些区别，后面三种协议的区别较小，需要特别注意。如果觉得上面不好记，那么久收藏本文吧，在需要的时候进行查看复习，或者提供下面网址供大家进行查看。<br><a href="http://choosealicense.online/appendix/" target="_blank" rel="noopener">http://choosealicense.online/appendix/</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;从上次和大家聊了下 &lt;a href=&quot;http://www.wxtlife.com/2017/09/10/00-ceo-fun-things/&quot;&gt;00后CEO的那些趣事&lt;/a&gt;，谈到了开源协议相关的内容，那么本篇文章，就主要介绍下大家在工作生活中常用到的开原协议。常见的协议如下：ApacheLicense 2.0 、GPLv3 、LGPL、、MIT License、BSD 和 Mozilla 2.0  。那么我们下面就分别介绍下这些协议的说明、允许项及禁止项。&lt;/p&gt;
&lt;h3 id=&quot;Apache-License-2-0&quot;&gt;&lt;a href=&quot;#Apache-License-2-0&quot; class=&quot;headerlink&quot; title=&quot;Apache License 2.0&quot;&gt;&lt;/a&gt;Apache License 2.0&lt;/h3&gt;&lt;p&gt;这是一个著名的非盈利开源组织Apache采用的协议，它励代码共享和尊重原作者的著作权，同时也允许代码修改，再发布（作为开源或商业软件）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要求&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;在代码中保留作者提供的协议和版权信息&lt;/li&gt;
&lt;li&gt;如果修改了代码，则必须在被修改的文件中进行说明。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;允许的权利&lt;br&gt;商用、分发、修改、专利授权、私用、附加协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;禁止项&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;禁止因使用等造成影响责任承担、也就是说免责申明&lt;/li&gt;
&lt;li&gt;不能使用相应的商标。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;提示：商业软件可以使用，也可以修改使用Apache协议的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;GPLv3&quot;&gt;&lt;a href=&quot;#GPLv3&quot; class=&quot;headerlink&quot; title=&quot;GPLv3&quot;&gt;&lt;/a&gt;GPLv3&lt;/h3&gt;&lt;p&gt;此协议是应用最为广泛的开源协议，拥有较强的版权自由要求,也赋予和保证了开源项目开发者广泛的权利。基本上，它允许用户合法复制，分发和修改软件，但衍生代码的分发需开源并且也要遵守此协议。此协议有许多变种，不同变种的要求略有不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="License" scheme="http://www.wxtlife.com/tags/License/"/>
    
  </entry>
  
  <entry>
    <title>00后CEO引起的那些趣事</title>
    <link href="http://www.wxtlife.com/2017/09/10/00-ceo-fun-things/"/>
    <id>http://www.wxtlife.com/2017/09/10/00-ceo-fun-things/</id>
    <published>2017-09-10T15:24:08.000Z</published>
    <updated>2018-03-16T15:49:44.447Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h4></blockquote><p>今天要来说点有趣的事情了，事情的大致起因呢是这样的，在前几天播出的一档节目中采访了<code>崇才网络科技</code>公司的CEO,然而这家CEO不简单，竟然是00后，这下子让还在为生活打拼的80及90后，开始不安了，在网络上引起极大的关注，再加上雷军转发了那位天才CEO的微博表示对00后CEO的祝贺和肯定。如下：</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/4/86a1ded6a7b86a0c393c49c827fabef0" alt=""></p><p>熟话说树大招风，不久的几天后，首位 00 后 CEO 遭“打脸”被指抄袭开源作品，被网名ID为<code>墨镜猫</code>发现其抄袭其在<code>github</code>上的开源作品。还被指责其抄袭都不够格，简直就是赤裸裸的复制粘贴，就连里面的图片素材都没有更换。这位墨镜猫的个人网址如下:<a href="http://www.jackywang.tech/" target="_blank" rel="noopener">http://www.jackywang.tech/</a> 其在主页上发表了一篇文章为<a href="http://www.jackywang.tech/2017/09/05/%E4%B8%AD%E5%9B%BD%E9%A6%96%E4%BD%8D00%E5%90%8ECEO%E5%85%AC%E7%84%B6%E6%8A%84%E8%A2%AD%E3%80%81%E5%A4%8D%E5%88%B6%E6%88%91%E7%9A%84%E5%BC%80%E6%BA%90%E4%BD%9C%E5%93%81/" target="_blank" rel="noopener">中国首位00后CEO公然抄袭、复制我的开源作品</a>。</p><a id="more"></a><p>侵权的画面截图：<br><img src="https://user-gold-cdn.xitu.io/2017/9/4/519632499c052e8dfd7defb9d5bf6c61" alt="侵权截图"></p><p>原作者的软件界面：<br><img src="https://user-gold-cdn.xitu.io/2017/9/4/ab4550b558c0fb7eb4091bc39e59e47b" alt="原作者"></p><p>程序员应该都知道在开源软件一般都是有开源协议的，有很多的类型，可以保护自己的知识产权，那说到这里，我们就直接找到<code>墨镜猫</code> 在github上开源的项目去看看到底使用的是什么开原协议呢，其github开源项目地址如下:<a href="https://github.com/JackyAndroid/AndroidTVLauncher" target="_blank" rel="noopener">https://github.com/JackyAndroid/AndroidTVLauncher</a></p><p>进到项目看到如下图的信息：<br><img src="/img/ceo/project.png" alt="项目主页"></p><p>初步看到开源协议是GPL3.0，这个协议是很少有商业公司使用的，因为使用者需要将修改后的代码也需要开源并且使用同样的协议， 看到这里真为这位00后CEO捏了一把汗，毕竟公司使用后，要想不维权，是需要开源修改后的代码的，这对商业公司是个不小的伤害，假装心痛一秒钟。</p><p>接着再仔细看看上图圆圈的部分，发现最近3天有修改，于是好奇的打开 提交历史页面，看到如下信息：<br><img src="/img/ceo/all-commit.png" alt="项目主页"></p><p>从commit用语很犀利，作者应该很生气，好奇心害死猫，于是从最开始的commit的开始看修改记录，然后看到下面的时候，震惊了，修改记录如下：</p><p><img src="/img/ceo/modify-lisence.png" alt="项目主页"></p><p>看到作者将原来的<code>Apache License 2.0</code>协议改为<code>GNU GPLv3</code>的协议了，这剧情反转的有点措手不及。然后顺便再看下后面的评论。也是挺有意思的。</p><p><img src="/img/ceo/pinglun1.png" alt="项目主页"></p><p>这位网友也是看热闹不怕事情大，不停的嘲讽说是太迟啦，来不及啦。。。</p><p><img src="/img/ceo/pinglun2.png" alt="项目主页"></p><p>这位程序员则认为在中国版权意识没有那么强，不管你啥协议都有人照抄，只是没出名，没被发现而已，版权都是大公司间的把戏。。想想似乎也是这么个理。。我竟无言以对。</p><p><img src="/img/ceo/pinglun3.png" alt="项目主页"></p><p>这位网友则比较同情作者，在帮助他从<code>Apache License 2.0</code>中找到可以维权的证据。然而这就需要看侵权者是否真的有这方面的维权喽。</p><p><img src="/img/ceo/pinglun4.png" alt="项目主页"></p><p>这位程序员也是使出了独门武器来告诉作者，现在修改协议似乎很容易被发现，有一种伪造修改记录时间的方法，使用<code>git filter-branch</code>来进行神操作，具体使用方法如下：<a href="https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2#核弹级选项:-filter-branch" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2#核弹级选项:-filter-branch</a></p><p>看到这里似乎有些懂了，没有完全了解开源协议而随便使用的问题应该是比较普遍的，所以对于各种开源协议，以及知识共享协议等，都需要弄清它们的权利要求以及限制等，这样才能用的安心，那么后面就会说说，开源协议中常用协议的权利要求及限制等等，敬请期待！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h4&gt;&lt;/blockquote&gt;
&lt;p&gt;今天要来说点有趣的事情了，事情的大致起因呢是这样的，在前几天播出的一档节目中采访了&lt;code&gt;崇才网络科技&lt;/code&gt;公司的CEO,然而这家CEO不简单，竟然是00后，这下子让还在为生活打拼的80及90后，开始不安了，在网络上引起极大的关注，再加上雷军转发了那位天才CEO的微博表示对00后CEO的祝贺和肯定。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/9/4/86a1ded6a7b86a0c393c49c827fabef0&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;熟话说树大招风，不久的几天后，首位 00 后 CEO 遭“打脸”被指抄袭开源作品，被网名ID为&lt;code&gt;墨镜猫&lt;/code&gt;发现其抄袭其在&lt;code&gt;github&lt;/code&gt;上的开源作品。还被指责其抄袭都不够格，简直就是赤裸裸的复制粘贴，就连里面的图片素材都没有更换。这位墨镜猫的个人网址如下:&lt;a href=&quot;http://www.jackywang.tech/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.jackywang.tech/&lt;/a&gt; 其在主页上发表了一篇文章为&lt;a href=&quot;http://www.jackywang.tech/2017/09/05/%E4%B8%AD%E5%9B%BD%E9%A6%96%E4%BD%8D00%E5%90%8ECEO%E5%85%AC%E7%84%B6%E6%8A%84%E8%A2%AD%E3%80%81%E5%A4%8D%E5%88%B6%E6%88%91%E7%9A%84%E5%BC%80%E6%BA%90%E4%BD%9C%E5%93%81/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中国首位00后CEO公然抄袭、复制我的开源作品&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="趣事" scheme="http://www.wxtlife.com/tags/%E8%B6%A3%E4%BA%8B/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin开发基础（一）</title>
    <link href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/"/>
    <id>http://www.wxtlife.com/2017/09/08/kotlin-share-1/</id>
    <published>2017-09-08T15:17:40.000Z</published>
    <updated>2018-03-16T15:49:44.452Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="想第一时间获取我的最新文章，请关注公众号-技术特工队"><a href="#想第一时间获取我的最新文章，请关注公众号-技术特工队" class="headerlink" title="想第一时间获取我的最新文章，请关注公众号: 技术特工队"></a>想第一时间获取我的最新文章，请关注公众号: <a href="http://www.wxtlife.com/img/qrcode/qrcode.jpg">技术特工队</a></h3></blockquote><ul><li><strong><a href="http://www.wxtlife.com/2017/09/08/kotlin-share-1/">Kotlin开发基础（一）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/12/kotlin-share-2/">Kotlin开发基础（二）</a></strong></li><li><strong><a href="http://www.wxtlife.com/2017/12/17/kotlin-share-3/">Kotlin开发基础（三）</a></strong></li></ul><h3 id="为什么学习kotlin"><a href="#为什么学习kotlin" class="headerlink" title="为什么学习kotlin"></a>为什么学习kotlin</h3><p>kotlin在今年的Google IO 上正式被确认为Android的官方开发语言，想必原因大家也能猜到一二，一是Google与oracle关于Java相关的版权相关的问题，二是kotlin语言很简洁，不罗嗦，支持很多的新特性。</p><p>由于Google都已经官方支持了，语法简洁高效，和IOS的 swift 很是相似，发展趋势不可小觑，还有个大新闻就是我们的大神 <a href="https://github.com/JakeWharton" target="_blank" rel="noopener">Jake Wharton</a> 从square 辞职加入了Google，且其在最近的github中国fork了kotlin 仓库，想必是为kotlin在Android的发展做贡献，就从这可以断定kotlin的未来不会太差， 当然作为技术人就需要不断的学习，不段的挑战。如果想在Android上继续深造kotlin肯定是要学习的。</p><h3 id="怎么学习"><a href="#怎么学习" class="headerlink" title="怎么学习"></a>怎么学习</h3><p>我的想法是，大家都是学过基本的语言的，比如C，C++，做Android的肯定学过Java，所以我的想法是对照Java的基础与kotlin基础做对比着学习， 这样印象会深刻点，差异化学习。</p><h3 id="Kotlin基础"><a href="#Kotlin基础" class="headerlink" title="Kotlin基础"></a>Kotlin基础</h3><h4 id="Kotlin-数据类型"><a href="#Kotlin-数据类型" class="headerlink" title="Kotlin 数据类型"></a>Kotlin 数据类型</h4><p>在kotlin语言中，所有的类型都是都是对象，kotlin中没有了基础数据类型（int，boolean，char，byte）等。全部换为对象类型。类型如下：<br><code>Int</code>,<code>Boolean</code>,<code>String</code>,<code>Byte</code>,<code>Float</code>,<code>Char</code>,<code>Double</code>,<code>Short</code>，这些没有了Java中隐式拓宽转换，例如不能把Int类型直接赋值给Long类型了，如要要这样做这些书类型可以调用如下方法进行转换：</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">toByte():   <span class="built_in">Byte</span></span><br><span class="line">toShort():  <span class="built_in">Short</span></span><br><span class="line">toInt():    <span class="built_in">Int</span></span><br><span class="line">toLong():   <span class="built_in">Long</span></span><br><span class="line">toFloat():  <span class="built_in">Float</span></span><br><span class="line">toDouble(): <span class="built_in">Double</span></span><br><span class="line">toChar():   <span class="built_in">Char</span></span><br></pre></td></tr></table></figure><p>kotlin 中各数字类型所占位数如下：</p><table><thead><tr><th>Type</th><th>bit</th></tr></thead><tbody><tr><td>Double</td><td>64</td></tr><tr><td>Long</td><td>64</td></tr><tr><td>Float</td><td>32</td></tr><tr><td>Int</td><td>32</td></tr><tr><td>Short</td><td>16</td></tr><tr><td>Byte</td><td>8</td></tr></tbody></table><p>数值常量和Java中基本无区别，十进制：123，十六进制：0x1F。</p><p>主要是以下几种字面值常量： </p><ul><li>十进制数值: 123</li><li>长整型要加大写 L : 123L</li><li>16进制：0x0f</li><li>二进制：0b00001011</li><li>默认双精度浮点数(Double) : 123.5 , 123.5e10</li><li>单精度浮点数(Float)要添加 f 或 F ：123.5f</li></ul><p><strong>注意: kotlin不支持八进制</strong></p><p><strong>黑魔法：</strong> 在我们写Int或者Long类型数据时，常常一写一长串，不便于识别，现在kotlin支持在数字常量中可以添加<code>_</code>了，便于阅读，不影响数据类型和值，例如电话号码可以这样写了。<code>val phone : Long = 186_****_0814</code>便于我们阅读。不得不说kotlin语言的灵活性。</p><p><strong>kotlin中不会在末尾写分号啦！！！！！</strong></p><h4 id="与-的区别"><a href="#与-的区别" class="headerlink" title="== 与 ===的区别"></a>== 与 ===的区别</h4><p>在kotlin中多了一种判断符<code>===</code>三个等号，这个特点呢就是判断两个对象是否指向同一个对象，也就是引用相等，而<code>==</code>则表示的数据的结构相等，也就是调用<code>equals</code>方法的返回值。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a : Int = 3 </span><br><span class="line">println(a===a)  // true </span><br><span class="line">var b : Int  = a</span><br><span class="line">var c : Int = a</span><br><span class="line">println(b===c) // false 因为指向的对象不是同一个</span><br><span class="line">println(b==c)  // true</span><br></pre></td></tr></table></figure></p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串有两种表达方式，一种是可以带转义符的，另外一种是可以包含任意字符的。例如下面有转义的<code>val s = &quot;hello world \n&quot;</code> ，但如果真正的字符串就是上面带有转义字符<code>\n</code>的，那么要怎么表示呢，kotlin中使用三引号 <code>&quot;&quot;&quot;</code>来表示，例如：<code>val s = &quot;&quot;&quot;hello world \n&quot;&quot;&quot;</code> 这样<code>\n</code>就不会被转义为回车，而是原封原样的字符串了。</p><p>字符串还有了很好的模板特性，会极大的方便字符串拼接，操作等。下面就直接看例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val a = 1</span><br><span class="line">var str : String = &quot;this num is $a&quot;</span><br><span class="line">a = 2</span><br><span class="line">val s2 = &quot;$&#123;str.replace(&quot;is&quot;, &quot;was&quot;)&#125;, but now is $a&quot;</span><br></pre></td></tr></table></figure></p><p>可以看到这极大的方便字符串的操作，使用$即可直接取到变量的值，如果在字符串中操作则使用表达式<code>${}</code>直接对字符串进行操作。</p><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><p>控制流基本与java中常用的保持一致，有<code>for</code>,<code>while</code>,但<code>switch</code>在kotlin中换为<code>when</code>，学过其他语言的应该都能很容易的掌握。</p><h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p>for循环使用 in 关键字进行遍历，普通的如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val array = 1..100</span><br><span class="line">for (value in array) &#123;</span><br><span class="line">    print(&quot;value = $value&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于之前for循环的步长使用<code>step</code>来表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (i in 1..100 step 2) &#123;</span><br><span class="line">    print(&quot;i = $i&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 1..100  表示是闭区间 ，[1,100]</span><br></pre></td></tr></table></figure></p><p>为了表示开闭区间，可以使用<code>until</code> 来表示。如下:<code>1 until 100</code> 表示 [1,100)</p><p>倒序的话将<code>..</code>替换为<code>downTo</code></p><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p><code>while</code> 循环与java 一样，不在多说，以及<code>do while</code></p><h5 id="when"><a href="#when" class="headerlink" title="when"></a>when</h5><p>when 的功能与java switch 功能类似，但是其便捷性不仅仅能case 一些基本数据类型，它可以支持表达式，这样会更加的灵活便捷。下面看个例子吧：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fun describe(obj: Any): String =</span><br><span class="line">    when (obj) &#123;</span><br><span class="line">        1,&apos;1&apos; -&gt; &quot;One&quot;</span><br><span class="line">        &quot;Hello&quot;,&quot;Good&quot; -&gt; &quot;Greeting&quot;</span><br><span class="line">        is Long -&gt; &quot;Long&quot;</span><br><span class="line">        !is String -&gt; &quot;Not a string&quot;</span><br><span class="line">        else -&gt; &quot;Unknown&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到上面的是不是很灵活? 可以对不同的类型在同一个分支中进行判断，极大的提高了灵活性。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul><li>数组：</li></ul><p>在Kotlin中使用<code>Array</code>来表示数组，它本身定义了<code>set</code>,<code>get</code>,<code>size</code>等属性，可以使用<code>arrayOf</code>来创建数组，例如：<code>var test = arrayof(1,2,3)</code>,数组中的数据类型可以是任何类型，但是使用时需要注意类型，访问可以用<code>get(index)</code> 或者<code>[index]</code>来访问，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (ar in array) &#123;</span><br><span class="line">    print(&quot;array value = $ar&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (i in array.indices) &#123;</span><br><span class="line">    print(&quot;array value = $array[i]&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>List</li></ul><p>list的创建也很简便，使用<code>listOf</code>创建，使用<code>val list = listOf(1,2,3,&quot;string&quot;)</code>, 当然遍历也提供了多种方式，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (it in list) &#123;</span><br><span class="line">    print(&quot;list value = $it&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 带下标，以及值的遍历方式</span><br><span class="line">for ((index,value) in list.withIndex()) &#123;</span><br><span class="line">    print(&quot;index = $index value = $value &quot; )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>Map</li></ul><p>map的创建<code>val map = mapOf(&quot;a&quot; to 1, &quot;b&quot; to 2, &quot;c&quot; to 3)</code>,访问也是很简单，比java中访问简单太多，方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ((key, value) in map) &#123;</span><br><span class="line">    print(&quot;key = $key  value = $value&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到上面常见集合的类型套路都是一样使用<code>类型Of()</code>来创建，访问遍历也是很方便。</p><h4 id="空安全"><a href="#空安全" class="headerlink" title="空安全"></a>空安全</h4><p>在kotlin是空类型安全的，所以如果要给一个变量赋值为null，则必须在其定义后面加上？,否则无法编译器会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str : String ? = null </span><br><span class="line">var  size =  str.length   //此时会编译报错，提示可能为空</span><br></pre></td></tr></table></figure></p><p>那么怎么获取呢，在kotlin中提供两种方法来访问，第一种为<code>?.</code>的访问形式，此种表示如果为空则不执行，非空再继续，则上面则可以写成这样<code>val size = str?.length</code>,第二种就是可能在执行前给变量赋值了，我们肯定它不为空，那么可以用<code>!!.</code>来获取，如下：<code>val size = str!!.length</code>,当然第二种你必须为运行时控制住做好心理准备。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在Java中变量有普通的变量，静态常量（<code>final</code>），静态编量(<code>static</code>)，但在kotlin中没有<code>static</code>关键字了，需要使用静态变量有另外的一种表示，后续在将这部分，那在kotlin中的变量的表示方式为<code>var</code>,常量的表达方式为<code>val</code>, 具体表达方式如下： </p><p><code>val a :Float = 1f</code>, <code>val a = &quot;Aaron&quot;, var c :Int = 2, c += 2</code><br>kotlin中定义的类型是放在变量后面的，且类型有时可省略。</p><p><code>var a : Int = 2</code>, <code>var a = 2</code> 这两个表达的是一样的，后面的表达式会进行自动类型推倒。</p><p>kotlin是空类型安全的，所以在赋值时也有些差别，如果想要空类型的则在赋值后面需要加<code>？</code>，</p><h4 id="延迟属性"><a href="#延迟属性" class="headerlink" title="延迟属性"></a>延迟属性</h4><p>延迟属性或者延初始化可以帮助我们在需要用到时在初始化，不需要时不初始化，帮助程序节省内存空间及启动速度。</p><p>在kotlin中使用<code>lazy</code>关键字来表示。直接看下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val answer by lazy &#123;</span><br><span class="line">    println(&quot;Calculating the answer...&quot;)</span><br><span class="line">    42</span><br><span class="line">&#125;</span><br><span class="line">if (needAnswer()) &#123; // 返回随机值</span><br><span class="line">    println(&quot;The answer is $answer.&quot;) // 此时计算出答案</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    println(&quot;Sometimes no answer is the answer...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有执行到上面needAnswer()为true时，answer才会被初始化。<br>想想是不是我们写的很多初始化的代码，都可以用lazy来延迟初始化了。</p><ul><li>注意<code>by lazy</code>所赋值的变量必须为<code>val</code>类型</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数在kotlin中使用 <code>fun</code> 来表示，函数参数与定义变量一样放在变量后面，参数的类型不可省略，返回值也是在放在参数括号后面，当没有返回值的时候使用<code>Unit</code>代替 java中的<code>void</code>关键字，当然<code>Unit</code>也是可以省略的。下面我们看几个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a: Int, b: Int): Int &#123;</span><br><span class="line">    return a + b</span><br><span class="line">&#125;</span><br><span class="line">// 等同于下面语句，简称函数式表达式</span><br><span class="line">fun sum(a:Int, b:Int) = a + b</span><br><span class="line"></span><br><span class="line">val sum = &#123;x:Int ,y:Int -&gt; x + y&#125;</span><br></pre></td></tr></table></figure></p><p>上面就是一个简单的函数，有参数又返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun printSum(a: Int, b: Int): Unit &#123;</span><br><span class="line">  println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// 等同于下面</span><br><span class="line">fun printSum(a: Int, b: Int) &#123;</span><br><span class="line">  println(&quot;sum of $a and $b is $&#123;a + b&#125;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面则为没有返回值，其可以将函数后面的<code>Unit</code>省略掉。</p><h5 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h5><p>在java中我们如果对同一个方法名，但是有不同的参数个数，需要写多个方法出来，看起来很臃肿，对于少参数的来说，可能就是某个参数为固定或者默认值，那么在kotlin中有了默认参数的表示方式。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a :Int , b : Int = 3) : Int &#123;</span><br><span class="line">    return a +b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用 sum(1,2) // 代表 1 + 2 </span><br><span class="line">//调用 sum (2)  // 代表2 + 3</span><br></pre></td></tr></table></figure></p><h5 id="函数具名参数"><a href="#函数具名参数" class="headerlink" title="函数具名参数"></a>函数具名参数</h5><p>具名参数是对上面的一种特殊情况的考虑，比如我们将上面的代码改为如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun sum(a :Int = 3, b : Int) : Int &#123;</span><br><span class="line">    return a +b</span><br><span class="line">&#125;</span><br><span class="line">//调用 sum (2)   此时对于此调用，编译器认为2 是为a赋值，而b没有赋值，无法编译通过。那么要调用则采用具名参数来指明参数。</span><br><span class="line">// 改为 sum(b = 2) 这样既可指定将2赋值给b，则a使用默认的值。</span><br></pre></td></tr></table></figure></p><h5 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h5><p>在Android可能很常见的是有一个Utils包，专门放置一些常用的公共方法，比如String，Toast，File 操作等等，然而现在kotlin可以直接对系统类，进行扩展。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun Context.toast(message: CharSequence, duration: Int = Toast.LENGTH_SHORT) &#123;</span><br><span class="line">    Toast.makeText(this, message, duration).show()</span><br><span class="line">&#125;</span><br><span class="line">//在Activity，Context实例中就可以直接调用了。</span><br><span class="line">toast(&quot;我是Toast&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面讲述了kotlin 很基础的知识，讲解了些kotlin的特性，当然还有很多的特性，以及在Android上开发的便捷性等等，本篇就先说这么多，下一篇将会说到kotlin更多的特性，比如：自定义类的getter和setter 方法，inline 函数，高阶函数，数据类，单例类等。敬请期待！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h3 id=&quot;想第一时间获取我的最新文章，请关注公众号-技术特工队&quot;&gt;&lt;a href=&quot;#想第一时间获取我的最新文章，请关注公众号-技术特工队&quot; class=&quot;headerlink&quot; title=&quot;想第一时间获取我的最新文章，请关注公众号: 技术特工队&quot;&gt;&lt;/a&gt;想第一时间获取我的最新文章，请关注公众号: &lt;a href=&quot;http://www.wxtlife.com/img/qrcode/qrcode.jpg&quot;&gt;技术特工队&lt;/a&gt;&lt;/h3&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/09/08/kotlin-share-1/&quot;&gt;Kotlin开发基础（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/12/kotlin-share-2/&quot;&gt;Kotlin开发基础（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;http://www.wxtlife.com/2017/12/17/kotlin-share-3/&quot;&gt;Kotlin开发基础（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;为什么学习kotlin&quot;&gt;&lt;a href=&quot;#为什么学习kotlin&quot; class=&quot;headerlink&quot; title=&quot;为什么学习kotlin&quot;&gt;&lt;/a&gt;为什么学习kotlin&lt;/h3&gt;&lt;p&gt;kotlin在今年的Google IO 上正式被确认为Android的官方开发语言，想必原因大家也能猜到一二，一是Google与oracle关于Java相关的版权相关的问题，二是kotlin语言很简洁，不罗嗦，支持很多的新特性。&lt;/p&gt;
&lt;p&gt;由于Google都已经官方支持了，语法简洁高效，和IOS的 swift 很是相似，发展趋势不可小觑，还有个大新闻就是我们的大神 &lt;a href=&quot;https://github.com/JakeWharton&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Jake Wharton&lt;/a&gt; 从square 辞职加入了Google，且其在最近的github中国fork了kotlin 仓库，想必是为kotlin在Android的发展做贡献，就从这可以断定kotlin的未来不会太差， 当然作为技术人就需要不断的学习，不段的挑战。如果想在Android上继续深造kotlin肯定是要学习的。&lt;/p&gt;
&lt;h3 id=&quot;怎么学习&quot;&gt;&lt;a href=&quot;#怎么学习&quot; class=&quot;headerlink&quot; title=&quot;怎么学习&quot;&gt;&lt;/a&gt;怎么学习&lt;/h3&gt;&lt;p&gt;我的想法是，大家都是学过基本的语言的，比如C，C++，做Android的肯定学过Java，所以我的想法是对照Java的基础与kotlin基础做对比着学习， 这样印象会深刻点，差异化学习。&lt;/p&gt;
&lt;h3 id=&quot;Kotlin基础&quot;&gt;&lt;a href=&quot;#Kotlin基础&quot; class=&quot;headerlink&quot; title=&quot;Kotlin基础&quot;&gt;&lt;/a&gt;Kotlin基础&lt;/h3&gt;&lt;h4 id=&quot;Kotlin-数据类型&quot;&gt;&lt;a href=&quot;#Kotlin-数据类型&quot; class=&quot;headerlink&quot; title=&quot;Kotlin 数据类型&quot;&gt;&lt;/a&gt;Kotlin 数据类型&lt;/h4&gt;&lt;p&gt;在kotlin语言中，所有的类型都是都是对象，kotlin中没有了基础数据类型（int，boolean，char，byte）等。全部换为对象类型。类型如下：&lt;br&gt;&lt;code&gt;Int&lt;/code&gt;,&lt;code&gt;Boolean&lt;/code&gt;,&lt;code&gt;String&lt;/code&gt;,&lt;code&gt;Byte&lt;/code&gt;,&lt;code&gt;Float&lt;/code&gt;,&lt;code&gt;Char&lt;/code&gt;,&lt;code&gt;Double&lt;/code&gt;,&lt;code&gt;Short&lt;/code&gt;，这些没有了Java中隐式拓宽转换，例如不能把Int类型直接赋值给Long类型了，如要要这样做这些书类型可以调用如下方法进行转换：&lt;/p&gt;
    
    </summary>
    
      <category term="Kotlin" scheme="http://www.wxtlife.com/categories/Kotlin/"/>
    
    
      <category term="Android" scheme="http://www.wxtlife.com/tags/Android/"/>
    
      <category term="kotlin" scheme="http://www.wxtlife.com/tags/kotlin/"/>
    
  </entry>
  
</feed>
